scilla_version 0

import BoolUtils IntUtils

library ZilSwap

type Pool = | Pool of Uint128 Uint128
type SwapDirection = | ZilToToken | TokenToZil
type ExactSide = | ExactInput | ExactOutput
type Swap = | Swap of (Option Pool) SwapDirection ExactSide Uint128 (Option Uint128) (* exact amt, limit amt *)
type Result =
 | Amount of Uint128
 | Error of String

let zero = Uint128 0
let one = Uint128 1
let min_liquidity = Uint128 100
let after_fee = Uint256 997
let fee_denom = Uint256 1000
let zil_address = 0x0000000000000000000000000000000000000000

let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
      builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the corresponding input or output amount for a pool,
   given the swap direction and an exact output or input amount *)
let resultFor : Pool -> SwapDirection -> ExactSide -> Uint128 -> Option Uint128 =
  fun (pool : Pool) =>
  fun (direction : SwapDirection) =>
  fun (exact_side: ExactSide) =>
  fun (exact_amount: Uint128) =>
    match pool with
    | Pool zil_reserve token_reserve =>
      match direction with
      | ZilToToken =>
        match exact_side with
        | ExactInput =>
          outputFor exact_amount zil_reserve token_reserve
        | ExactOutput =>
          inputFor exact_amount zil_reserve token_reserve
        end
      | TokenToZil =>
        match exact_side with
        | ExactInput =>
          outputFor exact_amount token_reserve zil_reserve
        | ExactOutput =>
          inputFor exact_amount token_reserve zil_reserve
        end
      end
    end

(* checks whether the result amount is within the user provided
   limit amount, which is dependent on whether the output or input
   result was the one being computed *)
let withinLimits : Uint128 -> Option Uint128 -> ExactSide -> Bool =
  fun (result_amount : Uint128) =>
  fun (maybe_limit_amount : Option Uint128) =>
  fun (exact_side : ExactSide) =>
    match maybe_limit_amount with
    | None => True
    | Some limit_amount =>
      match exact_side with
      | ExactInput =>
        (* we are given an exact input and are computing the output,
           which should be greater or equal to the limit *)
        uint128_ge result_amount limit_amount
      | ExactOutput =>
        (* we are given an exact output and are computing the input,
           which should be lower or equal to the limit *)
        uint128_ge limit_amount result_amount
      end
    end

(* computes the resultant amount for the given swap *)
let resultForSwap : Swap -> Result =
  fun (swap : Swap) =>
    match swap with
    | Swap maybe_pool direction exact_side exact_amount maybe_limit_amount =>
      match maybe_pool with
      | None =>
        let e = "MissingPool" in Error e
      | Some pool =>
        let maybe_result = resultFor pool direction exact_side exact_amount in
        match maybe_result with
        | None =>
          let e = "IntegerOverflow" in Error e
        | Some result =>
          let within_limits = withinLimits result maybe_limit_amount exact_side in
          match within_limits with
          | False =>
            let e = "RequestedRatesCannotBeFulfilled" in Error e
          | True =>
            Amount result
          end
        end
      end
    end

(* checks whether the given pool is empty based
   on where either of the token reserve amounts are zero *)
let poolEmpty : Pool -> Bool =
  fun (p : Pool) =>
    match p with
    | Pool x y =>
      let x_empty = builtin lt x one in
      let y_empty = builtin lt y one in
      orb x_empty y_empty
    end

contract ZilSwap
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128

procedure ThrowIfExpired(deadline_block: BNum)
  current_block <- & BLOCKNUMBER;
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    e = { _exception : "TransactionExpired" };
    throw e
  end
end

procedure ThrowIfZero(number: Uint128)
  gt_zero = uint128_gt number zero;
  match gt_zero with
  | True =>
  | False =>
    e = { _exception : "InvalidParameter" };
    throw e
  end
end

procedure Send(
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    msg = { _tag : "AddFunds"; _recipient: _sender; _amount: amount };
    msgs = oneMsg msg;
    send msgs
  | False =>
    msg_to_token =  {
      _tag : "Transfer"; _recipient: token; _amount: zero;
      to: _sender; amount: amount
    };
    msgs = oneMsg msg_to_token;
    send msgs
  end
end

procedure Receive(
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    accept;
    needs_refund = uint128_gt _amount amount;
    match needs_refund with
    | True =>
      refund_amount = builtin sub _amount amount;
      Send zil_address refund_amount
    | False => (* do nothing *)
    end
  | False =>
    msg_to_token = {
      _tag : "TransferFrom"; _recipient: token; _amount: zero;
      from: _sender; to: _this_address; amount: amount
    };
    msgs = oneMsg msg_to_token;
    send msgs
  end
end

procedure UpdatePool(
  maybe_pool: Option Pool,
  token_address: ByStr20,
  address: ByStr20,
  zil_in: Uint128,
  token_in: Uint128,
  zil_out: Uint128,
  token_out: Uint128
)
  match maybe_pool with
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      new_pool =
      let new_x = let x_add = builtin add x zil_in in builtin sub x_add zil_out in
      let new_y = let y_add = builtin add y token_in in builtin sub y_add token_out in
      Pool new_x new_y;
      pools[token_address] := new_pool;

      e = {
        _eventname: "Swap"; pool: token_address; address: address;
        zil_in: zil_in; token_in: token_in;
        zil_out: zil_out; token_out: token_out
      };
      event e
    end
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  end
end

transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address in
    let is_transfer_to_self = builtin eq recipient _this_address in
    andb self_triggered is_transfer_to_self;

  match is_valid_transfer_to_self with
  | False =>
    e = { _exception : "InvalidInvocation" };
    throw e
  | True => (* noop *)
  end
end

transition TransferFromSuccessCallBack(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition TransferSuccessCallBack(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero _amount;
  ThrowIfZero max_token_amount;

  Receive zil_address _amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    min_zil_contributed = uint128_ge _amount min_liquidity;
    match min_zil_contributed with
    | False =>
      e = { _exception : "InvalidParameter" };
      throw e
    | True =>
      Receive token_address max_token_amount;

      new_pool = Pool _amount max_token_amount;
      pools[token_address] := new_pool;
      e1 = { _eventname: "PoolCreated"; pool: token_address };
      event e1;

      balances[token_address][_sender] := _amount;
      total_contributions[token_address] := _amount;
      e2 = { _eventname: "Mint"; pool: token_address; address: _sender; amount: _amount };
      event e2
    end
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)

      (* dY = dX * Y / X + 1 *)
      (* dX is always the QA transferred *)
      maybe_result = frac _amount x y;
      match maybe_result with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some result =>
        delta_y = builtin add result one;
        maybe_total_contribution <- total_contributions[token_address];
        match maybe_total_contribution with
        | None =>
          e = { _exception : "MissingContributions" };
          throw e
        | Some total_contribution =>
          maybe_new_contribution = frac _amount x total_contribution;
          match maybe_new_contribution with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some new_contribution =>
            within_limits =
              let token_lte_max = uint128_le delta_y max_token_amount in
              let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
              andb token_lte_max contribution_gte_max;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y };
              throw e
            | True =>
              Receive token_address delta_y;

              new_pool =
                let new_x = builtin add x _amount in
                let new_y = builtin add y delta_y in
                Pool new_x new_y;
              pools[token_address] := new_pool;

              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | Some b =>
                new_balance = builtin add b new_contribution;
                balances[token_address][_sender] := new_balance
              | None =>
                balances[token_address][_sender] := new_contribution
              end;

              new_total_contribution = builtin add total_contribution new_contribution;
              total_contributions[token_address] := new_total_contribution;

              e = { _eventname: "Mint"; pool: token_address; address: _sender; amount: new_contribution };
              event e
            end
          end
        end
      end
    end
  end
end

transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128,
  min_zil_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero contribution_amount;
  ThrowIfZero min_zil_amount;
  ThrowIfZero min_token_amount;

  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some total_contribution =>
    ThrowIfZero total_contribution;
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_amount = frac contribution_amount total_contribution x;
        maybe_token_amount = frac contribution_amount total_contribution y;
        match maybe_zil_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount =>
            within_limits =
              let zil_ok = uint128_ge zil_amount min_zil_amount in
              let token_ok = uint128_ge token_amount min_token_amount in
              andb zil_ok token_ok;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | None =>
                e = { _exception : "MissingBalance" };
                throw e
              | Some b =>
                new_pool =
                  let new_x = builtin sub x zil_amount in
                  let new_y = builtin sub y token_amount in
                  Pool new_x new_y;

                is_pool_now_empty = poolEmpty new_pool;
                match is_pool_now_empty with
                | True =>
                  delete pools[token_address];
                  delete balances[token_address];
                  delete total_contributions[token_address]
                | False =>
                  pools[token_address] := new_pool;
                  new_balance = builtin sub b contribution_amount;
                  balances[token_address][_sender] := new_balance;
                  new_total_contribution = builtin sub total_contribution contribution_amount;
                  total_contributions[token_address] := new_total_contribution
                end;

                Send zil_address zil_amount;
                Send token_address token_amount;

                e = { _eventname: "Burn"; pool: token_address; address: _sender; amount: contribution_amount };
                event e
              end
            end
          end
        end
      end
    end
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  (* _amount: the zil amount to be sent in *)
  min_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero _amount;
  ThrowIfZero min_token_amount;

  pool <- pools[token_address];

  result =
    let direction = ZilToToken in
    let exact_side = ExactInput in
    let limit_amount = Some {Uint128} min_token_amount in
    let swap = Swap pool direction exact_side _amount limit_amount in
      resultForSwap swap;

  match result with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Amount token_amount =>
    Receive zil_address _amount;
    Send token_address token_amount;
    UpdatePool pool token_address _sender _amount zero zero token_amount
  end
end

transition SwapExactTokensForZIL(
  token_address : ByStr20,
  token_amount : Uint128,
  min_zil_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero token_amount;
  ThrowIfZero min_zil_amount;

  pool <- pools[token_address];

  result =
    let direction = TokenToZil in
    let exact_side = ExactInput in
    let limit_amount = Some {Uint128} min_zil_amount in
    let swap = Swap pool direction exact_side _amount limit_amount in
      resultForSwap swap;

  match result with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Amount zil_amount =>
    Receive token_address token_amount;
    Send zil_address zil_amount;
    UpdatePool pool token_address _sender zero token_amount zil_amount zero
  end
end

transition SwapZILForExactTokens(
  token_address : ByStr20,
  (* _amount: the max zil amount to be sent in *)
  token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero _amount;
  ThrowIfZero token_amount;

  pool <- pools[token_address];

  result =
    let direction = ZilToToken in
    let exact_side = ExactOutput in
    let limit_amount = Some {Uint128} _amount in
    let swap = Swap pool direction exact_side token_amount limit_amount in
      resultForSwap swap;

  match result with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Amount zil_amount =>
    Receive zil_address zil_amount;
    Send token_address token_amount;
    UpdatePool pool token_address _sender zil_amount zero zero token_amount
  end
end

transition SwapTokensForExactZIL(
  token_address : ByStr20,
  max_token_amount : Uint128,
  zil_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero zil_amount;
  ThrowIfZero max_token_amount;

  pool <- pools[token_address];

  result =
    let direction = TokenToZil in
    let exact_side = ExactOutput in
    let limit_amount = Some {Uint128} max_token_amount in
    let swap = Swap pool direction exact_side zil_amount limit_amount in
      resultForSwap swap;

  match result with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Amount token_amount =>
    Receive token_address token_amount;
    Send zil_address zil_amount;
    UpdatePool pool token_address _sender zero token_amount zil_amount zero
  end
end

transition SwapExactTokensForTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  token0_amount : Uint128, (* the token0 amount to be sent in *)
  min_token1_amount : Uint128, (* min token0 amount that must be received for the txn to not revert *)
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero token0_amount;
  ThrowIfZero min_token1_amount;

  pool0 <- pools[token0_address];

  result0 =
    let direction = TokenToZil in
    let exact_side = ExactInput in
    let limit_amount = None {Uint128} in
    let swap = Swap pool0 direction exact_side token0_amount limit_amount in
      resultForSwap swap;

  match result0 with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Amount zil_intermediate_amount =>
    pool1 <- pools[token1_address];

    result1 =
      let direction = ZilToToken in
      let exact_side = ExactInput in
      let limit_amount = Some {Uint128} min_token1_amount in
      let swap = Swap pool1 direction exact_side zil_intermediate_amount limit_amount in
        resultForSwap swap;

    match result1 with
    | Error msg =>
      e = { _exception : msg };
      throw e
    | Amount output_amount =>
      Receive token0_address token0_amount;
      UpdatePool pool0 token0_address _sender zero token0_amount zil_intermediate_amount zero;
      Send token1_address output_amount;
      UpdatePool pool1 token1_address _sender zil_intermediate_amount zero zero output_amount
    end
  end
end

transition SwapTokensForExactTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  max_token0_amount : Uint128, (* the max token0 amount that may be sent in before the txn will revert *)
  token1_amount : Uint128, (* token1 amount to be received *)
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero max_token0_amount;
  ThrowIfZero token1_amount;

  pool1 <- pools[token1_address];

  result1 =
    let direction = ZilToToken in
    let exact_side = ExactOutput in
    let limit_amount = None {Uint128} in
    let swap = Swap pool1 direction exact_side token1_amount limit_amount in
      resultForSwap swap;

  match result1 with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Amount zil_intermediate_amount =>
    pool0 <- pools[token0_address];

    result0 =
      let direction = TokenToZil in
      let exact_side = ExactOutput in
      let limit_amount = Some {Uint128} max_token0_amount in
      let swap = Swap pool1 direction exact_side zil_intermediate_amount limit_amount in
        resultForSwap swap;

    match result0 with
    | Error msg =>
      e = { _exception : msg };
      throw e
    | Amount input_amount =>
      Receive token0_address input_amount;
      UpdatePool pool0 token0_address _sender zero input_amount zil_intermediate_amount zero;
      Send token1_address token1_amount;
      UpdatePool pool1 token1_address _sender zil_intermediate_amount zero zero token1_amount
    end
  end
end
