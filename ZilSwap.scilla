scilla_version 0

import BoolUtils IntUtils ListUtils

library ZilSwap

type Pool =
  | Pool of Uint128 Uint128

let zero = Uint128 0
let one = Uint128 0
let two = Uint128 0
let three = Uint128 3
let after_fee = Uint256 997
let fee_denom = Uint256 1000
let zil_address = 0x0000000000000000000000000000000000000000

let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

let addBoolList : Bool -> List Bool -> List Bool =
  fun (bool : Bool) =>
  fun (list : List Bool) =>
    Cons {Bool} bool list

let allTrue : List Bool -> Bool =
  fun (list : List Bool) =>
    let isTrue = fun (bool : Bool) => bool in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool isTrue list

let andb3 : Bool -> Bool -> Bool -> Bool =
  fun (b1: Bool) =>
  fun (b2: Bool) =>
  fun (b3: Bool) =>
    let b12 = andb b1 b2 in
    andb b12 b3

let btwn : Uint128 -> Uint128 -> Uint128 -> Bool =
  fun (min : Uint128) =>
  fun (var : Uint128) =>
  fun (max : Uint128) =>
    let gtm = uint128_gt min var in
    let ltm = uint128_lt var max in
    andb gtm ltm

(* computes the amount of the fraction d / x that is in y *)
(* TODO: we should grow all uint128 to 256 at the start to reduce need for type checking *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
      builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

let sqrt : Nat -> Nat =
  fun (n : Nat) =>
  let folder = @nat_fold (Pair (Pair Nat Nat) Nat) in
  let zero = Zero in
  let p00 = Pair {Nat Nat} zero zero in
  let init = Pair {(Pair Nat Nat) Nat} p00 zero in
  let f = fun (acc : Pair (Pair Nat Nat) Nat) => fun (unused : Nat) =>
    match acc with
    | Pair (Pair p q) r =>
      match r with
      | Zero => let sp = Succ p in
                let sq = Succ q in
                let ssq = Succ sq in
                let new_pq = Pair {Nat Nat} sp ssq in
                let new_r = ssq in
                Pair {(Pair Nat Nat) Nat} new_pq new_r
      | Succ r1 =>
                let pq = Pair {Nat Nat} p q in
                Pair {(Pair Nat Nat) Nat} pq r1
      end
    end in
  let res = folder f init n in
  match res with
  | Pair (Pair sqrt _) _ => sqrt
  end

contract ZilSwap
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128

procedure Receive(
  from : ByStr20,
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    valid_transfer =
      let correct_sender = builtin eq from _sender in
      let correct_amount_transferred = builtin eq amount _amount in
      andb correct_sender correct_amount_transferred;
    match valid_transfer with
    | True =>
      accept
    | False =>
      e = { _exception : "ReceiveFailed" };
      throw e
    end
  | False =>
    msg_to_token = {
      _tag : "TransferFrom"; _recipient: token; _amount: zero;
      from: from; to: _this_address; amount: amount
    };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg_to_token nil;
    send msgs
  end
end

procedure Send(
  to : ByStr20,
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    msg = { _tag : "_"; _recipient: to; _amount: amount };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg nil;
    send msgs
  | False =>
    msg_to_token = {
      _tag : "Transfer"; _recipient: token; _amount: zero;
      from: _this_address; to: to; amount: amount
    };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg_to_token nil;
    send msgs
  end
end

transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  (* here we just check that the transfer from is triggered from this contract
    and the recipient is this contract. does not check the sender, token, or amount. *)
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address in
    let is_transfer_to_self = builtin eq recipient _this_address in
    andb self_triggered is_transfer_to_self;

  match is_valid_transfer_to_self with
  | False =>
    e = { _exception : "InvalidInvocation" };
    throw e
  | True => (* noop *)
  end
end

transition TransferFromSuccessCallBack(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  (* no-op, nothing needed here as we handle transfer receipt in RecipientAcceptTransferFrom  *)
end

transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128, (* the minimum contribution, which is determined by zil sent / zil reserve * total contribution *)
  max_token_amount : Uint128, (* the maximum amount of tokens to transfer; this is directly used for new pools *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_zil = uint128_gt _amount zero in
    let has_token = uint128_gt max_token_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in negb expired
    in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    Receive _sender zil_address _amount;

    maybe_pool <- pools[token_address];

    (* dumb adding for now *)
    match maybe_pool with
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)

        (* dY = dX * Y / X + 1 *)
        (* dX is always the QA transferred *)
        delta_y = zero;
        maybe_result = frac _amount x y;
        match maybe_result with
        | Some result =>
          delta_y = builtin add result one
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        end;

        total_contribution = zero;
        maybe_total_contribution <- total_contributions[token_address];
        match maybe_total_contribution with
        | Some c =>
          total_contribution = c
        | None =>
          e = { _exception : "MissingContributions" };
          throw e
        end;

        new_contribution = zero;
        maybe_new_contribution = frac _amount total_contribution x;
        match maybe_new_contribution with
        | Some c =>
          new_contribution = c
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        end;

        within_limits =
          let token_lte_max = uint128_le delta_y max_token_amount in
          let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
          andb token_lte_max contribution_gte_max;

        match within_limits with
        | False =>
          e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y };
          throw e
        | True =>
          new_pool =
            let new_x = builtin add x _amount in
            let new_y = builtin add y delta_y in
            Pool new_x new_y;
          pools[token_address] := new_pool;

          existing_balance <- balances[token_address][_sender];
          match existing_balance with
          | Some b =>
            new_balance = builtin add b new_contribution;
            balances[token_address][_sender] := new_balance
          | None =>
            balances[token_address][_sender] := new_contribution
          end;

          new_total_contribution = builtin add total_contribution new_contribution;
          total_contributions[token_address] := new_total_contribution;
          Receive _sender token_address delta_y
        end
      end
    | None =>
      Receive _sender token_address max_token_amount;
      new_pool = Pool _amount max_token_amount;
      pools[token_address] := new_pool;
      balances[token_address][_sender] := _amount;
      total_contributions[token_address] := _amount
    end
  end

  (* TODO: log effects *)
end

transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128, (* the contribution amount to remove *)
  min_zil_amount : Uint128, (* the min amount of zil to withdraw *)
  min_token_amount : Uint128, (* the min amount of tokens to withdraw *)
  deadline_block : BNum
)

  validity_checks = Nil {Bool};

  current_block <- & BLOCKNUMBER;

  validity_checks =
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    addBoolList is_not_expired validity_checks;

  validity_checks =
    let has_amount = uint128_neq contribution_amount zero in
    addBoolList has_amount validity_checks;

  validity_checks =
    let has_amount = uint128_neq min_zil_amount zero in
    addBoolList has_amount validity_checks;

  validity_checks =
    let has_amount = uint128_neq min_token_amount zero in
    addBoolList has_amount validity_checks;

  is_valid_transaction = allTrue validity_checks;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    Receive _sender zil_address _amount;

    total_contribution = zero;
    maybe_total_contribution <- total_contributions[token_address];
    match maybe_total_contribution with
    | Some c =>
      c_gt_zero = builtin lt zero c;
      match c_gt_zero with
      | True =>
        total_contribution = c
      | False =>
        e = { _exception : "MissingContributions" };
        throw e
      end
    | None =>
      e = { _exception : "MissingContributions" };
      throw e
    end;

    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_amount = frac contribution_amount x total_contribution;
        maybe_token_amount = frac contribution_amount y total_contribution;

        match maybe_zil_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount =>

            within_limits =
              let zil_ok = uint128_ge zil_amount min_zil_amount in
              let token_ok = uint128_ge token_amount min_token_amount in
              andb zil_ok token_ok;

            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | Some b =>
                new_balance = builtin sub b contribution_amount;
                balances[token_address][_sender] := new_balance;
                new_total_contribution = builtin sub total_contribution contribution_amount;
                total_contributions[token_address] := new_total_contribution;

                Send _sender zil_address zil_amount;
                Send _sender token_address token_amount
              | None =>
                e = { _exception : "MissingBalance" };
                throw e
              end
            end

          end
        end
      end
    end
  end

  (* TODO: log effects *)
end

transition BuyTokens(
  token_address : ByStr20,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_zil = uint128_gt _amount zero in
    let has_token = uint128_gt min_token_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_tokens_bought = outputFor _amount x y;
        match maybe_tokens_bought with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some tokens_bought =>
            within_limits = uint128_ge tokens_bought min_token_amount;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              Receive _sender zil_address _amount;
              Send _sender token_address tokens_bought
            end
        end
      end
    end
  end

  (* TODO: log effects *)
end

transition SellTokens(
  token_address : ByStr20,
  token_amount : Uint128,
  min_zil_amount : Uint128,
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token = uint128_gt token_amount zero in
    let has_zil = uint128_gt min_zil_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_bought = outputFor token_amount y x;
        match maybe_zil_bought with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_bought =>
            within_limits = uint128_ge zil_bought min_zil_amount;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              Receive _sender token_address token_amount;
              Send _sender zil_address zil_bought
            end
        end
      end
    end
  end

  (* TODO: log effects *)
end

transition BuyTokensWithExactOutput(
  token_address : ByStr20,
  token_amount : Uint128,
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token = uint128_gt token_amount zero in
    let has_zil = uint128_gt _amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_amount = inputFor token_amount x y;
        match maybe_zil_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_amount =>
          refund_amount = builtin sub _amount zil_amount;
          Receive _sender zil_address token_amount;
          Send _sender zil_address refund_amount;
          Send _sender token_address token_amount
        end
      end
    end
  end

  (* TODO: log effects *)
end

transition SellTokensWithExactOutput(
  token_address : ByStr20,
  zil_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token = uint128_gt max_token_amount zero in
    let has_zil = uint128_gt zil_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_token_amount = inputFor zil_amount y x;
        match maybe_token_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some token_amount =>
          within_limits = uint128_ge max_token_amount token_amount;
          match within_limits with
          | False =>
            e = { _exception : "RequestedRatesCannotBeFulfilled" };
            throw e
          | True =>
            Receive _sender token_address token_amount;
            Send _sender zil_address zil_amount
          end
        end
      end
    end
  end

  (* TODO: log effects *)
end

transition BuyTokensWithTokens(
)
end

transition SellTokensWithTokens(
)
end

transition BuyTokensWithTokensWithExactOutput(
)
end

transition SellTokensWithTokensWithExactOutput(

)
end
