scilla_version 0

import BoolUtils IntUtils ListUtils

library ZilSwap

type Pool =
  | Pool of Uint128 Uint128

let zero = Uint128 0
let one = Uint128 0
let two = Uint128 0
let three = Uint128 3
let after_fee = Uint256 997
let fee_denom = Uint256 1000
let zil_address = 0x0000000000000000000000000000000000000000

let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

let addBoolList : Bool -> List Bool -> List Bool =
  fun (bool : Bool) =>
  fun (list : List Bool) =>
    Cons {Bool} bool list

let allTrue : List Bool -> Bool =
  fun (list : List Bool) =>
    let isTrue = fun (bool : Bool) => bool in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool isTrue list

let andb3 : Bool -> Bool -> Bool -> Bool =
  fun (b1: Bool) =>
  fun (b2: Bool) =>
  fun (b3: Bool) =>
    let b12 = andb b1 b2 in
    andb b12 b3

let btwn : Uint128 -> Uint128 -> Uint128 -> Bool =
  fun (min : Uint128) =>
  fun (var : Uint128) =>
  fun (max : Uint128) =>
    let gtm = uint128_gt min var in
    let ltm = uint128_lt var max in
    andb gtm ltm

(* computes the amount of the fraction d / x that is in y *)
(* TODO: we should grow all uint128 to 256 at the start to reduce need for type checking *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
      builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

contract ZilSwap
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128

procedure Receive(
  from : ByStr20,
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    valid_transfer =
      let correct_sender = builtin eq from _sender in
      let correct_amount_transferred = builtin eq amount _amount in
      andb correct_sender correct_amount_transferred;
    match valid_transfer with
    | True =>
      accept
    | False =>
      e = { _exception : "ReceiveFailed" };
      throw e
    end
  | False =>
    msg_to_token = {
      _tag : "TransferFrom"; _recipient: token; _amount: zero;
      from: from; to: _this_address; amount: amount
    };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg_to_token nil;
    send msgs
  end
end

procedure Send(
  to : ByStr20,
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    msg = { _tag : ""; _recipient: to; _amount: amount };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg nil;
    send msgs
  | False =>
    msg_to_token = {
      _tag : "Transfer"; _recipient: token; _amount: zero;
      from: _this_address; to: to; amount: amount
    };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg_to_token nil;
    send msgs
  end
end

procedure UpdatePool(
  pool : Pool,
  token_address: ByStr20,
  zil_in: Uint128,
  token_in: Uint128,
  zil_out: Uint128,
  token_out: Uint128
)
  match pool with
  | Pool x y => (* zil reserve, token reserve *)
    new_pool =
    let new_x = let x_add = builtin add x zil_in in builtin sub x_add zil_out in
    let new_y = let y_add = builtin add y token_in in builtin sub y_add token_out in
    Pool new_x new_y;
    pools[token_address] := new_pool;

    e = { _eventname: "Swap"; token_address: token_address;
      zil_in: zil_in; token_in: token_in;
      zil_out: zil_out; token_out: token_out };
    event e
  end
end

transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  (* here we just check that the transfer from is triggered from this contract
    and the recipient is this contract. does not check the sender, token, or amount. *)
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address in
    let is_transfer_to_self = builtin eq recipient _this_address in
    andb self_triggered is_transfer_to_self;

  match is_valid_transfer_to_self with
  | False =>
    e = { _exception : "InvalidInvocation" };
    throw e
  | True => (* noop *)
  end
end

transition TransferFromSuccessCallBack(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  (* no-op, nothing needed here as we handle transfer receipt in RecipientAcceptTransferFrom  *)
end

transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128, (* the minimum contribution to add, which is determined by zil sent / zil reserve * total contribution *)
  max_token_amount : Uint128, (* the maximum amount of tokens to transfer for the txn to not revert; this is directly used for new pools and will never revert *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_zil = uint128_gt _amount zero in
    let has_token = uint128_gt max_token_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in negb expired
    in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    Receive _sender zil_address _amount;

    maybe_pool <- pools[token_address];

    (* dumb adding for now *)
    match maybe_pool with
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)

        (* dY = dX * Y / X + 1 *)
        (* dX is always the QA transferred *)
        delta_y = zero;
        maybe_result = frac _amount x y;
        match maybe_result with
        | Some result =>
          delta_y = builtin add result one
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        end;

        total_contribution = zero;
        maybe_total_contribution <- total_contributions[token_address];
        match maybe_total_contribution with
        | Some c =>
          total_contribution = c
        | None =>
          e = { _exception : "MissingContributions" };
          throw e
        end;

        new_contribution = zero;
        maybe_new_contribution = frac _amount total_contribution x;
        match maybe_new_contribution with
        | Some c =>
          new_contribution = c
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        end;

        within_limits =
          let token_lte_max = uint128_le delta_y max_token_amount in
          let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
          andb token_lte_max contribution_gte_max;

        match within_limits with
        | False =>
          e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y };
          throw e
        | True =>
          Receive _sender token_address delta_y;

          new_pool =
            let new_x = builtin add x _amount in
            let new_y = builtin add y delta_y in
            Pool new_x new_y;
          pools[token_address] := new_pool;

          existing_balance <- balances[token_address][_sender];
          match existing_balance with
          | Some b =>
            new_balance = builtin add b new_contribution;
            balances[token_address][_sender] := new_balance
          | None =>
            balances[token_address][_sender] := new_contribution
          end;

          new_total_contribution = builtin add total_contribution new_contribution;
          total_contributions[token_address] := new_total_contribution;

          e = { _eventname: "Mint"; address: _sender; amount: new_contribution };
          event e
        end
      end
    | None =>
      Receive _sender token_address max_token_amount;

      new_pool = Pool _amount max_token_amount;
      pools[token_address] := new_pool;
      e1 = { _eventname: "PoolCreated"; token: token_address };
      event e1;

      balances[token_address][_sender] := _amount;
      total_contributions[token_address] := _amount;
      e2 = { _eventname: "Mint"; address: _sender; amount: _amount };
      event e2
    end
  end
end

transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128, (* the desired contribution amount to remove *)
  min_zil_amount : Uint128, (* the min amount of zil to withdraw for the txn to not revert *)
  min_token_amount : Uint128, (* the min amount of tokens to withdraw for the txn to not revert *)
  deadline_block : BNum
)

  validity_checks = Nil {Bool};

  current_block <- & BLOCKNUMBER;

  validity_checks =
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    addBoolList is_not_expired validity_checks;

  validity_checks =
    let has_amount = uint128_neq contribution_amount zero in
    addBoolList has_amount validity_checks;

  validity_checks =
    let has_amount = uint128_neq min_zil_amount zero in
    addBoolList has_amount validity_checks;

  validity_checks =
    let has_amount = uint128_neq min_token_amount zero in
    addBoolList has_amount validity_checks;

  is_valid_transaction = allTrue validity_checks;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    Receive _sender zil_address _amount;

    total_contribution = zero;
    maybe_total_contribution <- total_contributions[token_address];
    match maybe_total_contribution with
    | Some c =>
      c_gt_zero = builtin lt zero c;
      match c_gt_zero with
      | True =>
        total_contribution = c
      | False =>
        e = { _exception : "MissingContributions" };
        throw e
      end
    | None =>
      e = { _exception : "MissingContributions" };
      throw e
    end;

    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_amount = frac contribution_amount x total_contribution;
        maybe_token_amount = frac contribution_amount y total_contribution;

        match maybe_zil_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount =>

            within_limits =
              let zil_ok = uint128_ge zil_amount min_zil_amount in
              let token_ok = uint128_ge token_amount min_token_amount in
              andb zil_ok token_ok;

            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | Some b =>
                new_pool =
                  let new_x = builtin sub x zil_amount in
                  let new_y = builtin sub y token_amount in
                  Pool new_x new_y;
                pools[token_address] := new_pool;

                new_balance = builtin sub b contribution_amount;
                balances[token_address][_sender] := new_balance;
                new_total_contribution = builtin sub total_contribution contribution_amount;
                total_contributions[token_address] := new_total_contribution;

                Send _sender zil_address zil_amount;
                Send _sender token_address token_amount;

                e = { _eventname: "Burn"; address: _sender; amount: contribution_amount };
                event e
              | None =>
                e = { _exception : "MissingBalance" };
                throw e
              end
            end
          end
        end
      end
    end
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  (* _amount: the zil amount to be sent in *)
  min_token_amount : Uint128, (* the min token amount that must be received for the txn to not revert *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_zil = uint128_gt _amount zero in
    let has_token = uint128_gt min_token_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_tokens_bought = outputFor _amount x y;
        match maybe_tokens_bought with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some tokens_bought =>
          within_limits = uint128_ge tokens_bought min_token_amount;
          match within_limits with
          | False =>
            e = { _exception : "RequestedRatesCannotBeFulfilled" };
            throw e
          | True =>
            Receive _sender zil_address _amount;
            Send _sender token_address tokens_bought;
            UpdatePool pool token_address _amount zero zero tokens_bought
          end
        end
      end
    end
  end
end

transition SwapExactTokensForZIL(
  token_address : ByStr20,
  token_amount : Uint128, (* amount of tokens to send in *)
  min_zil_amount : Uint128, (* min zil amount that must be received for the txn to not revert *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token = uint128_gt token_amount zero in
    let has_zil = uint128_gt min_zil_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_bought = outputFor token_amount y x;
        match maybe_zil_bought with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_bought =>
          within_limits = uint128_ge zil_bought min_zil_amount;
          match within_limits with
          | False =>
            e = { _exception : "RequestedRatesCannotBeFulfilled" };
            throw e
          | True =>
            Receive _sender token_address token_amount;
            Send _sender zil_address zil_bought;
            UpdatePool pool token_address zero token_amount zil_bought zero
          end
        end
      end
    end
  end
end

transition SwapZILForExactTokens(
  token_address : ByStr20,
  (* _amount: the max zil amount to be sent in *)
  token_amount : Uint128, (* the amount of tokens to receive *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token = uint128_gt token_amount zero in
    let has_zil = uint128_gt _amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_amount = inputFor token_amount x y;
        match maybe_zil_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_amount =>
          refund_amount = builtin sub _amount zil_amount;
          Receive _sender zil_address token_amount;
          Send _sender zil_address refund_amount;
          Send _sender token_address token_amount;
          UpdatePool pool token_address zil_amount zero zero token_amount
        end
      end
    end
  end
end

transition SwapTokensForExactZIL(
  token_address : ByStr20,
  zil_amount : Uint128, (* the zil amount to be received *)
  max_token_amount : Uint128, (* max token amount that may be sent before the txn will revert *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token = uint128_gt max_token_amount zero in
    let has_zil = uint128_gt zil_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_zil has_token is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_token_amount = inputFor zil_amount y x;
        match maybe_token_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some token_amount =>
          within_limits = uint128_ge max_token_amount token_amount;
          match within_limits with
          | False =>
            e = { _exception : "RequestedRatesCannotBeFulfilled" };
            throw e
          | True =>
            Receive _sender token_address token_amount;
            Send _sender zil_address zil_amount;
            UpdatePool pool token_address zero token_amount zil_amount zero
          end
        end
      end
    end
  end
end

transition SwapExactTokensForTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  token0_amount : Uint128, (* the token0 amount to be sent in *)
  min_token1_amount : Uint128, (* min token0 amount that must be received for the txn to not revert *)
  deadline_block : BNum
)

  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token0 = uint128_gt token0_amount zero in
    let has_token1 = uint128_gt min_token1_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_token0 has_token1 is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool0 <- pools[token0_address];
    match maybe_pool0 with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool0 =>
      match pool0 with
      | Pool x0 y0 => (* zil reserve, token reserve *)
        maybe_zil_intermediate = outputFor token0_amount y0 x0;
        match maybe_zil_intermediate with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_intermediate =>
          maybe_pool1 <- pools[token1_address];
          match maybe_pool1 with
          | None =>
            e = { _exception : "MissingPool" };
            throw e
          | Some pool1 =>
            match pool1 with
            | Pool x1 y1 => (* zil reserve, token reserve *)
              maybe_tokens_bought = outputFor zil_intermediate x1 y1;
              match maybe_tokens_bought with
              | None =>
                e = { _exception : "IntegerOverflow" };
                throw e
              | Some tokens_bought =>
                within_limits = uint128_ge tokens_bought min_token1_amount;
                match within_limits with
                | False =>
                  e = { _exception : "RequestedRatesCannotBeFulfilled" };
                  throw e
                | True =>
                  Receive _sender token0_address token0_amount;
                  UpdatePool pool0 token0_address zero token0_amount zil_intermediate zero;
                  Send _sender token1_address tokens_bought;
                  UpdatePool pool1 token1_address zil_intermediate zero zero tokens_bought
                end
              end
            end
          end
        end
      end
    end
  end
end

transition SwapTokensForExactTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  max_token0_amount : Uint128, (* the max token0 amount that may be sent in before the txn will revert *)
  token1_amount : Uint128, (* token1 amount to be received *)
  deadline_block : BNum
)
  (* check transition validity *)
  current_block <- & BLOCKNUMBER;
  is_valid_transaction =
    let has_token0 = uint128_gt max_token0_amount zero in
    let has_token1 = uint128_gt token1_amount zero in
    let is_not_expired =
      let expired = builtin blt current_block deadline_block in
      negb expired in
    andb3 has_token0 has_token1 is_not_expired;

  match is_valid_transaction with
  | False =>
    e = { _exception : "TransactionInvalidOrExpired" };
    throw e
  | True =>
    maybe_pool1 <- pools[token1_address];
    match maybe_pool1 with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool1 =>
      match pool1 with
      | Pool x1 y1 => (* zil reserve, token reserve *)
        maybe_zil_intermediate = inputFor token1_amount x1 y1;
        match maybe_zil_intermediate with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_intermediate =>
          maybe_pool0 <- pools[token0_address];
          match maybe_pool0 with
          | None =>
            e = { _exception : "MissingPool" };
            throw e
          | Some pool0 =>
            match pool0 with
            | Pool x0 y0 => (* zil reserve, token reserve *)
              maybe_token_amount = inputFor zil_intermediate y0 x0;
              match maybe_token_amount with
              | None =>
                e = { _exception : "IntegerOverflow" };
                throw e
              | Some token_amount =>
                within_limits = uint128_ge max_token0_amount token_amount;
                match within_limits with
                | False =>
                  e = { _exception : "RequestedRatesCannotBeFulfilled" };
                  throw e
                | True =>
                  Receive _sender token0_address token_amount;
                  UpdatePool pool0 token0_address zero token_amount zil_intermediate zero;
                  Send _sender token1_address token1_amount;
                  UpdatePool pool1 token1_address zil_intermediate zero zero token1_amount
                end
              end
            end
          end
        end
      end
    end
  end
end
