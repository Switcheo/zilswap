scilla_version 0

import BoolUtils IntUtils ListUtils

library ZilSwap

type Pool =
  | Pool of Uint128 Uint128

let zero = Uint128 0
let one = Uint128 1
let min_liquidity = Uint128 100
let after_fee = Uint256 997
let fee_denom = Uint256 1000
let zil_address = 0x0000000000000000000000000000000000000000

let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* computes the amount of the fraction d / x that is in y *)
(* TODO: we should grow all uint128 to 256 at the start to reduce need for type checking *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
      builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result

contract ZilSwap
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128

procedure ThrowIfExpired(deadline_block: BNum)
  current_block <- & BLOCKNUMBER;
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    e = { _exception : "TransactionExpired" };
    throw e
  end
end

procedure ThrowIfZero(number: Uint128)
  gt_zero = uint128_gt number zero;
  match gt_zero with
  | True =>
  | False =>
    e = { _exception : "InvalidParameter" };
    throw e
  end
end

procedure Receive(
  from : ByStr20,
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    valid_transfer =
      let correct_sender = builtin eq from _sender in
      let correct_amount_transferred = builtin eq amount _amount in
      andb correct_sender correct_amount_transferred;
    match valid_transfer with
    | True =>
      accept
    | False =>
      e = { _exception : "ReceiveFailed" };
      throw e
    end
  | False =>
    msg_to_token = {
      _tag : "TransferFrom"; _recipient: token; _amount: zero;
      from: from; to: _this_address; amount: amount
    };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg_to_token nil;
    send msgs
  end
end

procedure Send(
  to : ByStr20,
  token : ByStr20,
  amount : Uint128
)
  is_zil = builtin eq token zil_address;
  match is_zil with
  | True =>
    msg = { _tag : ""; _recipient: to; _amount: amount };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg nil;
    send msgs
  | False =>
    msg_to_token = {
      _tag : "Transfer"; _recipient: token; _amount: zero;
      to: to; amount: amount
    };
    msgs =
      let nil = Nil {Message} in
      Cons {Message} msg_to_token nil;
    send msgs
  end
end

procedure UpdatePool(
  pool: Pool,
  token_address: ByStr20,
  address: ByStr20,
  zil_in: Uint128,
  token_in: Uint128,
  zil_out: Uint128,
  token_out: Uint128
)
  match pool with
  | Pool x y => (* zil reserve, token reserve *)
    new_pool =
    let new_x = let x_add = builtin add x zil_in in builtin sub x_add zil_out in
    let new_y = let y_add = builtin add y token_in in builtin sub y_add token_out in
    Pool new_x new_y;
    pools[token_address] := new_pool;

    e = {
      _eventname: "Swap"; pool: token_address; address: address;
      zil_in: zil_in; token_in: token_in;
      zil_out: zil_out; token_out: token_out
    };
    event e
  end
end

transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address in
    let is_transfer_to_self = builtin eq recipient _this_address in
    andb self_triggered is_transfer_to_self;

  match is_valid_transfer_to_self with
  | False =>
    e = { _exception : "InvalidInvocation" };
    throw e
  | True => (* noop *)
  end
end

transition TransferFromSuccessCallBack(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition TransferSuccessCallBack(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero _amount;
  ThrowIfZero max_token_amount;

  Receive _sender zil_address _amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    min_zil_contributed = uint128_ge _amount min_liquidity;
    match min_zil_contributed with
    | False =>
      e = { _exception : "InvalidParameter" };
      throw e
    | True =>
      Receive _sender token_address max_token_amount;

      new_pool = Pool _amount max_token_amount;
      pools[token_address] := new_pool;
      e1 = { _eventname: "PoolCreated"; pool: token_address };
      event e1;

      balances[token_address][_sender] := _amount;
      total_contributions[token_address] := _amount;
      e2 = { _eventname: "Mint"; pool: token_address; address: _sender; amount: _amount };
      event e2
    end
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)

      (* dY = dX * Y / X + 1 *)
      (* dX is always the QA transferred *)
      maybe_result = frac _amount x y;
      match maybe_result with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some result =>
        delta_y = builtin add result one;
        maybe_total_contribution <- total_contributions[token_address];
        match maybe_total_contribution with
        | None =>
          e = { _exception : "MissingContributions" };
          throw e
        | Some total_contribution =>
          maybe_new_contribution = frac _amount x total_contribution;
          match maybe_new_contribution with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some new_contribution =>
            within_limits =
              let token_lte_max = uint128_le delta_y max_token_amount in
              let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
              andb token_lte_max contribution_gte_max;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y };
              throw e
            | True =>
              Receive _sender token_address delta_y;

              new_pool =
                let new_x = builtin add x _amount in
                let new_y = builtin add y delta_y in
                Pool new_x new_y;
              pools[token_address] := new_pool;

              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | Some b =>
                new_balance = builtin add b new_contribution;
                balances[token_address][_sender] := new_balance
              | None =>
                balances[token_address][_sender] := new_contribution
              end;

              new_total_contribution = builtin add total_contribution new_contribution;
              total_contributions[token_address] := new_total_contribution;

              e = { _eventname: "Mint"; pool: token_address; address: _sender; amount: new_contribution };
              event e
            end
          end
        end
      end
    end
  end
end

transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128,
  min_zil_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero contribution_amount;
  ThrowIfZero min_zil_amount;
  ThrowIfZero min_token_amount;

  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some total_contribution =>
    ThrowIfZero total_contribution;
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* zil reserve, token reserve *)
        maybe_zil_amount = frac contribution_amount total_contribution x;
        maybe_token_amount = frac contribution_amount total_contribution y;
        match maybe_zil_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some zil_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount =>
            within_limits =
              let zil_ok = uint128_ge zil_amount min_zil_amount in
              let token_ok = uint128_ge token_amount min_token_amount in
              andb zil_ok token_ok;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | None =>
                e = { _exception : "MissingBalance" };
                throw e
              | Some b =>
                new_pool =
                  let new_x = builtin sub x zil_amount in
                  let new_y = builtin sub y token_amount in
                  Pool new_x new_y;
                pools[token_address] := new_pool;

                new_balance = builtin sub b contribution_amount;
                balances[token_address][_sender] := new_balance;
                new_total_contribution = builtin sub total_contribution contribution_amount;
                total_contributions[token_address] := new_total_contribution;

                Send _sender zil_address zil_amount;
                Send _sender token_address token_amount;

                e = { _eventname: "Burn"; pool: token_address; address: _sender; amount: contribution_amount };
                event e
              end
            end
          end
        end
      end
    end
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  (* _amount: the zil amount to be sent in *)
  min_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero _amount;
  ThrowIfZero min_token_amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      maybe_tokens_bought = outputFor _amount x y;
      match maybe_tokens_bought with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some tokens_bought =>
        within_limits = uint128_ge tokens_bought min_token_amount;
        match within_limits with
        | False =>
          e = { _exception : "RequestedRatesCannotBeFulfilled" };
          throw e
        | True =>
          Receive _sender zil_address _amount;
          Send _sender token_address tokens_bought;
          UpdatePool pool token_address _sender _amount zero zero tokens_bought
        end
      end
    end
  end
end

transition SwapExactTokensForZIL(
  token_address : ByStr20,
  token_amount : Uint128,
  min_zil_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero token_amount;
  ThrowIfZero min_zil_amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      maybe_zil_bought = outputFor token_amount y x;
      match maybe_zil_bought with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some zil_bought =>
        within_limits = uint128_ge zil_bought min_zil_amount;
        match within_limits with
        | False =>
          e = { _exception : "RequestedRatesCannotBeFulfilled" };
          throw e
        | True =>
          Receive _sender token_address token_amount;
          Send _sender zil_address zil_bought;
          UpdatePool pool token_address _sender zero token_amount zil_bought zero
        end
      end
    end
  end
end

transition SwapZILForExactTokens(
  token_address : ByStr20,
  (* _amount: the max zil amount to be sent in *)
  token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero _amount;
  ThrowIfZero token_amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      maybe_zil_amount = inputFor token_amount x y;
      match maybe_zil_amount with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some zil_amount =>
        within_limits = uint128_ge _amount zil_amount;
        match within_limits with
        | False =>
          e = { _exception : "RequestedRatesCannotBeFulfilled" };
          throw e
        | True =>
          refund_amount = builtin sub _amount zil_amount;
          Receive _sender zil_address _amount;
          Send _sender zil_address refund_amount;
          Send _sender token_address token_amount;
          UpdatePool pool token_address _sender zil_amount zero zero token_amount
        end
      end
    end
  end
end

transition SwapTokensForExactZIL(
  token_address : ByStr20,
  max_token_amount : Uint128,
  zil_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero zil_amount;
  ThrowIfZero max_token_amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      maybe_token_amount = inputFor zil_amount y x;
      match maybe_token_amount with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some token_amount =>
        within_limits = uint128_ge max_token_amount token_amount;
        match within_limits with
        | False =>
          e = { _exception : "RequestedRatesCannotBeFulfilled" };
          throw e
        | True =>
          Receive _sender token_address token_amount;
          Send _sender zil_address zil_amount;
          UpdatePool pool token_address _sender zero token_amount zil_amount zero
        end
      end
    end
  end
end

transition SwapExactTokensForTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  token0_amount : Uint128, (* the token0 amount to be sent in *)
  min_token1_amount : Uint128, (* min token0 amount that must be received for the txn to not revert *)
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero token0_amount;
  ThrowIfZero min_token1_amount;

  maybe_pool0 <- pools[token0_address];
  match maybe_pool0 with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some pool0 =>
    match pool0 with
    | Pool x0 y0 => (* zil reserve, token reserve *)
      maybe_zil_intermediate = outputFor token0_amount y0 x0;
      match maybe_zil_intermediate with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some zil_intermediate =>
        maybe_pool1 <- pools[token1_address];
        match maybe_pool1 with
        | None =>
          e = { _exception : "MissingPool" };
          throw e
        | Some pool1 =>
          match pool1 with
          | Pool x1 y1 => (* zil reserve, token reserve *)
            maybe_tokens_bought = outputFor zil_intermediate x1 y1;
            match maybe_tokens_bought with
            | None =>
              e = { _exception : "IntegerOverflow" };
              throw e
            | Some tokens_bought =>
              within_limits = uint128_ge tokens_bought min_token1_amount;
              match within_limits with
              | False =>
                e = { _exception : "RequestedRatesCannotBeFulfilled" };
                throw e
              | True =>
                Receive _sender token0_address token0_amount;
                UpdatePool pool0 token0_address _sender zero token0_amount zil_intermediate zero;
                Send _sender token1_address tokens_bought;
                UpdatePool pool1 token1_address _sender zil_intermediate zero zero tokens_bought
              end
            end
          end
        end
      end
    end
  end
end

transition SwapTokensForExactTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  max_token0_amount : Uint128, (* the max token0 amount that may be sent in before the txn will revert *)
  token1_amount : Uint128, (* token1 amount to be received *)
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero max_token0_amount;
  ThrowIfZero token1_amount;

  maybe_pool1 <- pools[token1_address];
  match maybe_pool1 with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some pool1 =>
    match pool1 with
    | Pool x1 y1 => (* zil reserve, token reserve *)
      maybe_zil_intermediate = inputFor token1_amount x1 y1;
      match maybe_zil_intermediate with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some zil_intermediate =>
        maybe_pool0 <- pools[token0_address];
        match maybe_pool0 with
        | None =>
          e = { _exception : "MissingPool" };
          throw e
        | Some pool0 =>
          match pool0 with
          | Pool x0 y0 => (* zil reserve, token reserve *)
            maybe_token_amount = inputFor zil_intermediate y0 x0;
            match maybe_token_amount with
            | None =>
              e = { _exception : "IntegerOverflow" };
              throw e
            | Some token_amount =>
              within_limits = uint128_ge max_token0_amount token_amount;
              match within_limits with
              | False =>
                e = { _exception : "RequestedRatesCannotBeFulfilled" };
                throw e
              | True =>
                Receive _sender token0_address token_amount;
                UpdatePool pool0 token0_address _sender zero token_amount zil_intermediate zero;
                Send _sender token1_address token1_amount;
                UpdatePool pool1 token1_address _sender zil_intermediate zero zero token1_amount
              end
            end
          end
        end
      end
    end
  end
end
