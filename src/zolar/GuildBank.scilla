scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import ListUtils BoolUtils NatUtils IntUtils
library GuildBank

let true = True
let false = False
let zero = Uint128 0
let one = Uint128 1
let hundred_percent_bps = Uint128 10000
let uint32_zero = Uint32 0
let none = None {ByStr20}
let zero_address = 0x0000000000000000000000000000000000000000

(* sets to contract substate bank_version *)
let guild_bank_version = Uint32 1

let max_officer_count = Uint32 2
let max_member_count = Uint32 30

type ControlMode =
  | CaptainOnly
  | CaptainAndOneOfficer
  | CaptainAndTwoOfficers

(* guild management fee allocation to captains and officers *)
type FeeAllocation =
  | FeeAllocation of Uint128 Uint128 (* captain bps, officers bps *)

(* fee settings for weekly tax and joining fee *)
type Fee =
  | Fee of Uint128 FeeAllocation (* amount, fee allocation *)

(* all of a guild bank's configurations *)
type GuildBankSettings =
  | GuildBankSettings of Fee Fee ControlMode (* joining fee, weekly tax, multisig control mode *)

(* parameters for multisig transactions *)
type TxParams =
  | UpdateConfigTxParams of GuildBankSettings
  | WithdrawTxParams of ByStr20 ByStr20 Uint128 (* recipient, token, amount *)
  | DepositHiveTxParams of Uint128 Uint128 Uint128 Uint32 (* min contribution, zil amount, max token amount, deadline blocks offset *)
  | WithdrawHiveTxParams of Uint128 Uint128 Uint128 Uint32 (* contribution, min zil amount, min token amount, deadline blocks offset *)

(* multisig transaction with metadata *)
type BankTx =
  | BankTx of String ByStr20 TxParams (* message, initiator, params *)

(* represents an existing multisig transaction. consists of the transaction with a list of approvers *)
type PendingTx =
  | PendingTx of BankTx (List ByStr20) (* tx, approvers *)

(* used for bulk collecting weekly tax *)
type TaxParam =
  | TaxParam of ByStr20 Uint32 (* payer, epoch number *)

(* used for recording tax owed per epoch *)
type TaxOwed =
  | TaxOwed of ByStr20 Uint32 Uint128 (* payer, epoch number, amount *)

(* used for migrating funds on this contract to another guild bank contract during an upgrade *)
type MigrateParam = 
  | MigrateParam of ByStr20 ByStr20 (* token contract, recipient *)

(* send token param for bulk sending tokens *)
type SendTokenParam = 
  | SendTokenParam of ByStr20 (ByStr20 with contract field balances : Map ByStr20 Uint128 end) Uint128 (* recipient, token contract, amount *)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotSelf
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodePendingTxDoesNotExist
  | CodePendingTxExists
  | CodeInvalidTxInsufficientBalance
  | CodeAmountRecievedMismatch
  | CodeInvalidTokenContract
  | CodeNoTokenBalance
  | CodeAlreadyTaxed
  | CodeIsAlreadyMember
  | CodeNotMember
  | CodeIsAlreadyOfficer
  | CodeNotOfficer
  | CodeOfficerLimitReached
  | CodeMemberLimitReached
  | CodeInvalidMembershipState
  | CodeMemberApplicationNotFound
  | CodeCaptainCannotLeave
  | CodeNotCaptainOrOfficer
  | CodeNotBankAuthority
  | CodeInvalidTaxParam
  | CodeInvalidEpoch
  | CodeAlreadyMigrated
  | CodeNotMigrated
  | CodeNotMigratedToSelf
  | CodeHiveNotEmpty
  | CodeInvalidBankTx
  | CodeTaxNotApproved

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                        => Int32 -1
      | CodeNotSelf                         => Int32 -2
      | CodeNotPendingOwner                 => Int32 -3
      | CodePendingOwnerNotEmpty            => Int32 -4
      | CodePendingTxDoesNotExist           => Int32 -5
      | CodePendingTxExists                 => Int32 -6
      (* CodeInvalidTxInsufficientBalance is also thrown when withdraw tx token address *)
      (* is not a valid ZRC2 token contract address *)
      | CodeInvalidTxInsufficientBalance    => Int32 -7
      | CodeAmountRecievedMismatch          => Int32 -8
      | CodeInvalidTokenContract            => Int32 -9
      | CodeNoTokenBalance                  => Int32 -10
      | CodeAlreadyTaxed                    => Int32 -11
      | CodeIsAlreadyMember                 => Int32 -12
      | CodeNotMember                       => Int32 -13
      | CodeIsAlreadyOfficer                => Int32 -14
      | CodeNotOfficer                      => Int32 -15
      | CodeOfficerLimitReached             => Int32 -16
      | CodeMemberLimitReached              => Int32 -17
      | CodeInvalidMembershipState          => Int32 -18
      | CodeMemberApplicationNotFound       => Int32 -19
      | CodeCaptainCannotLeave              => Int32 -20
      | CodeNotCaptainOrOfficer             => Int32 -21
      | CodeNotBankAuthority                => Int32 -22
      | CodeInvalidTaxParam                 => Int32 -23
      | CodeInvalidEpoch                    => Int32 -24
      | CodeAlreadyMigrated                 => Int32 -25
      | CodeNotMigrated                     => Int32 -26
      | CodeNotMigratedToSelf               => Int32 -27
      | CodeHiveNotEmpty                    => Int32 -30
      | CodeInvalidBankTx                   => Int32 -31
      | CodeTaxNotApproved                  => Int32 -32
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end

let get_uint128list_nth = @list_nth Uint128

let get_element_amount_or_zero =
  fun (list: List Uint128) =>
  fun (n: Uint32) =>
    let maybe_value = get_uint128list_nth n list in
    match maybe_value with
    | Some amt => amt
    | None => zero
    end

(* convert initialization fee_params list to fee config *)
let get_fee =
  fun (fee_params : List Uint128) =>
    let uint32_one = Uint32 1 in
    let uint32_two = Uint32 2 in
    let fee_initial_amount = get_element_amount_or_zero fee_params uint32_zero in
    let alloc_captain = get_element_amount_or_zero fee_params uint32_one in
    let alloc_officer = get_element_amount_or_zero fee_params uint32_two in
    let allocation = FeeAllocation alloc_captain alloc_officer in
    Fee fee_initial_amount allocation

(* returns fee amount the fee config *)
let get_fee_amount = fun (f : Fee) => match f with | Fee amount _ => amount end

(* returns True if all items in the list is True *)
let all_true =
  fun (list : List Bool) =>
    let identity = fun (a: Bool) => a in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool identity list

(* compares fee *)
let is_fee_eq = 
  fun (lhs_fee: Fee) =>
  fun (rhs_fee: Fee) =>
    match lhs_fee with
    | Fee lhs_amount lhs_alloc =>
      match lhs_alloc with
      | FeeAllocation lhs_captain_bps lhs_officer_bps =>
        match rhs_fee with
        | Fee rhs_amount rhs_alloc =>
          match rhs_alloc with
          | FeeAllocation rhs_captain_bps rhs_officer_bps =>
            let amount_eq = builtin eq lhs_amount rhs_amount in
            let captain_bps_eq = builtin eq lhs_captain_bps rhs_captain_bps in
            let officer_bps_eq = builtin eq lhs_officer_bps rhs_officer_bps in

            let l0 = Nil {Bool} in
            let l1 = Cons {Bool} amount_eq l0 in
            let l2 = Cons {Bool} captain_bps_eq l1 in
            let l3 = Cons {Bool} officer_bps_eq l2 in
            all_true l3
          end
        end
      end
    end
    

(* returns result of amount * bps *)
let get_amount_portion = 
  fun (amount : Uint128) =>
  fun (portion_bps : Uint128) =>
  let is_zero = builtin eq portion_bps zero in
    match is_zero with
    | True => zero
    | False =>
      let portions = builtin div hundred_percent_bps portion_bps in
      builtin div amount portions
    end
  

(* look up ControlMode based on provided signing power *)
let get_control_mode =
  fun (power : Uint32) =>
    let five = Uint32 5 in
    let two_officers = builtin eq power five in
    match two_officers with
    | True => CaptainAndTwoOfficers
    | False =>
      let four = Uint32 4 in
      let one_officer = builtin eq power four in
      match one_officer with
      | True => CaptainAndOneOfficer
      | False => CaptainOnly
      end
    end

(* look up signing power requirement based on ControlMode *)
let get_required_power =
  fun (mode : ControlMode) =>
      match mode with
      | CaptainOnly             => Uint32 3
      | CaptainAndOneOfficer    => Uint32 4
      | CaptainAndTwoOfficers   => Uint32 5
      end

(* returns Uint32 representation of provided member's signing power *)
let get_power = 
  fun (officers : Map ByStr20 Uint32) =>
  fun (captain : ByStr20) =>
  fun (member : ByStr20) =>
    let maybe_officer = builtin get officers member in
    match maybe_officer with
    | Some _ => Uint32 1 (* officer has 1 power *)
    | None =>
      let maybe_captain = builtin eq captain member in
      match maybe_captain with
      | True => Uint32 3 (* captain has 3 power *)
      | False => Uint32 0 (* member not privileged *)
      end
    end

(* returns Uint32 representation of combined signers power *)
let get_current_power =
  fun (signers : List ByStr20) =>
  fun (officers : Map ByStr20 Uint32) =>
  fun (captain : ByStr20) =>
    let fold = @list_foldl ByStr20 Uint32 in
    let fn = 
      fun (power: Uint32) => 
      fun (signer: ByStr20) =>
        let signer_power = get_power officers captain signer in
        builtin add signer_power power
    in
    let uint32_zero = Uint32 0 in
    fold fn uint32_zero signers

(* returns length of given list *)
let get_list_length = 
  fun (list : List ByStr20) =>
    let fn = @list_length ByStr20 in fn list
  
(* create empty PendingTx with given BankTx *)
let create_pending_tx = 
  fun (tx : BankTx) => 
    let empty_list = Nil {ByStr20} in
    PendingTx tx empty_list

(* appends an address to PendingTx approvers *)
let insert_tx_signer = 
  fun (tx : PendingTx) => 
  fun (signer : ByStr20) =>
    match tx with
    | PendingTx bank_tx signers => 
      let new_signers = Cons {ByStr20} signer signers in
      PendingTx bank_tx new_signers
    end

(* convert a map to list of pairs *)
let map_to_list =
  fun (address_map : Map ByStr20 Uint32) => 
    let fold = @list_foldl (Pair ByStr20 Uint32) (List ByStr20) in
    let fn = 
      fun (result_list: List ByStr20) => 
      fun (token_pair: Pair ByStr20 Uint32) =>
        match token_pair with
          | Pair token _ =>
            Cons {ByStr20} token result_list
        end
    in
    let address_list = builtin to_list address_map in
    let empty_list = Nil {ByStr20} in
    fold fn empty_list address_list

(* convert a ByStr20 list and a given value to a map of { ByStr20 : value } *)
let list_to_map =
  fun (list : List ByStr20) => 
  fun (value : Uint32) => 
    let fold = @list_foldl (ByStr20) (Map ByStr20 Uint32) in
    let fn = 
      fun (result_map: Map ByStr20 Uint32) => 
      fun (item: ByStr20) =>
        builtin put result_map item value
    in
    let empty_map = Emp ByStr20 Uint32 in
    fold fn empty_map list

(* returns True if candidate is a member of list *)
let is_list_member =
  fun (list : List ByStr20) =>
  fun (candidate: ByStr20) =>
    let check_exists = @list_exists ByStr20 in
    let exist_fn = fun (item: ByStr20) => builtin eq item candidate in
    check_exists exist_fn list

(* returns True if candidate list is a subset of set list *)
let is_list_subset =
  fun (set : List ByStr20) =>
  fun (candidate : List ByStr20) =>
    let fold = @list_foldl ByStr20 (List Bool) in
    let fn = 
      fun (result_list: List Bool) => 
      fun (item: ByStr20) =>
        let is_element = is_list_member set item in
        Cons {Bool} is_element result_list
    in
    let empty_list = Nil {Bool} in
    let result = fold fn empty_list candidate in
    all_true result
    
(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract GuildBank(
  initial_owner: ByStr20,
  bank_authority: ByStr20 with contract
    field current_epoch : Uint32,
    field hive : ByStr20 with contract
      field current_refinery : ByStr20,
      field balances : Map ByStr20 Uint128
    end,
    field huny : ByStr20 with contract
      field balances : Map ByStr20 Uint128,
      field allowances : Map ByStr20 (Map ByStr20 Uint128)
    end
  end,
  initial_epoch: Uint32,
  initial_joining_fee: List Uint128,
  initial_weekly_tax: List Uint128,
  initial_control_mode_power: Uint32,
  initial_members: List ByStr20,
  initial_officers: List ByStr20
)
with
  let officer_count = get_list_length initial_officers in
  let officer_overlimit = builtin lt max_officer_count officer_count in
  let officer_limit_ok = negb officer_overlimit in

  let member_count = get_list_length initial_members in
  let member_overlimit = builtin lt max_member_count member_count in
  let member_limit_ok = negb member_overlimit in

  let captain_is_member = is_list_member initial_members initial_owner in
  let captain_is_officer = is_list_member initial_officers initial_owner in
  let captain_not_officer = negb captain_is_officer in
  let officer_list_ok = is_list_subset initial_members initial_officers in

  let l0 = Nil {Bool} in
  let l1 = Cons {Bool} officer_limit_ok l0 in
  let l2 = Cons {Bool} member_limit_ok l1 in
  let l3 = Cons {Bool} captain_is_member l2 in
  let l4 = Cons {Bool} captain_not_officer l3 in
  let l5 = Cons {Bool} officer_list_ok l4 in
  all_true l5
=>

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

field bank_version : Uint32 = guild_bank_version
field migrated_to_bank : Option ByStr20 = none

field control_mode : ControlMode = get_control_mode initial_control_mode_power
field pending_tx : Option PendingTx = None {PendingTx}

field joining_fee : Fee = get_fee initial_joining_fee
field weekly_tax : Fee = get_fee initial_weekly_tax

field last_updated_epoch : Uint32 = initial_epoch
field current_joining_fee : Uint128 = get_element_amount_or_zero initial_joining_fee uint32_zero

field members : Map ByStr20 Uint32 = list_to_map initial_members initial_epoch
field officers : Map ByStr20 Uint32 = list_to_map initial_officers initial_epoch

(* map of users requesting to join guild, can be approved by guild managers to complete join flow *)
field joining_requests : Map ByStr20 Bool = Emp ByStr20 Bool

(* map of joining fee paid per user *)
field joining_fee_paid : Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* map of token addresses that bank has balance of, used for migrate *)
field tokens_held : Map ByStr20 Bool = Emp ByStr20 Bool

(* map of accounts who approved for tax collection *)
field tax_approved : Map ByStr20 Bool = Emp ByStr20 Bool

(* map of tax collected per user by epoch *)
field tax_collected : Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128)

(* map of tax owed per user by epoch *)
field tax_owed : Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128)

(* map of unpaid management allocated to officers and captain *)
field management_fees : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsNotOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
      err = CodeCaptainCannotLeave;
      ThrowError err
    | False => (* no-op *)
    end
  | None => (* no-op *)
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsSelf(address: ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure IsNotMigrated()
  maybe_migrated_bank <- migrated_to_bank;
  match maybe_migrated_bank with
  | Some address =>
    err = CodeAlreadyMigrated;
    ThrowError err
  | None =>
  end
end

procedure IsMigrated()
  maybe_migrated_bank <- migrated_to_bank;
  match maybe_migrated_bank with
  | Some address =>
  | None =>
    err = CodeNotMigrated;
    ThrowError err
  end
end

procedure IsValidAllocation(allocation: FeeAllocation)
  match allocation with
  | FeeAllocation captain_bps officer_bps =>
    total_officer_bps = builtin add officer_bps officer_bps;
    total_allocation = builtin add captain_bps total_officer_bps;
    is_invalid_allocation = builtin lt hundred_percent_bps total_allocation;
    match is_invalid_allocation with
    | True =>
      err = CodeInvalidBankTx;
      ThrowError err
    | False =>
    end
  end
end

procedure IsValidFee(fee: Fee)
  match fee with
  | Fee amount allocation =>
    IsValidAllocation allocation
  end
end


procedure IsValidBankTx(bank_tx: BankTx)
  match bank_tx with
  | BankTx message initiator params =>
    match params with
    | UpdateConfigTxParams new_settings =>
      match new_settings with
      | GuildBankSettings new_joining_fee new_weekly_tax new_control_mode =>
        IsNotMigrated;
        IsValidFee new_joining_fee;
        IsValidFee new_weekly_tax
      end
    | WithdrawTxParams recipient token amount =>
      maybe_zil = builtin eq token zero_address;
      match maybe_zil with
      | True =>
        zil_balance <- _balance;
        maybe_insufficient_balance = builtin lt zil_balance amount;
        match maybe_insufficient_balance with
        | False => (* no-op - balance is sufficient *)
        | True =>
          err = CodeInvalidTxInsufficientBalance;
          ThrowError err
        end
      | False =>
        maybe_token_contract <- & token as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
        match maybe_token_contract with
        | Some token_contract =>
          maybe_token_balance <- & token_contract.balances[_this_address];
          match maybe_token_balance with
          | Some token_balance =>
            maybe_insufficient_balance = builtin lt token_balance amount;
            match maybe_insufficient_balance with
            | False => (* no-op - balance is sufficient *)
            | True =>
              err = CodeInvalidTxInsufficientBalance;
              ThrowError err
            end
          | None =>
            err = CodeInvalidTxInsufficientBalance;
            ThrowError err
          end
        | None =>
          err = CodeInvalidTxInsufficientBalance;
          ThrowError err
        end
        
      end

    | DepositHiveTxParams min_contribution zil_amount max_token_amount deadline_block_offset =>
    | WithdrawHiveTxParams contribution min_zil_amount min_token_amount deadline_block_offset =>
    end
  end
end

procedure IsNotPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    err = CodePendingTxExists;
    ThrowError err
  | None =>
  end
end

procedure IsTaxable(member: ByStr20, epoch_number: Uint32)
  maybe_approved <- tax_approved[member];
  match maybe_approved with
  | Some _ => (* no-op *)
  | None =>
    err = CodeTaxNotApproved;
    ThrowError err
  end;

  maybe_taxed <- tax_collected[epoch_number][member];
  match maybe_taxed with
  | None =>
    maybe_tax_owed <- tax_owed[epoch_number][member];
    match maybe_tax_owed with
    | Some tax_amount =>
    | None => (* tax not owed by member *)
      err = CodeInvalidTaxParam;
      ThrowError err
    end
  | Some tax_amount => (* tax already collected for member in given epoch *)
    err = CodeAlreadyTaxed;
    ThrowError err
  end
end

(* Validates BankTx params of the current PendingTx *)
(* throws if there is no PendingTx *)
(* throws conditions of BankTx is not met  *)
procedure IsValidPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    match current_pending_tx with
    | PendingTx bank_tx signers => IsValidBankTx bank_tx
    end
  | None =>
    err = CodePendingTxDoesNotExist;
    ThrowError err
  end
end

procedure IsApplicationActive(member: ByStr20)
  maybe_application <- joining_requests[member];
  match maybe_application with
  | Some application =>
    match application with
    | True => (* no-op *)
    | False =>
      err = CodeMemberApplicationNotFound;
      ThrowError err
    end
  | None =>
    err = CodeMemberApplicationNotFound;
    ThrowError err
   end
end

procedure IsCaptainOrOfficer(address: ByStr20)
  current_officers <- officers;
  maybe_captain <- contract_owner;
  match maybe_captain with
  | Some captain =>
    power = get_power current_officers captain address;
    is_no_power = builtin eq power uint32_zero;
    match is_no_power with
    | True =>
      err = CodeNotCaptainOrOfficer;
      ThrowError err
    | False => (* no op *)
    end
  | None =>
    err = CodeNotCaptainOrOfficer;
    ThrowError err
  end
end

procedure IsBankAuthority(address: ByStr20)
  is_bank_authority = builtin eq bank_authority address;
  match is_bank_authority with
  | False =>
    err = CodeNotBankAuthority;
    ThrowError err
  | True =>
  end
end

procedure IsHiveEmpty()
  hive <- & bank_authority.hive;
  maybe_hive_balance <- & hive.balances[_this_address];
  hive_balance = get_amount_or_zero maybe_hive_balance;
  has_hive_balance = builtin lt zero hive_balance;
  match has_hive_balance with
  | False =>
  | True =>
    err = CodeHiveNotEmpty;
    ThrowError err
  end
end

procedure IsNotMember(user: ByStr20)
  maybe_member <- members[user];
  match maybe_member with
  | Some member =>
    err = CodeIsAlreadyMember;
    ThrowError err
  | None =>
  end
end

procedure IsMember(user: ByStr20)
  maybe_member <- members[user];
  match maybe_member with
  | Some member =>
  | None =>
    err = CodeNotMember;
    ThrowError err
  end
end

procedure IsNotOfficer(user: ByStr20)
  maybe_officer <- officers[user];
  match maybe_officer with
  | Some officer =>
    err = CodeIsAlreadyOfficer;
    ThrowError err
  | None =>
  end
end

procedure IsOfficer(user: ByStr20)
  maybe_officer <- officers[user];
  match maybe_officer with
  | Some officer =>
  | None =>
    err = CodeNotOfficer;
    ThrowError err
  end
end

procedure ReceiveZil(amount: Uint128)
  maybe_match_amount = builtin eq amount _amount;
  match maybe_match_amount with
  | True =>
    accept
  | False =>
    err = CodeAmountRecievedMismatch;
    ThrowError err
  end
end

procedure SendZil(recipient: ByStr20, amount: Uint128)
  msg = { _tag : "AddFunds"; _recipient: recipient; _amount: amount };
  msgs = one_msg msg;
  send msgs
end

(* update tokens_held map *)
procedure UpdateTokenBalance(
  token: ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end
)
  maybe_token_balance <- & token.balances[_this_address];
  match maybe_token_balance with
  | Some token_balance =>
    is_zero_balance = builtin eq token_balance zero;
    match is_zero_balance with
    | True => delete tokens_held[token]
    | False => tokens_held[token] := true
    end
  | None => delete tokens_held[token]
  end
end

procedure IncreaseAllowance(spender: ByStr20, required_amount : Uint128)
  huny_token <- & bank_authority.huny;
  a <- & huny_token.allowances[_this_address][spender];

  allowance = get_amount_or_zero a;
  need_increase = builtin lt allowance required_amount;
  match need_increase with
  | False => (* no-op *)
  | True =>
    increase_amount = builtin sub required_amount allowance;
    msg_to_token = {
      _tag : "IncreaseAllowance"; _recipient : huny_token; _amount : zero;
      spender : spender; amount : increase_amount
    };
    msg = one_msg msg_to_token;
    send msg
  end
end

procedure ReceiveToken(
  from: ByStr20,
  token: ByStr20 with contract
    field balances : Map ByStr20 Uint128
  end, 
  amount: Uint128
)
  msg_to_token = {
    _tag: "TransferFrom";
    _recipient: token;
    _amount: zero;
    from: from;
    to: _this_address;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs
end

procedure SendToken(params: SendTokenParam)
  match params with
  | SendTokenParam recipient token amount =>
    msg_to_token = {
      _tag: "Transfer";
      _recipient: token;
      _amount: zero;
      to: recipient;
      amount: amount
    };
    msgs = one_msg msg_to_token;
    send msgs
  end
end

(* multi-sig authenticated operation *)
procedure UpdateGuildSettings(settings: GuildBankSettings)
  msg_to_authority = {
    _tag: "ProcessBankUpdate"; 
    _recipient: bank_authority; 
    _amount: zero 
  };
  msgs = one_msg msg_to_authority;
  send msgs;

  match settings with
  | GuildBankSettings new_joining_fee new_weekly_tax new_control_mode =>
    current_weekly_tax <- weekly_tax;
    weekly_tax_unchanged = is_fee_eq new_weekly_tax current_weekly_tax;
    match weekly_tax_unchanged with
    | True =>
    | False =>
      old_tax = get_fee_amount current_weekly_tax;
      new_tax = get_fee_amount new_weekly_tax;
      postive_increment = builtin lt old_tax new_tax;
      match postive_increment with
      | False =>
      | True =>
        empty_map = Emp ByStr20 Bool;
        tax_approved := empty_map
      end
    end;

    joining_fee := new_joining_fee;
    weekly_tax := new_weekly_tax;
    control_mode := new_control_mode;

    e = {_eventname: "BankSettingsUpdated"; settings: settings };
    event e
  end
end

(* multi-sig authenticated operation *)
procedure Withdraw(recipient: ByStr20, token: ByStr20, amount: Uint128)
  maybe_zil = builtin eq token zero_address;
  match maybe_zil with
  | True =>
    SendZil recipient amount
  | False =>
    maybe_token_contract <- & token as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
    match maybe_token_contract with
    | Some token_contract =>
      params = SendTokenParam recipient token_contract amount;
      SendToken params
    | None =>
    end
  end;

  e = {_eventname: "WithdrawComplete"; token: token; recipient: recipient; amount: amount};
  event e
end

(* multi-sig authenticated operation *)
procedure DepositHive(min_contribution: Uint128, zil_amount: Uint128, max_token_amount: Uint128, deadline_block_offset: Uint32)
  hive_address <- & bank_authority.hive;
  IncreaseAllowance hive_address max_token_amount;

  current_block_number <- & BLOCKNUMBER;
  deadline_block = builtin badd current_block_number deadline_block_offset;
  msg_to_hive = {
    _tag: "AddLiquidity";
    _recipient: hive_address;
    _amount: zil_amount;
    min_contribution_amount: min_contribution;
    max_token_amount: max_token_amount;
    deadline_block: deadline_block
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "HiveDepositComplete" };
  event e
end

(* multi-sig authenticated operation *)
procedure WithdrawHive(contribution: Uint128, min_zil_amount: Uint128, min_token_amount: Uint128, deadline_block_offset: Uint32)
  current_block_number <- & BLOCKNUMBER;
  deadline_block = builtin badd current_block_number deadline_block_offset;
  hive_address <- & bank_authority.hive;
  msg_to_hive = {
    _tag: "RemoveLiquidity";
    _recipient: hive_address;
    _amount: zero;
    amount: contribution;
    min_zil_amount: min_zil_amount;
    min_token_amount: min_token_amount;
    deadline_block: deadline_block
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "HiveWithdrawComplete" };
  event e
end

(* execute transaction specified in BankTx *)
procedure ExecuteBankTx(bank_tx: BankTx)
  match bank_tx with
  | BankTx message initiator tx_params => 
    match tx_params with
    | UpdateConfigTxParams new_settings => UpdateGuildSettings new_settings
    | WithdrawTxParams recipient token amount => Withdraw recipient token amount
    | DepositHiveTxParams min_contribution zil_amount max_token_amount deadline_block_offset => 
      DepositHive min_contribution zil_amount max_token_amount deadline_block_offset
    | WithdrawHiveTxParams contribution min_zil_amount min_token_amount deadline_block_offset =>
      WithdrawHive contribution min_zil_amount min_token_amount deadline_block_offset
    end
  end
end

(* execute given PendingTx is multisig signature requirement has been met *)
procedure CheckConcludePendingTx(current_pending_tx: PendingTx)
  current_control_mode <- control_mode;
  required_power = get_required_power current_control_mode;
  match current_pending_tx with
  | PendingTx bank_tx signers =>
    maybe_owner <- contract_owner;
    match maybe_owner with
    | Some current_captain =>
      current_officers <- officers;
      current_power = get_current_power signers current_officers current_captain;
      maybe_insufficient_power = builtin lt current_power required_power;
      match maybe_insufficient_power with
      | True => (* insufficient power to execute *)
      | False => 
        ExecuteBankTx bank_tx;

        none_pending_tx = None {PendingTx};
        pending_tx := none_pending_tx;

        e = {_eventname: "TxExecuted"; pending_tx: current_pending_tx };
        event e
      end
    | None => (* impossible *)
    end
   end
end

procedure SignPendingTx(signer: ByStr20)
  IsValidPendingTx;

  maybe_tx <- pending_tx;
  match maybe_tx with
  | Some tx =>
    new_pending_tx = insert_tx_signer tx signer;
    p = Some {PendingTx} new_pending_tx;
    pending_tx := p;
    
    e = {_eventname: "TxSigned"; signer: _sender; pending_tx: new_pending_tx };
    event e;
    
    CheckConcludePendingTx new_pending_tx
  | None => (* not possible *)
   end
end

(* reset signature progress on guild multisig transaction *)
(* effected when any of guild officers or captain is changed *)
procedure ResetPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    match current_pending_tx with
    | PendingTx bank_tx signers =>
      empty_signers = Nil {ByStr20};
      new_pending_tx = PendingTx bank_tx empty_signers;
      p = Some {PendingTx} new_pending_tx;
      pending_tx := p;
      e = {_eventname: "TxSigningReset"; pending_tx: new_pending_tx };
      event e
    end
  | None => (* no-op *)
  end
end

procedure FlushAllocations(param: Pair ByStr20 (ByStr20 with contract field balances: Map ByStr20 Uint128 end))
  match param with
  | Pair recipient token =>
    maybe_amount <- management_fees[recipient][token];
    amount = get_amount_or_zero maybe_amount;
    has_amount = builtin lt zero amount;
    match has_amount with
    | True =>
      send_param = SendTokenParam recipient token amount;
      delete management_fees[recipient][token];
      SendToken send_param
    | False => (* no-op *)
    end
  end
end

procedure FlushManagementFees(token: ByStr20 with contract field balances: Map ByStr20 Uint128 end)
  maybe_captain <- contract_owner;
  match maybe_captain with
  | None =>
  | Some captain =>
    captain_param = Pair {ByStr20 (ByStr20 with contract field balances: Map ByStr20 Uint128 end)} captain token;
    FlushAllocations captain_param
  end;
  
  current_officers <- officers;
  officer_list = map_to_list current_officers;

  map_send_params = @list_map ByStr20 (Pair ByStr20 (ByStr20 with contract field balances: Map ByStr20 Uint128 end));
  fn = fun (officer: ByStr20) => Pair {ByStr20 (ByStr20 with contract field balances: Map ByStr20 Uint128 end)} officer token;
  param_list = map_send_params fn officer_list;

  forall param_list FlushAllocations
end


procedure AllocateFee(param: SendTokenParam)
  match param with
  | SendTokenParam recipient token amount =>
    maybe_fee_allocated <- management_fees[recipient][token];
    current_fee_allocated = get_amount_or_zero maybe_fee_allocated;
    new_fee_allocated = builtin add current_fee_allocated amount;
    management_fees[recipient][token] := new_fee_allocated
  end
end

(* allocate fees to captain and officers according to config *)
procedure AllocateManagementFee(
  fee: Fee,
  gross_amount: Uint128,
  token: ByStr20 with contract field balances: Map ByStr20 Uint128 end
)
  match fee with
  | Fee _ allocation =>
    match allocation with
    | FeeAllocation captain_bps officer_bps =>
      current_officers <- officers;
      officer_list = map_to_list current_officers;

      officer_amount = get_amount_portion gross_amount officer_bps;
      map_send_params = @list_map ByStr20 SendTokenParam;
      fn = fun (officer: ByStr20) => SendTokenParam officer token officer_amount;
      param_list = map_send_params fn officer_list;
      forall param_list AllocateFee;

      maybe_captain <- contract_owner;
      match maybe_captain with
      | Some captain =>
        captain_amount = get_amount_portion gross_amount captain_bps;
        params = SendTokenParam captain token captain_amount;
        AllocateFee params
      | None =>
      end
    end
  end
end

procedure ReceiveTax(param: TaxParam)
  current_tax <- weekly_tax;
  match param with
  | TaxParam member epoch_number =>
    IsTaxable member epoch_number;

    huny_token <- & bank_authority.huny;
    maybe_tax_owed <- tax_owed[epoch_number][member];
    match maybe_tax_owed with
    | None => 
      err = CodeInvalidTaxParam;
      ThrowError err
    | Some tax_amount =>
      ReceiveToken member huny_token tax_amount;
      tax_collected[epoch_number][member] := tax_amount;
      delete tax_owed[epoch_number][member];

      e = {_eventname: "TaxCollected"; payer: member; tax_amount: tax_amount; epoch_number: epoch_number };
      event e;
      AllocateManagementFee current_tax tax_amount huny_token
    end
  end
end

procedure RecordTaxOwed(tax: TaxOwed)
  match tax with
  | TaxOwed member epoch_number amount =>
    tax_owed[epoch_number][member] := amount
  end
end

(* advance epoch to given epoch number, must be last_updated_epoch + 1  *)
(* update joining fee if epoch has been updated                         *)
(* record weekly taxes into tax_owed if any                             *)
procedure AdvanceEpoch(current_epoch: Uint32)
  f <- joining_fee;

  new_joining_fee = get_fee_amount f;
  current_joining_fee := new_joining_fee;

  current_members <- members;
  members_list = map_to_list current_members;

  current_tax <- weekly_tax;
  tax_amount = get_fee_amount current_tax;

  list_convert = @list_map ByStr20 TaxOwed;
  fn = fun (member: ByStr20) => TaxOwed member current_epoch tax_amount;
  tax_list = list_convert fn members_list;
  forall tax_list RecordTaxOwed;

  last_updated_epoch := current_epoch;

  e = {_eventname: "EpochUpdated"; epoch: current_epoch };
  event e
end


(* check bank authority contract and update current epoch                     *)
(* executes AdvanceEpoch for every epoch since last_epoch until current_epoch *)
procedure UpdateEpoch()
  last_epoch <- last_updated_epoch;
  current_epoch <- & bank_authority.current_epoch;
  maybe_already_updated = builtin eq last_epoch current_epoch;
  match maybe_already_updated with
  | True => (* no op*)
  | False =>
    epoch_valid = uint32_le last_epoch current_epoch;
    match epoch_valid with
    | False => 
      err = CodeInvalidEpoch;
      ThrowError err
    | True =>  
      diff = builtin sub current_epoch last_epoch;
      diff_nat = builtin to_nat diff;
      fold = @nat_fold (List Uint32);
      fn = fun (list: List Uint32) => fun (nat: Nat)  => 
        let step = nat_to_int nat in
        let offset = builtin sub diff step in
        let epoch_number = builtin add last_epoch   offset in
        Cons {Uint32} epoch_number list;
      init = Nil {Uint32};
      epoch_list = fold fn init diff_nat;
      reverse_list = @list_reverse Uint32;
      epoch_list_reverse = reverse_list epoch_list; 
      forall epoch_list_reverse AdvanceEpoch
    end
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Request to join guild                                                        *)
(* required before a member can join the guild by calling ApproveAndReceiveJoiningFee *)
transition ApplyForMembership()
  IsNotMigrated;
  IsNotMember _sender;

  joining_requests[_sender] := true;

  e = {_eventname: "MemberApplicationCreated"; applicant: _sender};
  event e
end

(* @dev: Withdraw guild membership application *)
transition WithdrawMembershipApplication()
  IsNotMigrated;
  IsApplicationActive _sender;

  delete joining_requests[_sender];

  e = {_eventname: "MemberApplicationWithdrawn"; applicant: _sender};
  event e
end

(* @dev: Initiate a generic multisig transaction (depends on configuration  *)
(* could resolve immediately if in single-signature mode)                   *)
(* @param tx_params: multisig transaction parameters                        *)
(* @param message: user message for the multisig transaction request        *)
transition InitiateTx(tx_params: TxParams, message: String)
  IsCaptainOrOfficer _sender;
  IsNotPendingTx;

  UpdateEpoch;

  bank_tx = BankTx message _sender tx_params; 
  IsValidBankTx bank_tx;

  new_pending_tx = create_pending_tx bank_tx;
  p = Some {PendingTx} new_pending_tx;
  pending_tx := p;

  e = {_eventname: "TxInitiated"; initiator: _sender; pending_tx: new_pending_tx};
  event e;

  SignPendingTx _sender
end

(* @dev: Cancels a pending multisig transaction. *)
transition CancelTx()
  IsOwner _sender;

  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some cancelled_pending_tx =>
    no_pending_tx = None {PendingTx};
    pending_tx := no_pending_tx;

    e = {_eventname: "TxCancelled"; initiator: _sender; pending_tx: cancelled_pending_tx };
    event e
  | None =>
    err = CodePendingTxDoesNotExist;
    ThrowError err
  end
  
end

(* @dev: Sign a multisig transaction, resolves and executes if number of *)
(* required signing parties is met. *)
transition SignTx()
  IsCaptainOrOfficer _sender;
  UpdateEpoch;

  SignPendingTx _sender
end

(* @dev: Promote a member from normal member to officer status *)
(* @param member: member to be promoted                        *)
transition PromoteMember(member: ByStr20)
  IsNotMigrated;
  IsOwner _sender;
  IsNotOwner member;

  IsNotOfficer member;
  IsMember member;

  UpdateEpoch;

  current_officers <- officers;
  officer_list = map_to_list current_officers;
  officer_count = get_list_length officer_list;

  has_officer_capacity = builtin lt officer_count max_officer_count;
  match has_officer_capacity with
  | True =>
    current_epoch <- last_updated_epoch;
    officers[member] := current_epoch;

    e = {_eventname: "MemberPromoted"; initiator: _sender; member: member};
    event e;

    ResetPendingTx
  | False =>
    err = CodeOfficerLimitReached;
    ThrowError err
  end
end

(* @dev: Demote a member from officer to normal member status *)
(* @param member: member to be demoted                        *)
transition DemoteMember(member: ByStr20)
  IsNotMigrated;
  IsOwner _sender;
  
  IsOfficer member;

  delete officers[member];

  e = {_eventname: "MemberDemoted"; initiator: _sender; member: member};
  event e;

  ResetPendingTx
end

(* @dev: Remove a member from the guild, can only be called by captain or *)
(* officer. Cannot remove self.                                           *)
(* @param member: member to be removed from guild                         *)
transition RemoveMember(member: ByStr20)
  IsNotMigrated;
  IsCaptainOrOfficer _sender;
  IsMember member;
  IsNotOwner member;

  is_removing_self = builtin eq member _sender;
  match is_removing_self with
  | False =>
    delete members[member];
    delete tax_approved[member];
    e = {_eventname: "MemberLeft"; initiator: _sender; member: member};
    event e;

    maybe_officer <- officers[member];
    match maybe_officer with
    | Some officer =>
      delete officers[member];
      ResetPendingTx
    | None => (* no-op *)
    end
  | True =>
    err = CodeNotOwner;
    ThrowError err
  end
end

(* @dev: Remove caller from the guild, cannot be called by owner *)
transition LeaveGuild()
  IsNotMigrated;
  IsNotOwner _sender;
  IsMember _sender;

  UpdateEpoch;

  delete members[_sender];
  delete tax_approved[_sender];
  e = {_eventname: "MemberLeft"; initiator: _sender; member: _sender};
  event e;

  maybe_officer <- officers[_sender];
  match maybe_officer with
  | Some officer =>
    delete officers[_sender];
    ResetPendingTx
  | None => (* no-op *)
  end
end

(* @dev: Approve membership application and charge joining fee to user.       *)
(* if member leaves and then eventually joins guild again, no fee is charged. *)
(* @param member: member to be charge fee and add to guild                    *)
transition ApproveAndReceiveJoiningFee(member: ByStr20)
  IsNotMigrated;
  IsCaptainOrOfficer _sender;
  IsNotMember member;
  IsApplicationActive member;

  UpdateEpoch;

  (* add member to members *)
  current_epoch <- last_updated_epoch;
  members[member] := current_epoch;

  delete joining_requests[member];

  (* announce new membership *)
  e = {_eventname: "MemberJoined"; initiator: _sender; member: member};
  event e;

  (* check if joining fee paid *)
  maybe_paid_joining_fee <- joining_fee_paid[member];
  match maybe_paid_joining_fee with
  | Some _ => (* no-op - fee already paid previously *)
  | None =>

    (* check if joining fee is zero *)
    fee_amount <- current_joining_fee;
    has_joining_fee = builtin lt zero fee_amount;
    match has_joining_fee with
    | False => (* no-op - joining fee less than eq zero *)
    | True =>
      joining_fee_paid[member] := fee_amount;

      huny_token <- & bank_authority.huny;
      e = {_eventname: "PaidJoiningFee"; member: member; token: huny_token; amount: fee_amount};
      event e;

      ReceiveToken member huny_token fee_amount;

      fee_config <- joining_fee;
      AllocateManagementFee fee_config fee_amount huny_token;
      FlushManagementFees huny_token
    end
   end
end

(* @dev: Reject membership application and remove application.  *)
(* @param member: member whose                                  *)
transition RejectJoinRequest(member: ByStr20)
  IsNotMigrated;
  IsCaptainOrOfficer _sender;
  IsApplicationActive member;

  delete joining_requests[member];

  e = {_eventname: "MemberApplicationRejected"; initiator: _sender; member: member};
  event e
end

(* @dev: Transfers specified amount of tokens to guild bank *)
(* @param token: address of token to donate                 *)
(* @param amount: amount of token to donate                 *)
transition MakeDonation(token: ByStr20, amount: Uint128)
  IsNotMigrated;
  is_token_zil = builtin eq zero_address token;
  match is_token_zil with
  | True =>
    ReceiveZil amount
  | False =>
    maybe_token_address <- & token as ByStr20 with contract field balances : Map ByStr20 Uint128 end;
    match maybe_token_address with
    | Some token_address => ReceiveToken _sender token_address amount
    | None =>
    end
  end;

  e = {_eventname: "DonationReceived"; initiator: _sender; token: token; amount: amount};
  event e
end

(* @dev: Approves tax collection for sender. Tax cannot be collected    *)
(* without this approval first.                                         *)
transition ApproveTaxCollection()
  IsNotMigrated;
  IsMember _sender;
  
  maybe_approved <- tax_approved[_sender];
  match maybe_approved with
  | Some _ =>
  | None =>
    tax_approved[_sender] := true
  end
end

(* @dev: Transfers tax from specified guild members to guild bank       *)
(* @param params: list of member and epoch number to collect taxes for  *)
transition CollectTax(params: List TaxParam)
  IsNotMigrated;
  IsCaptainOrOfficer _sender;

  UpdateEpoch;
  forall params ReceiveTax;

  token <- & bank_authority.huny;
  FlushManagementFees token
end

(* @dev: Migrate current bank contract state to new bank - for contract upgrade *)
(* @param new_bank: new bank contract                                           *)
transition MigrateBank(new_bank: ByStr20)
  IsBankAuthority _sender;
  IsNotMigrated;
  IsHiveEmpty;

  option_new_bank = Some {ByStr20} new_bank;
  migrated_to_bank := option_new_bank;

  e = {_eventname: "BankMigrated"; initiator: _sender; new_bank: new_bank};
  event e
end

transition MigrateData(
  legacy_contract: ByStr20 with contract
    field migrated_to_bank : Option ByStr20,
    field last_updated_epoch : Uint32,
    field joining_requests : Map ByStr20 Bool,
    field joining_fee_paid : Map ByStr20 Uint128,
    field tax_collected : Map Uint32 (Map ByStr20 Uint128),
    field tax_owed : Map Uint32 (Map ByStr20 Uint128)
  end
)
  IsBankAuthority _sender;
  IsNotMigrated;

  maybe_migrated_to_bank <- & legacy_contract.migrated_to_bank;
  match maybe_migrated_to_bank with
  | Some migrated_to =>
    is_migrated_to_self = builtin eq migrated_to _this_address;
    match is_migrated_to_self with
    | False =>
      err = CodeNotMigratedToSelf;
      ThrowError err
    | True => (* validation ok *)
    end
  | None =>
    err = CodeNotMigratedToSelf;
    ThrowError err
  end;

  legacy_last_updated_epoch <- & legacy_contract.last_updated_epoch;
  last_updated_epoch := legacy_last_updated_epoch;

  legacy_joining_requests <- & legacy_contract.joining_requests;
  joining_requests := legacy_joining_requests;

  legacy_joining_fee_paid <- & legacy_contract.joining_fee_paid;
  joining_fee_paid := legacy_joining_fee_paid;

  legacy_tax_collected <- & legacy_contract.tax_collected;
  tax_collected := legacy_tax_collected;

  legacy_tax_owed <- & legacy_contract.tax_owed;
  tax_owed := legacy_tax_owed;

  e = {_eventname : "DataMigrated"; legacy_contract : legacy_contract};
  event e
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
(* @param token: token contract                                       *)
transition MigrateToken(token: ByStr20)
  IsBankAuthority _sender;
  IsMigrated;

  maybe_migrated <- migrated_to_bank;

  match maybe_migrated with
  | None =>
  | Some recipient =>
    is_token_zil = builtin eq token zero_address;
    match is_token_zil with
    | True =>
      zil_balance <- _balance;
      has_no_zil_balance = builtin eq zil_balance zero;
      match has_no_zil_balance with
      | True =>
      | False =>
        SendZil recipient zil_balance
      end
    | False =>
      param = MigrateParam token recipient;
      maybe_token <- & token as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
      match maybe_token with
      | Some token_contract =>
        maybe_token_balance <- & token_contract.balances[_this_address];
        match maybe_token_balance with
        | Some token_balance =>
          params = SendTokenParam recipient token_contract token_balance;
          SendToken params
        | None => (* no-op - should not happen *)
        end
      | None => (* no-op - should not happen *)
      end
    end
  end
end

(* @dev: Claim Refinery pots *)
transition ClaimRefinery(claim_block: BNum)
  IsCaptainOrOfficer _sender;
  hive <- & bank_authority.hive;
  refinery <- & hive.current_refinery;

  msg_to_refinery = {
    _tag: "Claim";
    _recipient: refinery;
    _amount: zero;
    claim_block: claim_block
  };
  msgs = one_msg msg_to_refinery;
  send msgs;

  e = {_eventname: "ClaimedRefinery"; initiator: _sender; claim_block: claim_block};
  event e
end

(* @dev: Claim Magic Hive rewards *)
transition ClaimHive()
  IsCaptainOrOfficer _sender;
  hive_address <- & bank_authority.hive;
  msg_to_hive = {
    _tag: "Claim";
    _recipient: hive_address;
    _amount: zero
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "ClaimedHive"; initiator: _sender};
  event e
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsNotMigrated;
  IsOwner _sender;
  IsMember new_owner;
  
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsNotMigrated;
  IsPendingOwner _sender;
  IsMember _sender;

  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  
  maybe_officer <- officers[_sender];
  match maybe_officer with
  | Some officer => delete officers[_sender]
  | None =>
  end;

  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e;

  ResetPendingTx
end

(***************************************)
(*             Callbacks               *)
(***************************************)

(* receive fee/tax *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op *)
end
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow sending tokens to bank *)
  maybe_token_address <- & _sender as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
  match maybe_token_address with
  | Some token_address => UpdateTokenBalance token_address
  | None => (* no-op *)
  end
end
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow withdraw multisign tx *)
  maybe_token_address <- & _sender as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
  match maybe_token_address with
  | Some token_address => UpdateTokenBalance token_address
  | None => (* no-op *)
  end
end
transition AddFunds()
  (* allow receiving of ZIL from Hive *)
  accept
end
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow receiving HUNY from token contract *)
end
(* receive minted huny *)
transition RecipientAcceptMint(minter: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow receiving HUNY from refinery *)
end
