scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import ListUtils
library ZolarProfessions

let true = True
let false = False
let zero = Uint128 0
let uint256_zero = Uint256 0
let uint256_one = Uint256 1
let one = Uint128 1
let two = Uint128 2
let none = None {ByStr20}
let empty = ""
let empty_traits = Nil {(Pair String String)}
let hundred_percent_bps = Uint128 10000
let hundred = Uint128 100
let empty_pair = Pair {Uint128 Uint128} zero zero
let zero_address = 0x0000000000000000000000000000000000000000

let trait_key_profession = "Profession"
let trait_val_str = "STR"
let trait_val_dex = "DEX"
let trait_val_int = "INT"

let trait_list_filter = @list_filter (Pair String String)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodeNotOperatorError
  | CodeOperatorFoundError
  | CodeOperatorNotFoundError
  | CodeInvalidMetazoaContract
  | CodeNotTokenOwner

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                          => Int32 -1
      | CodeNotPendingOwner                   => Int32 -2
      | CodePendingOwnerNotEmpty              => Int32 -3
      | CodeNotOperatorError                  => Int32 -4
      | CodeOperatorFoundError                => Int32 -5
      | CodeOperatorNotFoundError             => Int32 -6
      | CodeInvalidMetazoaContract            => Int32 -7
      | CodeNotTokenOwner                     => Int32 -8
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let nil_msg = Nil {Message} in
  let list = Cons {Message} msg1 nil_msg in
  Cons {Message} msg2 list

let str_exist = 
  fun (str: String) =>
  fun (list: List String) =>
    let exist = @list_exists String in
    let fn = fun (item: String) => builtin eq item str in
    exist fn list

let append_or_replace =
  fun (traits: List (Pair String String)) =>
  fun (new_trait: Pair String String) =>
    let new_trait_key = match new_trait with | Pair key _ => key end in
    let filter_fn = fun (trait: Pair String String) =>
      let trait_key = match trait with | Pair key _ => key end in
      let is_profession = builtin eq trait_key new_trait_key in
      match is_profession with | True => false | False => true end
    in
    let new_traits = trait_list_filter filter_fn traits in
    Cons {(Pair String String)} new_trait new_traits

let get_maybe_address = 
  fun (maybe_address: Option ByStr20) =>
    match maybe_address with
    | Some addr => addr
    | None => zero_address
    end
    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ZolarProfessions(
  initial_owner : ByStr20
)

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

(* Set for operators *)
(* `initial_contract_owner` is a operator by default *)
field operators: Map ByStr20 Bool =
    let emp_map = Emp ByStr20 Bool in
    builtin put emp_map initial_owner true

field professions: List String = 
  let p0 = Nil {String} in
  let p1 = Cons {String} trait_val_str p0 in
  let p2 = Cons {String} trait_val_dex p1 in
  Cons {String} trait_val_int p2

field metazoa_address : Option (ByStr20 with contract
  field traits: Map Uint256 (List (Pair String String)),
  field token_owners: Map Uint256 ByStr20
end) = None {(ByStr20 with contract
  field traits: Map Uint256 (List (Pair String String)),
  field token_owners: Map Uint256 ByStr20
end)}

field receiving_metazoa_address : ByStr20 = zero_address

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsOperator(address: ByStr20)
  has_operator <- exists operators[address];
  match has_operator with
  | True =>
  | False =>
    err = CodeNotOperatorError;
    ThrowError err
  end
end

procedure IsOwnerOrOperator(token_id: Uint256, address: ByStr20)
  is_operator <- exists operators[address];
  match is_operator with
  | True =>
  | False =>
    maybe_metazoa_contract <- metazoa_address;
    match maybe_metazoa_contract with
    | None =>
      err = CodeInvalidMetazoaContract;
      ThrowError err
    | Some curr_metazoa_contract =>
      maybe_token_owner <- & curr_metazoa_contract.token_owners[token_id];
      token_owner = match maybe_token_owner with
        | Some addr => addr
        | None => zero_address
        end;

      is_token_owner = builtin eq address token_owner;
      match is_token_owner with
      | True =>
      | False =>
        err = CodeNotTokenOwner;
        ThrowError err
      end
      
    end
  end
end


procedure VerifyProfession(profession: String)
  accepted_professions <- professions;
  profession_exist = str_exist profession accepted_professions;
  match profession_exist with
  | True =>
  | False =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure UpdateProfessionTrait(token_id: Uint256, profession: String)
  VerifyProfession profession;

  maybe_metazoa_contract <- metazoa_address;
  match maybe_metazoa_contract with
  | None =>
    err = CodeInvalidMetazoaContract;
    ThrowError err
  | Some curr_metazoa_contract =>
    maybe_traits <- & curr_metazoa_contract.traits[token_id];
    traits = match maybe_traits with
      | None => empty_traits
      | Some traits => traits
      end;
    
    new_trait = Pair {String String} trait_key_profession profession;
    new_traits = append_or_replace traits new_trait;

    msg_to_metazoa = {
      _tag: "SetTokenTraits";
      _recipient: curr_metazoa_contract;
      _amount: zero;
      token_id: token_id;
      proposed_traits: new_traits
    };

    msgs = one_msg msg_to_metazoa;
    send msgs 
  end
end

procedure SendMsgMetazoa(msgs: List Message)
  maybe_metazoa_contract <- metazoa_address;
  match maybe_metazoa_contract with
  | None =>
    err = CodeInvalidMetazoaContract;
    ThrowError err
  | Some curr_metazoa_contract =>
    send msgs
  end
end


(***************************************)
(*             Transitions             *)
(***************************************)

transition UpdateProfession(token_id: Uint256, profession: String)
  IsOwnerOrOperator token_id _sender;

  UpdateProfessionTrait token_id profession
end


(* Adds `operator`. *)
(* @Requirements: *)
(* - `_sender` must be the contract owner. Otherwise, it must throw `NotContractOwnerError` *)
(* - `operator` must not be already a operator. Otherwise, it must throw `OperatorFoundError` *)
transition AddOperator(operator: ByStr20)
  IsOwner _sender;
  has_operator <- exists operators[operator];
  match has_operator with
  | True =>
    err = CodeOperatorFoundError;
    ThrowError err
  | False =>
    operators[operator] := true
  end;

  e = {
    _eventname: "AddOperator";
    operator: operator;
    initiator: _sender
  };
  event e
end

(* Removes `operator`. *)
(* @Requirements: *)
(* - `_sender` must be the contract owner. Otherwise, it must throw `NotContractOwnerError` *)
(* - `operator` must be already a operator. Otherwise, it must throw `OperatorNotFoundError` *)
transition RemoveOperator(operator: ByStr20)
  IsOwner _sender;
  has_operator <- exists operators[operator];
  match has_operator with
  | False =>
    err = CodeOperatorNotFoundError;
    ThrowError err
  | True =>
    delete operators[operator]
  end;

  e = {
    _eventname: "RemoveOperator";
    operator: operator;
    initiator: _sender
  };
  event e
end

(***************************************************)
(*            Metazoa Proxy Transitions            *)
(***************************************************)

(* @dev: Proxy update the traits of a given token_id     *)
(* param: token_id - Unique ID of the metazoa NFT        *)
(* param: proposed_traits   - A map of the traits        *)
transition SetTokenTraits(
  token_id: Uint256,
  proposed_traits: List (Pair String String)
)
  IsOperator _sender;

  maybe_metazoa_contract <- metazoa_address;
  curr_metazoa_address = get_maybe_address maybe_metazoa_contract;
  
  msg_to_metazoa = {
    _tag: "SetTokenTraits";
    _recipient: curr_metazoa_address;
    _amount: zero;
    token_id: token_id;
    proposed_traits: proposed_traits
  };

  msgs = one_msg msg_to_metazoa;
  SendMsgMetazoa msgs 
end

(* Proxy pauses the metazoa contract. *)
transition PauseMetazoa()
  IsOwner _sender;

  maybe_metazoa_contract <- metazoa_address;
  curr_metazoa_address = get_maybe_address maybe_metazoa_contract;
  
  msg_to_metazoa = {
    _tag: "Pause";
    _recipient: curr_metazoa_address;
    _amount: zero
  };

  msgs = one_msg msg_to_metazoa;
  SendMsgMetazoa msgs
end

(* Proxy unpauses the metazoa contract. *)
transition UnpauseMetazoa()
  IsOwner _sender;

  maybe_metazoa_contract <- metazoa_address;
  curr_metazoa_address = get_maybe_address maybe_metazoa_contract;
  
  msg_to_metazoa = {
    _tag: "Unpause";
    _recipient: curr_metazoa_address;
    _amount: zero
  };

  msgs = one_msg msg_to_metazoa;
  SendMsgMetazoa msgs
end

transition SetContractOwnershipRecipient(to: ByStr20)
  IsOwner _sender;

  maybe_metazoa_contract <- metazoa_address;
  curr_metazoa_address = get_maybe_address maybe_metazoa_contract;
  
  msg_to_metazoa = {
    _tag: "SetContractOwnershipRecipient";
    _recipient: curr_metazoa_address;
    _amount: zero;
    to: to
  };

  msgs = one_msg msg_to_metazoa;
  SendMsgMetazoa msgs
end

transition AcceptContractOwnership(new_metazoa_address: ByStr20)
  IsOwner _sender;

  receiving_metazoa_address := new_metazoa_address;

  msg_to_metazoa = {
    _tag: "AcceptContractOwnership";
    _recipient: new_metazoa_address;
    _amount: zero
  };

  msgs = one_msg msg_to_metazoa;
  send msgs
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end

(***************************************)
(*             Callbacks               *)
(***************************************)

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  msg_to_resource = {
    _tag: "Burn";
    _recipient: _sender;
    _amount: zero;
    burn_account: _this_address;
    amount: amount
  };
 
  msgs = one_msg msg_to_resource;
  send msgs 
end

transition ZRC6_RecipientAcceptTransferFrom(from: ByStr20, to: ByStr20, token_id: Uint256)
  msg_to_token = {
    _tag: "BurnToken";
    _recipient: _sender;
    _amount: zero;
    token_id: token_id
  };

  msgs = one_msg msg_to_token;
  send msgs 
end

(* accept proxy *)
transition ZRC6_AcceptContractOwnershipCallback(contract_owner: ByStr20)
  curr_receiving_address <- receiving_metazoa_address;
  is_valid_contract = builtin eq curr_receiving_address _sender;
  match is_valid_contract with
  | True =>
  | False =>
    err = CodeInvalidMetazoaContract;
    ThrowError err
  end;
  

  maybe_metazoa_contract <- & _sender as ByStr20 with contract
    field traits: Map Uint256 (List (Pair String String)),
    field token_owners: Map Uint256 ByStr20
  end;
  match maybe_metazoa_contract with
  | None =>
    err = CodeInvalidMetazoaContract;
    ThrowError err
  | Some _ => 
    metazoa_address := maybe_metazoa_contract
  end
end

(* burn geodes *)
transition BurnSuccessCallBack(burner: ByStr20, burn_account: ByStr20, amount: Uint128)
  (* no-op *)
end

(* burn gems *)
transition ZRC6_BurnCallBack(token_owner: ByStr20, token_id: Uint256)
  (* no-op *)
end

