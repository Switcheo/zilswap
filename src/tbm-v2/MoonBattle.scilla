(* SPDX-License-Identifier: MIT *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
library MoonBattle

let zero = Uint32 0
let one = Uint32 1

type Action =
  | HarvestHuny
  | ReturnToBase
  | SummonReinforcements

(* Error exception *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodeNotOracle

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                    => Int32 -1
      | CodeNotPendingOwner             => Int32 -2
      | CodePendingOwnerNotEmpty        => Int32 -3
      | CodeNotOracle                   => Int32 -4
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg: Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract MoonBattle
(
  initial_owner: ByStr20,
  initial_oracle: ByStr20,
  huny_token: ByStr20, (* _this_address must also be a minter (to burn huny) *)
  metazoa_contract: ByStr20 with contract (* _this_address must also be a minter (to mint reinforcements) *)
    field token_owners : Map Uint256 ByStr20
  end
)

(* Contract constraints *)
with
=>

(* Mutable fields *)

(* game addresses *)
field current_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none
field current_oracle : ByStr20 = ByStr20 initial_oracle

(* map of battling metazoas to their commanders (internal owner) *)
field metazoa_commanders: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* incrementing action id *)
field current_action_id: Uint32 = zero

(* map of ongoing action ids to action type *)
field ongoing_actions: Map Uint32 Action = Emp Uint32 Action

(* maps huny harvests that have been initialized but not concluded via oracle randomness provision *)
field ongoing_harvests: Map Uint32 (List Uint256) = Emp Uint32 (List Uint256)

(* maps returns to base that have been initialized but not concluded via oracle randomness provision *)
field ongoing_returns: Map Uint32 (List Uint256) = Emp Uint32 (List Uint256)

(* maps summons that have been initialized but not concluded via oracle randomness provision *)
field ongoing_summons: Map Uint32 Uint32 = Emp Uint32 Uint32

(* validates that the tx sender is the owner of the metazoa *)
procedure ValidateOwnership(token_id: Uint256)
  maybe_owner <- & metazoa_contract.token_owners[token_id];
  match maybe_owner with
  | Some actual_owner =>
    is_owner = builtin eq actual_owner _sender;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotTokenOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotTokenOwner;
    ThrowError err
  end
end

(* validates that the tx sender is the commander of the battling metazoa *)
procedure ValidateCommander(token_id: Uint256)
  maybe_owner <- metazoa_commanders[token_id];
  match maybe_owner with
  | Some actual_owner =>
    is_owner = builtin eq actual_owner _sender;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotTokenOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotTokenOwner;
    ThrowError err
  end
end

(* transfers a metazoa to this contract for battle under the tx sender as the commander *)
procedure TransferToBattle(token_id: Uint256)
  metazoa_commanders[token_id] = _sender;
  msg_to_metazoa = {
    _tag: "TransferFrom";
    _recipient: metazoa_contract;
    _amount: zero;
    to: _this_address;
    token_id: token_id
  };
  msgs = one_msg msg_to_metazoa;
  send msgs
end

procedure RemoveCommander(token_id: Uint256)
  delete metazoa_commanders[token_id]
end

(* burns huny from the targeted account *)
procedure BurnHuny(burn_account: ByStr20, amount: Uint128)
  msg_to_huny = {
    _tag: "Burn";
    _recipient: huny_token;
    _amount: zero;
    burn_account: burn_account;
    amount: amount
  };
  msgs = one_msg msg_to_metazoa;
  send msgs
end

(* emits an event with the current action id and action type, incrementing the current_action_id for next use *)
procedure StartAction(action_id : Uint32, action_type : Action)
  ongoing_actions[action_id] := action_type;
  new_action_id = builtin add action_id one;
  current_action_id := new_action_id;
  e = { _eventname: "ActionStarted"; action_id: action_id; action_type: action_type };
  event e
end

procedure ConcludeHarvestHuny(token_ids : List Uint256)
  (* increase reward pool for minos *)
  (* send remaining huny to commander *)
end

procedure ConcludeReturnToBase(token_ids : List Uint256)
  (* for each metazoa: *)
  (* calculate if huny is stolen (60%) *)
  (* increase mino reward pool if stolen, else send to commander *)
  (* calculate if metazoa is kidnapped (10%) for gen1-3 *)
  (* if not kidnapped, send to user *)
  (* if kidnapped, assign new commander based on berserker level *)
end

procedure ConcludeSummonReinforcements(count : Uint32)
  (* calculate how many reinforcements are kidnapped (15%) *)
  (* if not kidnapped, send to user via batchmint *)
  (* if kidnapped, send to contract via batchmint and assign new commander based on berserker level *)
end

(***************************************************)
(*               Battle Transitions                *)
(***************************************************)

transition EnterBattle(token_ids : List Uint256)
  forall token_ids ValidateOwnership;
  forall token_ids TransferToBattle
end

transition HarvestHuny(token_ids : List Uint256)
  forall token_ids ValidateCommander;
  action_type = HarvestHuny;
  action_id <- current_action_id;
  ongoing_harvests[action_id] := token_ids;
  StartAction action_id action_type
end

transition ReturnToBase(token_ids : List Uint256)
  forall token_ids ValidateCommander;
  (* remove from stake here to avoid "double spend " *)
  forall token_ids RemoveCommander;
  action_type = ReturnToBase;
  action_id <- current_action_id;
  ongoing_returns[action_id] := token_ids;
  StartAction action_id action_type
end

transition SummonReinforcements(count : Uint32)
  (* calculate amount of huny required based on summon count *)
  (* burn huny *)
  action_type = SummonReinforcements;
  action_id <- current_action_id;
  ongoing_summons[action_id] := count;
  StartAction action_id action_type
end

transition ConcludeAction(action_id : Uint32, random : Uint256)
  IsOracle _sender;
  action_type <- ongoing_actions[action_id];
  match action_type with
  | HarvestHuny =>
    token_ids <- ongoing_harvests[action_id];
    ConcludeHarvestHuny token_ids
    delete ongoing_harvests[action_id];
  | ReturnToBase
    token_ids <- ongoing_returns[action_id];
    ConcludeReturnToBase token_ids
    delete ongoing_returns[action_id];
  | SummonReinforcements
    count <- ongoing_summons[action_id];
    ConcludeSummonReinforcements count
    delete ongoing_summons[action_id];
  end
  delete ongoing_actions[action_id];
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- current_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsOracle(address: ByStr20)
  maybe_current_oracle <- current_oracle;
  match maybe_current_oracle with
  | Some current_oracle =>
    is_oracle = builtin eq current_oracle address;
    match is_oracle with
    | True =>
    | False =>
      err = CodeNotOracle;
      ThrowError err
    end
  | None =>
    err = CodeNotOracle;
    ThrowError err
  end
end

(* @dev: Removes the current_owner, meaning that new minters can no longer be added. Must not have a pending owner. *)
transition RevokeOwnership()
  IsOwner _sender;
  NoPendingOwner;
  current_owner := none;
  e = {_eventname : "OwnershipRevoked"; current_owner : _sender};
  event e
end

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new current_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; current_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new current_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_current_owner <- current_owner;
  o = Some {ByStr20} _sender;
  current_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_current_owner : previous_current_owner; current_owner : _sender};
  event e
end
