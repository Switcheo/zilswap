scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

library MagicHive

let true = True
let false = False
let zero = Uint128 0
let one = Uint128 1
let none = None {ByStr20}

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodeNotSelf
  | CodeInsufficientBalance

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner              => Int32 -1
      | CodeNotPendingOwner       => Int32 -2
      | CodePendingOwnerNotEmpty  => Int32 -3
      | CodeNotSelf               => Int32 -4
      | CodeInsufficientBalance   => Int32 -5
      end
    in
    { _exception : "Error"; code : result_code }


let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let three_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  fun (msg3 : Message) =>
    let msgs_tmp = two_msgs msg2 msg3 in
    Cons {Message} msg1 msgs_tmp

let four_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  fun (msg3 : Message) =>
  fun (msg4 : Message) =>
    let msgs_tmp = three_msgs msg2 msg3 msg4 in
    Cons {Message} msg1 msgs_tmp

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract MagicHive(
  init_owner: ByStr20,
  huny_token: ByStr20  with contract
    field balances : Map ByStr20 Uint128
  end,
  zilswap_contract: ByStr20 with contract
    field balances : Map ByStr20 (Map ByStr20 Uint128)
  end
)

field contract_owner : Option ByStr20 = Some {ByStr20} init_owner
field pending_owner : Option ByStr20 = none
field enabled : Bool = True

field balances : Map ByStr20 Uint128 = Emp ByStr20 Uint128

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsSelf(address: ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure UpdateBalance(address: ByStr20)
  b <- & zilswap_contract.balances[huny_token][address];
  balance = get_amount_or_zero b;
  balances[_sender] := balance
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end

(* @dev: Disables adding of liquidity. Only can be called by the contract_owner. *)
transition Disable()
  IsOwner _sender;
  enabled := false
end

(* @dev: Enables adding of liquidity. Only can be called by the contract_owner. *)
transition Enable()
  IsOwner _sender;
  enabled := true
end

(* @dev: Swaps the required amount of HUNY for ZIL and adds  evenly to Zilswap. *)
transition SwapAndAddLiquidity(

)
  (* TODO *)
end

(* @dev: Adds liquidity to Zilswap using the given params. *)
transition AddLiquidity(
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  e <- enabled;
  match e with
  | False => (* no op *)
  | True =>
    accept;
    amount <- _balance;
    msg_to_token1 = {
      _tag : "TransferFrom"; _recipient: huny_token; _amount: zero;
      from: _sender; to: _this_address; amount: max_token_amount
    };
    msg_to_token2 = {
      _tag : "IncreaseAllowance"; _recipient : huny_token; _amount : zero;
      spender : zilswap_contract; amount : max_token_amount
    };
    msg_to_zilswap = {
      _tag : "AddLiquidity"; _recipient : zilswap_contract; _amount : amount;
      token_address : huny_token; min_contribution_amount : zero; max_token_amount : max_token_amount; deadline_block : deadline_block
    };
    msg_to_self = {
      _tag : "Withdraw"; _recipient : _this_address; _amount : zero;
      address: _sender
    };
    msgs = four_msgs msg_to_token1 msg_to_token2 msg_to_zilswap msg_to_self;
    send msgs
  end
end

(* @dev: Removes liquidity from Zilswap based on the given params. *)
transition RemoveLiquidity(
  contribution_amount : Uint128,
  min_zil_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  b <- balances[_sender];
  balance = get_amount_or_zero b;
  insufficient_balance = builtin lt balance contribution_amount;
  match insufficient_balance with
  | True =>
    err = CodeInsufficientBalance;
    ThrowError err
  | False =>
    msg_to_zilswap = {
      _tag : "RemoveLiquidity"; _recipient : zilswap_contract; _amount : zero;
      token_address : huny_token; contribution_amount : contribution_amount; min_zil_amount : min_zil_amount; min_token_amount : min_token_amount; deadline_block : deadline_block
    };
    msg_to_self = {
      _tag : "Withdraw"; _recipient : _this_address; _amount : zero;
      address: _sender
    };
    msgs = two_msgs msg_to_zilswap msg_to_self;
    send msgs
  end
end

(* @dev: Withdraws all HUNY and ZIL from the contract to the user. Can only be called by this contract. *)
transition Withdraw(address : ByStr20)
  IsSelf _sender;
  UpdateBalance address;

  zil_amount <- _balance;
  huny_balance <- & huny_token.balances[_this_address];
  huny_amount = get_amount_or_zero huny_balance;

  msg_to_user = {
    _tag : "AddFunds"; _recipient : address; _amount : zil_amount
  };
  msg_to_token = {
    _tag : "Transfer"; _recipient : huny_token; _amount : zero;
    to : address; amount : huny_amount
  };
  msgs = two_msgs msg_to_user msg_to_token;
  send msgs
end

(***************************************)
(*             Callbacks               *)
(***************************************)

transition AddFunds()
  (* allow receiving of ZIL from Zilswap *)
  accept
end

transition RecipientAcceptTransfer(sender : ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow receiving HUNY from user *)
end

transition TransferSuccessCallBack(sender : ByStr20, recipient : ByStr20, amount : Uint128)
  (* no-op - allow withdrawing HUNY to user *)
end
