scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

library MagicHive

let true = True
let false = False
let zero = Uint128 0
let one = Uint128 1
let zero_u256 = Uint256 0
let none = None {ByStr20}
let share_factor = Uint256 1000000000000 (* huny_per_share is multiplied by this to retain precision *)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodeNotEnabled
  | CodeNotDisabled
  | CodeNotSelf
  | CodeInsufficientBalance

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner              => Int32 -1
      | CodeNotPendingOwner       => Int32 -2
      | CodePendingOwnerNotEmpty  => Int32 -3
      | CodeNotEnabled            => Int32 -4
      | CodeNotDisabled           => Int32 -5
      | CodeNotSelf               => Int32 -6
      | CodeInsufficientBalance   => Int32 -7
      end
    in
    { _exception : "Error"; code : result_code }


let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let three_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  fun (msg3 : Message) =>
    let msgs_tmp = two_msgs msg2 msg3 in
    Cons {Message} msg1 msgs_tmp

let four_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  fun (msg3 : Message) =>
  fun (msg4 : Message) =>
    let msgs_tmp = three_msgs msg2 msg3 msg4 in
    Cons {Message} msg1 msgs_tmp

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end

let get_amount_or_zero_u256 =
  fun (maybe : Option Uint256) =>
    match maybe with
    | Some amt => amt
    | None => zero_u256
    end

let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => zero_u256 (* should never happen *)
    end

let bsub_to_u256 =
  fun (a : BNum) =>
  fun (b : BNum) =>
    let d = builtin bsub a b in
    let d_u256 = builtin to_uint256 d in
    match d_u256 with
    | Some r => r
    | None =>
      let x = zero_u256 in
      let y = Uint256 1 in
      builtin sub x y (* throw if a < b or a - b > size(uint128) *)
    end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract MagicHive(
  init_owner: ByStr20,
  refinery: ByStr20,
  huny_token: ByStr20  with contract
    field balances : Map ByStr20 Uint128
  end,
  zilswap_contract: ByStr20 with contract
    field balances : Map ByStr20 (Map ByStr20 Uint128)
  end
)

field contract_owner : Option ByStr20 = Some {ByStr20} init_owner
field pending_owner : Option ByStr20 = none
field enabled : Bool = True

field total_supply : Uint128 = zero
field balances : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field debt : Map ByStr20 Uint256 = Emp ByStr20 Uint256

field huny_per_block : Uint256 = Uint256 81018518518519 (* 36,750,000 HUNY / 180days = 204166666666666667 HUNY/day = 81018518518519 HUNY/block @ 2520 blocks/day  *)
field huny_rewards_per_share : Uint256 = zero_u256 (* this is multiplied by share_factor *)
field last_reward_block : BNum = BNum 0

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsSelf(address: ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsEnabled()
  e <- enabled;
  match e with
  | True =>
  | False =>
    err = CodeNotEnabled;
    ThrowError err
  end
end

procedure UpdateBalance(address: ByStr20)
  acc_rewards <- huny_rewards_per_share;

  b <- & zilswap_contract.balances[huny_token][_this_address];
  new_supply = get_amount_or_zero b;
  prev_supply <- total_supply;

  ud <- debt[address];
  user_debt = get_amount_or_zero_u256 ud;

  ub <- balances[address];
  match ub with
  | None => (* no-op *)
  | Some balance =>
    (* send rewards first *)
    reward =
      let balance_u256 = grow balance in
      let pending_1e12 = builtin mul balance_u256 acc_rewards in
      let pending = builtin div pending_1e12 share_factor in
      builtin sub pending user_debt;
    msg_to_refinery = {
      _tag: "Refine";
      _recipient: refinery;
      _amount: zero;
      to: address;
      amount: reward
    };
    msgs = one_msg msg_to_refinery;
    send msgs
  end;

  user_balance = get_amount_or_zero ub;
  new_user_balance =
    let increased = builtin lt prev_supply new_supply in
    match increased with
    | True =>
      let diff = builtin sub new_supply prev_supply in
      builtin add user_balance diff
    | False =>
      let diff = builtin sub prev_supply new_supply in
      builtin sub user_balance diff
    end;

  new_debt =
    let ub_u256 = grow new_user_balance in
    let debt_1e12 = builtin mul ub_u256 acc_rewards in
    builtin div debt_1e12 share_factor;
  debt[address] := new_debt;

  balances[address] := new_user_balance;
  total_supply := new_supply
end

procedure UpdateRewards()
  current_block <- & BLOCKNUMBER;
  last_block <- last_reward_block;
  needs_reward = builtin blt last_block current_block;
  match needs_reward with
  | False => (* no-op *)
  | True =>
    blocks_to_reward = bsub_to_u256 current_block last_block;
    lp_supply <- total_supply;
    prev <- huny_rewards_per_share;
    per_block <- huny_per_block;
    new =
      let lp_supply_u256 = grow lp_supply in
      let rewards = builtin mul blocks_to_reward per_block in
      let rewards_1e12 = builtin mul rewards share_factor in
      let rewards_per_share = builtin div rewards_1e12 lp_supply_u256 in
      builtin add prev rewards_per_share;
    huny_rewards_per_share := new
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Adds liquidity to Zilswap using the given params. *)
transition AddLiquidity(
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  IsEnabled;
  UpdateRewards;
  accept;
  amount <- _balance;
  msg_to_token1 = {
    _tag : "TransferFrom"; _recipient: huny_token; _amount: zero;
    from: _sender; to: _this_address; amount: max_token_amount
  };
  msg_to_token2 = {
    _tag : "IncreaseAllowance"; _recipient : huny_token; _amount : zero;
    spender : zilswap_contract; amount : max_token_amount
  };
  msg_to_zilswap = {
    _tag : "AddLiquidity"; _recipient : zilswap_contract; _amount : amount;
    token_address : huny_token; min_contribution_amount : zero; max_token_amount : max_token_amount; deadline_block : deadline_block
  };
  msg_to_self = {
    _tag : "Flush"; _recipient : _this_address; _amount : zero;
    address: _sender
  };
  msgs = four_msgs msg_to_token1 msg_to_token2 msg_to_zilswap msg_to_self;
  send msgs
end

(* @dev: Swaps the required amount of HUNY for ZIL and adds  evenly to Zilswap. *)
transition SwapAndAddLiquidity(

)
  IsEnabled;
  UpdateRewards;
  accept
  (* TODO *)
end

(* @dev: Removes liquidity from Zilswap based on the given params. *)
transition RemoveLiquidity(
  contribution_amount : Uint128,
  min_zil_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  UpdateRewards;
  b <- balances[_sender];
  balance = get_amount_or_zero b;
  insufficient_balance = builtin lt balance contribution_amount;
  match insufficient_balance with
  | True =>
    err = CodeInsufficientBalance;
    ThrowError err
  | False =>
    msg_to_zilswap = {
      _tag : "RemoveLiquidity"; _recipient : zilswap_contract; _amount : zero;
      token_address : huny_token; contribution_amount : contribution_amount; min_zil_amount : min_zil_amount; min_token_amount : min_token_amount; deadline_block : deadline_block
    };
    msg_to_self = {
      _tag : "Flush"; _recipient : _this_address; _amount : zero;
      address: _sender
    };
    msgs = two_msgs msg_to_zilswap msg_to_self;
    send msgs
  end
end

(* @dev: Removes all liquidity from Zilswap without any reward functions. *)
transition EmergencyWithdraw(
  min_zil_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  b <- balances[_sender];
  contribution_amount = get_amount_or_zero b;
  msg_to_zilswap = {
    _tag : "RemoveLiquidity"; _recipient : zilswap_contract; _amount : zero;
    token_address : huny_token; contribution_amount : contribution_amount; min_zil_amount : min_zil_amount; min_token_amount : min_token_amount; deadline_block : deadline_block
  };
  msg_to_self = {
    _tag : "FlushWithoutRewards"; _recipient : _this_address; _amount : zero;
    address: _sender
  };
  msgs = two_msgs msg_to_zilswap msg_to_self;
  send msgs
end

(* @dev: Claims rewards for the sender. *)
transition Claim()
  UpdateRewards;
  UpdateBalance _sender
end

(* @dev: Flush all HUNY and ZIL from the contract to the user. Can only be called by this contract. *)
transition Flush(address : ByStr20)
  IsSelf _sender; (* already done UpdateRewards *)
  UpdateBalance address;

  zil_amount <- _balance;
  huny_balance <- & huny_token.balances[_this_address];
  huny_amount = get_amount_or_zero huny_balance;

  msg_to_user = {
    _tag : "AddFunds"; _recipient : address; _amount : zil_amount
  };
  msg_to_token = {
    _tag : "Transfer"; _recipient : huny_token; _amount : zero;
    to : address; amount : huny_amount
  };
  msgs = two_msgs msg_to_user msg_to_token;
  send msgs
end

(* @dev: Flush all HUNY and ZIL from the contract to the user without rewards. Can only be called by this contract. *)
transition FlushWithoutRewards(address : ByStr20)
  IsSelf _sender;

  zil_amount <- _balance;
  huny_balance <- & huny_token.balances[_this_address];
  huny_amount = get_amount_or_zero huny_balance;

  balances[address] := zero;
  debt[address] := zero_u256;

  msg_to_user = {
    _tag : "AddFunds"; _recipient : address; _amount : zil_amount
  };
  msg_to_token = {
    _tag : "Transfer"; _recipient : huny_token; _amount : zero;
    to : address; amount : huny_amount
  };
  msgs = two_msgs msg_to_user msg_to_token;
  send msgs
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end

(* @dev: Sets the current huny reward per block. *)
transition SetHunyRewardsPerBlock(rewards_per_block: Uint256)
  IsOwner _sender;
  huny_per_block := rewards_per_block
end

(* @dev: Enables adding of liquidity. Only can be called by the contract_owner. *)
transition Enable()
  IsOwner _sender;
  enabled := true
end

(* @dev: Disables adding of liquidity. Only can be called by the contract_owner. *)
transition Disable()
  IsOwner _sender;
  enabled := false
end

(***************************************)
(*             Callbacks               *)
(***************************************)

transition AddFunds()
  (* allow receiving of ZIL from Zilswap *)
  accept
end

transition RecipientAcceptTransfer(sender : ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow receiving HUNY from user *)
end

transition TransferSuccessCallBack(sender : ByStr20, recipient : ByStr20, amount : Uint128)
  (* no-op - allow withdrawing HUNY to user *)
end
