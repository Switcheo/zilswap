scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import IntUtils ListUtils BoolUtils
library BurnTBMMinter

(* Global variables *)
let max_mint_quantity = Uint32 10
let zero = Uint128 0
let one = Uint256 1
let one_big = Uint128 1
let none = None {ByStr20}
let false = False
let true = True
let empty = ""

(* Library functions *)
let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs : Message -> Message -> List Message =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let first = one_msg msg1 in
    Cons { Message } msg2 first

let grow : Uint32 -> Uint128 =
  fun (var : Uint32) =>
    let maybe_big = builtin to_uint128 var in
    match maybe_big with
    | Some big => big
    | None => Uint128 0 (* should never happen *)
    end

(* @dev:    Builds a pair of messages for each token_id provided.                                *)
(* @dev:    The first message is an instruction to burn from v1 NFT with a given token_id        *)
(* @dev:    The second message is an instruction to mint from v2 NFT                             *)
(* @param:  nft_address - NFT v2 contract                                                        *)
(* @param:  tbm_address - NFT v1 contract                                                        *)
(* @param:  to - Recipient of the NFT to be minted to                                            *)
(* @param:  token_ids - List of token ids to be burnt from the v1 contract                       *)
let build_burn_mint_msgs : ByStr20 -> ByStr20 -> ByStr20 -> List (Uint256) -> List (Message) =
  fun (nft_address : ByStr20) =>
  fun (tbm_address: ByStr20) =>
  fun (to: ByStr20) =>
  fun (token_ids: List (Uint256)) =>
    let f = fun (token_id: Uint256) =>
      let msg1 = { _tag: "Burn"; _recipient: tbm_address; _amount: zero; token_id: token_id } in 
      let msg2 = { _tag: "Mint"; _recipient: nft_address; _amount: zero; to: to; token_uri: empty } in
      two_msgs msg1 msg2
    in
    let mapper = @list_map Uint256 (List (Message)) in
    let messages = mapper f token_ids in
    let flatten = @list_flatten (Message) in
    flatten messages

(* Error exception *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodeExceedMaxMintQuantity
  | CodeNotReservedToken
  | CodeExceedMaxSupply
  | CodeNotApproved

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                    => Int32 -1
      | CodeNotPendingOwner             => Int32 -2
      | CodePendingOwnerNotEmpty        => Int32 -3
      | CodeExceedMaxMintQuantity       => Int32 -4
      | CodeNotReservedToken            => Int32 -5
      | CodeExceedMaxSupply             => Int32 -6
      | CodeNotApproved                 => Int32 -7
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract BurnTBMMinter
(
  contract_owner: ByStr20,
  nft_address: ByStr20,
  max_supply: Uint128,
  tbm_address: ByStr20
)

(* Mutable fields *)

field current_owner : Option ByStr20 = Some {ByStr20} contract_owner
field pending_owner : Option ByStr20 = none
field total_supply: Uint128 = Uint128 0

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- current_owner;
  match maybe_current_owner with
  | Some current_contract_owner =>
    is_owner = builtin eq current_contract_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure NoPendingOwner()
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some p =>
    err = CodePendingOwnerNotEmpty;
    ThrowError err
  | None =>
  end
end

procedure IsWithinMintLimit(quantity: Uint32)
  is_not_exceeding = uint32_le quantity max_mint_quantity;
  match is_not_exceeding with
  | True =>
  | False =>
    err = CodeExceedMaxMintQuantity;
    ThrowError err
  end
end

procedure CheckTotalMinted(quantity: Uint32)
  qty = grow quantity;
  current_supply <- total_supply;
  new_supply = builtin add current_supply qty;
  total_supply := new_supply;
  is_not_exceeding = uint128_le new_supply max_supply;
  match is_not_exceeding with
  | True =>
  | False =>
    err = CodeExceedMaxMintQuantity;
    ThrowError err
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev:    Mint new tokens to contract owner                             *)
(* @param:  to       - Recipient address of token                         *)
(* @param:  token_ids - List of all TBM tokens ids to burn                *)
transition BurnAndMint(
    to: ByStr20,
    token_ids: List Uint256
  )
  quantity = let my_list_length = @list_length Uint256 in my_list_length token_ids;
  CheckTotalMinted quantity;
  msgs = build_burn_mint_msgs nft_address tbm_address to token_ids;
  send msgs
end

(** Ownership lifecycle transitions *)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new current_owner.                                                                                     *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; current_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new current_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_current_owner <- current_owner;
  o = Some {ByStr20} _sender;
  current_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_current_owner : previous_current_owner; current_owner : _sender};
  event e
end

(* @dev: Removes the current_owner, meaning that new minters can no longer be added. Must not have a pending owner. *)
transition RevokeOwnership()
  IsOwner _sender;
  NoPendingOwner;
  current_owner := none;
  e = {_eventname : "OwnershipRevoked"; current_owner : _sender};
  event e
end

(*************************************)
(*             Callbacks             *)
(*************************************)

transition ZRC6_MintCallback(to: ByStr20, token_id: Uint256, token_uri: String)
  (* proxy callback to the recipient, who is always the minter *)
  msg_to_sender = {
    _tag : "ZRC6_MintCallback"; _recipient : to; _amount : zero;
    to : to; token_id : token_id; token_uri : token_uri
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

transition BurnCallBack(initiator: ByStr20, burn_address: ByStr20, token_id: Uint256)
  (* proxy callback to the sender, who is always the burner *)
  msg_to_sender = {
    _tag : "BurnCallBack"; _recipient : initiator; _amount : zero;
    initiator : initiator; burn_address : burn_address; token_id : token_id
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

