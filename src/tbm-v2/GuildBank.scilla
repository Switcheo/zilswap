scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import ListUtils BoolUtils
library GuildBank

let true = True
let false = False
let zero = Uint128 0
let uint32_zero = Uint32 0
let one = Uint128 1
let none = None {ByStr20}
let zero_address = 0x0000000000000000000000000000000000000000

(* sets to contract substate bank_version *)
let guild_bank_version = Uint32 1

let max_officer_count = Uint32 2
let max_member_count = Uint32 30

type ControlMode =
  | CaptainOnly
  | CaptainAndOneOfficer
  | CaptainAndTwoOfficers

type GuildBankSettings =
  | GuildBankSettings of Uint128 Uint128 ControlMode (* joining fee, weekly tax, multisig control mode *)

type TxParams =
  | UpdateConfigTxParams of GuildBankSettings
  | WithdrawTxParams of (* recipient, token, amount *)
    ByStr20
    ByStr20 with contract 
      field balances : Map ByStr20 Uint128,
      field allowances : Map ByStr20 (Map ByStr20 Uint128)
    end
    Uint128
  | DepositHiveTxParams of Uint128 Uint128 Uint32 (* min contribution, max token amount, deadline blocks offset *)

type BankTx =
  | BankTx of String ByStr20 TxParams (* message, initiator, params *)

type TaxParam =
  | TaxParam of ByStr20 Uint32 (* payer, epoch number *)

type PendingTx =
  | PendingTx of BankTx (List ByStr20) (* tx, approvals *)

type MigrateParam = 
  | MigrateParam of (ByStr20 with contract field balances: Map ByStr20 Uint128 end) ByStr20 (* token contract, recipient *)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotSelf
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodePendingTxDoesNotExist
  | CodePendingTxExists
  | CodeInvalidTxInsufficientBalance
  | CodeAmountRecievedMismatch
  | CodeInvalidTokenContract
  | CodeNoTokenBalance
  | CodeAlreadyTaxed
  | CodeIsAlreadyMember
  | CodeNotMember
  | CodeIsAlreadyOfficer
  | CodeNotOfficer
  | CodeOfficerLimitReached

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                        => Int32 -1
      | CodeNotSelf                         => Int32 -2
      | CodeNotPendingOwner                 => Int32 -3
      | CodePendingOwnerNotEmpty            => Int32 -4
      | CodePendingTxDoesNotExist           => Int32 -5
      | CodePendingTxExists                 => Int32 -6
      (* CodeInvalidTxInsufficientBalance is also thrown when withdraw tx token address *)
      (* is not a valid ZRC2 token contract address *)
      | CodeInvalidTxInsufficientBalance    => Int32 -7
      | CodeAmountRecievedMismatch          => Int32 -8
      | CodeInvalidTokenContract            => Int32 -9
      | CodeNoTokenBalance                  => Int32 -10
      | CodeAlreadyTaxed                    => Int32 -11
      | CodeIsAlreadyMember                 => Int32 -12
      | CodeNotMember                       => Int32 -13
      | CodeIsAlreadyOfficer                => Int32 -14
      | CodeNotOfficer                      => Int32 -15
      | CodeOfficerLimitReached             => Int32 -16
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end

let get_control_mode =
  fun (power : Uint32) =>
    let five = Uint32 5 in
    let two_officers = builtin eq power five in
    match two_officers with
    | True => CaptainAndTwoOfficers
    | False =>
      let four = Uint32 4 in
      let one_officer = builtin eq power four in
      match one_officer with
      | True => CaptainAndOneOfficer
      | False => CaptainOnly
      end
    end

let get_required_power =
  fun (mode : ControlMode) =>
      match mode with
      | CaptainOnly             => Uint32 3
      | CaptainAndOneOfficer    => Uint32 4
      | CaptainAndTwoOfficers   => Uint32 5
      end

let get_power = 
  fun (officers : Map ByStr20 Bool) =>
  fun (captain : ByStr20) =>
  fun (member : ByStr20) =>
    let maybe_officer = builtin get officers member in
    match maybe_officer with
    | Some _ => Uint32 1 (* officer has 1 power *)
    | None =>
      let maybe_captain = builtin eq captain member in
      match maybe_captain with
      | True => Uint32 3 (* captain has 3 power *)
      | False => Uint32 0 (* member not privileged *)
      end
    end

let get_current_power =
  fun (signers : List ByStr20) =>
  fun (officers : Map ByStr20 Bool) =>
  fun (captain : ByStr20) =>
    let fold = @list_foldl ByStr20 Uint32 in
    let fn = 
      fun (power: Uint32) => 
      fun (signer: ByStr20) =>
        let signer_power = get_power officers captain signer in
        builtin add signer_power power
    in
    let uint32_zero = Uint32 0 in
    fold fn uint32_zero signers

let get_first_addr = 
  fun (addr_list : List ByStr20) =>
    let fn = @list_head ByStr20 in
    fn addr_list

let get_addr =
  fun (addr_list : List ByStr20) =>
  fun (target : ByStr20) =>
    let find = @list_find ByStr20 in
    let fn = fun (addr: ByStr20) => builtin eq target addr in
    find fn addr_list

let get_list_length = 
  fun (list : List ByStr20) =>
    let fn = @list_length ByStr20 in fn list
  
let create_pending_tx = 
  fun (tx : BankTx) => 
    let empty_list = Nil {ByStr20} in
    PendingTx tx empty_list

let insert_tx_signer = 
  fun (tx : PendingTx) => 
  fun (signer : ByStr20) =>
    match tx with
    | PendingTx bank_tx signers => 
      let new_signers = Cons {ByStr20} signer signers in
      PendingTx bank_tx new_signers
    end

let list_append_recipient =
  fun (token_list : List (ByStr20 with contract field balances: Map ByStr20 Uint128 end)) => 
  fun (recipient : ByStr20) =>
  let fold = @list_foldl (ByStr20 with contract field balances: Map ByStr20 Uint128 end) (List MigrateParam) in
    let fn = 
      fun (result_list: List MigrateParam) => 
      fun (token: (ByStr20 with contract field balances: Map ByStr20 Uint128 end)) =>
        let new_item = MigrateParam token recipient in
        Cons {MigrateParam} new_item result_list
    in
    let empty_list = Nil {MigrateParam} in
    fold fn empty_list token_list

let map_to_list =
  fun (tokens_held : Map ByStr20 Bool) => 
    let fold = @list_foldl (Pair ByStr20 Bool) (List ByStr20) in
    let fn = 
      fun (result_list: List ByStr20) => 
      fun (token_pair: Pair ByStr20 Bool) =>
        match token_pair with
          | Pair token _ =>
            Cons {ByStr20} token result_list
        end
    in
    let token_list = builtin to_list tokens_held in
    let empty_list = Nil {ByStr20} in
    fold fn empty_list token_list

let list_to_map =
  fun (list : List ByStr20) => 
    let fold = @list_foldl (ByStr20) (Map ByStr20 Bool) in
    let fn = 
      fun (result_map: Map ByStr20 Bool) => 
      fun (item: ByStr20) =>
        builtin put result_map item true
    in
    let empty_map = Emp ByStr20 Bool in
    fold fn empty_map list

(* returns True if all items in the list is True *)
let all_true =
  fun (list : List Bool) =>
    let identity = fun (a: Bool) => a in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool identity list

let is_list_subset =
  fun (set : List ByStr20) =>
  fun (candidate : List ByStr20) =>
    let fold = @list_foldl ByStr20 (List Bool) in
    let check_exists = @list_exists ByStr20 in
    let fn = 
      fun (result_list: List Bool) => 
      fun (item: ByStr20) =>
        let exist_fn = fun (set_item: ByStr20) => builtin eq set_item item in
        let is_element = check_exists exist_fn set in
        Cons {Bool} is_element result_list
    in
    let empty_list = Nil {Bool} in
    let result = fold fn empty_list candidate in
    all_true result


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract GuildBank(
  initial_owner: ByStr20,
  bank_authority: ByStr20 with contract
    field current_epoch : Uint32,
    field hive : ByStr20,
    field huny : ByStr20 with contract
      field balances : Map ByStr20 Uint128
    end
  end,
  initial_joining_fee: Uint128,
  initial_weekly_tax: Uint128,
  initial_control_mode_power: Uint32,
  initial_members: List ByStr20,
  initial_officers: List ByStr20
)
with
  let officer_count = get_list_length initial_officers in
  let officer_overlimit = builtin lt max_officer_count officer_count in
  let officer_limit_ok = negb officer_overlimit in
  
  let member_count = get_list_length initial_members in
  let member_overlimit = builtin lt max_member_count member_count in
  let member_limit_ok = negb member_overlimit in
  
  let officer_list_ok = is_list_subset initial_officers initial_members in

  let l0 = Nil {Bool} in
  let l1 = Cons {Bool} officer_limit_ok l0 in
  let l2 = Cons {Bool} member_limit_ok l1 in
  let l3 = Cons {Bool} officer_list_ok l2 in
  all_true l3
=>

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

field bank_version : Uint32 = guild_bank_version

field control_mode : ControlMode = get_control_mode initial_control_mode_power
field pending_tx : Option PendingTx = None {PendingTx}

field joining_fee : Uint128 = initial_joining_fee
field weekly_tax : Uint128 = initial_weekly_tax

field members : Map ByStr20 Bool = list_to_map initial_members
field officers : Map ByStr20 Bool = list_to_map initial_officers

(* stores a map of joining fee paid per user *)
field joining_fee_paid : Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* stores a map of token addresses that bank has balance of, used for migrate *)
field tokens_held : Map ByStr20 Bool = Emp ByStr20 Bool

(* stores a map of tax collected per user by epoch *)
field tax_collected : Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsSelf(address: ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure IsValidBankTx(bank_tx: BankTx)
  match bank_tx with
  | BankTx message initiator params =>
    match params with
    | UpdateConfigTxParams new_settings =>

    | WithdrawTxParams recipient token amount =>
      maybe_token_balance <- & token.balances[_this_address];
      match maybe_token_balance with
      | Some token_balance =>
        maybe_insufficient_balance = builtin lt token_balance amount;
        match maybe_insufficient_balance with
        | False => (* no-op - balance is sufficient *)
        | True =>
          err = CodeInvalidTxInsufficientBalance;
          ThrowError err
        end
      | None =>
        err = CodeInvalidTxInsufficientBalance;
        ThrowError err
      end

    | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset =>
    end
  end
end

procedure IsNotPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    err = CodePendingTxExists;
    ThrowError err
  | None =>
  end
end

procedure IsTaxable(member: ByStr20, epoch_number: Uint32)
  maybe_taxed <- tax_collected[epoch_number][member];
  match maybe_taxed with
  | None =>
  | Some tax_amount =>
    err = CodeAlreadyTaxed;
    ThrowError err
  end
end

(* Validates BankTx params of the current PendingTx *)
(* throws if there is no PendingTx *)
(* throws conditions of PendingTx is not met  *)
procedure IsValidPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    match current_pending_tx with
    | PendingTx bank_tx signers => IsValidBankTx bank_tx
    end
  | None =>
    err = CodePendingTxDoesNotExist;
    ThrowError err
  end
end

procedure IsNotMember(user: ByStr20)
  maybe_member <- members[user];
  match maybe_member with
  | Some member =>
    err = CodeIsAlreadyMember;
    ThrowError err
  | None =>
  end
end

procedure IsMember(user: ByStr20)
  maybe_member <- members[user];
  match maybe_member with
  | Some member =>
  | None =>
    err = CodeNotMember;
    ThrowError err
  end
end

procedure IsNotOfficer(user: ByStr20)
  maybe_officer <- officers[user];
  match maybe_officer with
  | Some officer =>
    err = CodeIsAlreadyOfficer;
    ThrowError err
  | None =>
  end
end

procedure IsOfficer(user: ByStr20)
  maybe_officer <- officers[user];
  match maybe_officer with
  | Some officer =>
  | None =>
    err = CodeNotOfficer;
    ThrowError err
  end
end

procedure ReceiveZil(amount: Uint128)
  maybe_match_amount = builtin eq amount _amount;
  match maybe_match_amount with
  | True =>
    accept
  | False =>
    err = CodeAmountRecievedMismatch;
    ThrowError err
  end
end

procedure SendZil(recipient: ByStr20, amount: Uint128)
  msg = { _tag : "AddFunds"; _recipient: recipient; _amount: amount };
  msgs = one_msg msg;
  send msgs
end

procedure SendUpdateTokenBalance(token: ByStr20)
  msg_to_self = {
    _tag: "UpdateTokenBalance";
    _recipient: _this_address;
    _amount: zero;
    token: token
  };
  msgs = one_msg msg_to_self;
  send msgs
end

procedure ReceiveToken(from: ByStr20, token: ByStr20, amount: Uint128)
  msg_to_token = {
    _tag: "TransferFrom";
    _recipient: token;
    _amount: zero;
    from: from;
    to: _this_address;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs;

  SendUpdateTokenBalance token
end

procedure SendToken(recipient: ByStr20, token: ByStr20, amount: Uint128)
  msg_to_token = {
    _tag: "Transfer";
    _recipient: token;
    _amount: zero;
    to: recipient;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs;

  SendUpdateTokenBalance token
end

(* multi-sig authenticated operation *)
procedure UpdateGuildSettings(settings: GuildBankSettings)
  match settings with
  | GuildBankSettings new_joining_fee new_weekly_tax new_control_mode =>
    joining_fee := new_joining_fee;
    weekly_tax := new_weekly_tax;
    control_mode := new_control_mode;

    e = {_eventname: "BankSettingsUpdated"; settings: settings };
    event e
  end
end

(* multi-sig authenticated operation *)
procedure Withdraw(recipient: ByStr20, token: ByStr20, amount: Uint128)
  SendToken recipient token amount;

  e = {_eventname: "WithdrawComplete" };
  event e
end

(* multi-sig authenticated operation *)
procedure DepositHive(min_contribution: Uint128, max_token_amount: Uint128, deadline_block_offset: Uint32)
  current_block_number <- & BLOCKNUMBER;
  deadline_block = builtin badd current_block_number deadline_block_offset;
  hive_address <- & bank_authority.hive;
  msg_to_hive = {
    _tag: "AddLiquidity";
    _recipient: hive_address;
    _amount: zero;
    min_contribution_amount: min_contribution;
    max_token_amount: max_token_amount;
    deadline_block: deadline_block
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "HiveDepositComplete" };
  event e
end


procedure ExecuteBankTx(bank_tx: BankTx)
  match bank_tx with
  | BankTx message initiator tx_params => 
    match tx_params with
    | UpdateConfigTxParams new_settings => UpdateGuildSettings new_settings
    | WithdrawTxParams recipient token amount => Withdraw recipient token amount
    | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset => 
      DepositHive min_contribution max_token_amount deadline_block_offset
    end
  end
end

procedure CheckConcludePendingTx(current_pending_tx: PendingTx)
  current_control_mode <- control_mode;
  required_power = get_required_power current_control_mode;
  match current_pending_tx with
  | PendingTx bank_tx signers =>
    maybe_owner <- contract_owner;
    match maybe_owner with
    | Some current_captain =>
      current_officers <- officers;
      current_power = get_current_power signers current_officers current_captain;
      maybe_insufficient_power = builtin lt current_power required_power;
      match maybe_insufficient_power with
      | True => (* insufficient power to execute *)
      | False => 
        ExecuteBankTx bank_tx;

        none_pending_tx = None {PendingTx};
        pending_tx := none_pending_tx;

        e = {_eventname: "TxExecuted"; pending_tx: current_pending_tx };
        event e
      end
    | None => (* impossible *)
    end
   end
end

procedure SignPendingTx(signer: ByStr20)
  IsValidPendingTx;

  maybe_tx <- pending_tx;
  match maybe_tx with
  | Some tx =>
    new_pending_tx = insert_tx_signer tx signer;
    p = Some {PendingTx} new_pending_tx;
    pending_tx := p;
    
    e = {_eventname: "TxSigned"; signer: _sender; pending_tx: new_pending_tx };
    event e;
    
    CheckConcludePendingTx new_pending_tx
  | None => (* not possible *)
   end
end

(* reset signature progress on guild multisig transaction *)
(* effected when any of guild officers or captain is changed *)
procedure ResetPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    match current_pending_tx with
    | PendingTx bank_tx signers =>
      empty_signers = Nil {ByStr20};
      new_pending_tx = PendingTx bank_tx empty_signers;
      p = Some {PendingTx} new_pending_tx;
      pending_tx := p;
      e = {_eventname: "TxSigningReset"; pending_tx: new_pending_tx };
      event e
    end
  | None => (* no-op *)
  end
end


procedure ReceiveTax(param: TaxParam)
  tax_amount <- weekly_tax;
  match param with
  | TaxParam member epoch_number =>
    IsTaxable member epoch_number;
    huny_token <- & bank_authority.huny;
    ReceiveToken member huny_token tax_amount;

    tax_collected[epoch_number][member] := tax_amount;

    e = {_eventname: "TaxCollected"; payer: member; tax_amount: tax_amount; epoch_number: epoch_number };
    event e
  end
end

procedure MigrateToken(param: MigrateParam)
  match param with
  | MigrateParam token recipient =>
    maybe_token_balance <- & token.balances[_this_address];
    match maybe_token_balance with
    | Some token_balance =>
      SendToken recipient token token_balance
    | None => (* no-op - should not happen *)
    end
  end
end


(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Initiate a generic multisig transaction (depends on configuration *)
(* could resolve immediately if in single-signature mode) *)
transition InitiateTx(tx_params: TxParams, message: String)
  IsNotPendingTx;

  bank_tx = BankTx message _sender tx_params; 
  IsValidBankTx bank_tx;

  new_pending_tx = create_pending_tx bank_tx;
  p = Some {PendingTx} new_pending_tx;
  pending_tx := p;

  e = {_eventname: "TxInitiated"; initiator: _sender; pending_tx: new_pending_tx };
  event e;

  SignPendingTx _sender
end

(* @dev: Cancels a pending multisig transaction. *)
transition CancelTx()
  IsOwner _sender;

  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some cancelled_pending_tx =>
    no_pending_tx = None {PendingTx};
    pending_tx := no_pending_tx;

    e = {_eventname: "TxCancelled"; initiator: _sender; pending_tx: cancelled_pending_tx };
    event e
  | None =>
    err = CodePendingTxDoesNotExist;
    ThrowError err
  end
  
end

(* @dev: Sign a multisig transaction, resolves and executes if number of *)
(* required signing parties is met. *)
transition SignTx()
  SignPendingTx _sender
end

transition PromoteMember(member: ByStr20)
  IsNotOfficer member;
  IsMember member;

  current_officers <- officers;
  officer_list = map_to_list current_officers;
  officer_count = get_list_length officer_list;

  has_officer_capacity = builtin lt officer_count max_officer_count;
  match has_officer_capacity with
  | True =>
    officers[member] := true;

    e = {_eventname: "MemberPromoted"; member: _sender};
    event e;

    ResetPendingTx
  | False =>
    err = CodeOfficerLimitReached;
    ThrowError err
  end
end

transition DemoteMember(member: ByStr20)
  IsOfficer member;

  delete officers[member];

  e = {_eventname: "MemberDemoted"; member: _sender};
  event e;

  ResetPendingTx
end

(* @dev: Charge joining fee to user, called once by user joining a guild *)
transition JoinAndPayJoiningFee()
  IsNotMember _sender;

  (* add member to members *)
  members[_sender] := true;

  (* announce new membership *)
  e = {_eventname: "MemberJoined"; member: _sender};
  event e;

  (* check if joining fee paid *)
  maybe_paid_joining_fee <- joining_fee_paid[_sender];
  match maybe_paid_joining_fee with
  | Some _ => (* no-op - fee already paid previously *)
  | None =>

    (* check if joining fee is zero *)
    current_joining_fee <- joining_fee;
    has_joining_fee = builtin lt zero current_joining_fee;
    match has_joining_fee with
    | False => (* no-op - joining fee â‰¤ zero *)
    | True =>
      joining_fee_paid[_sender] := current_joining_fee;
    
      huny_token <- & bank_authority.huny;
      e = {_eventname: "PaidJoiningFee"; member: _sender; token: huny_token; amount: current_joining_fee};
      event e;

      ReceiveToken _sender huny_token current_joining_fee
    end
   end
end

(* @dev: Transfers specified amount of tokens to guild bank *)
transition MakeDonation(token: ByStr20, amount: Uint128)
  is_token_zil = builtin eq zero_address token;
  match is_token_zil with
  | True =>
    ReceiveZil amount
  | False =>
    ReceiveToken _sender token amount
  end;

  e = {_eventname: "DonationReceived"; initiator: _sender; token: token; amount: amount };
  event e
end

(* @dev: Transfers tax from specified guild members to guild bank *)
transition CollectTax(params: List TaxParam)
  forall params ReceiveTax
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
transition Migrate(recipient: ByStr20)
  IsOwner _sender;

  zil_balance <- _balance;
  has_no_zil_balance = builtin eq zil_balance zero;
  match has_no_zil_balance with
  | True =>
  | False =>
    SendZil recipient zil_balance
  end;

  current_tokens_held <- tokens_held;
  token_list = map_to_list current_tokens_held;

  some_token_item = get_first_addr token_list;
  match some_token_item with
  | None => (* no-op *)
  | Some _ =>
    msg_to_self = {
      _tag: "MigrateTokens";
      _recipient: _this_address;
      _amount: zero;
      recipient: recipient;
      token_list: token_list
    };
    msgs = one_msg msg_to_self;
    send msgs
  end
end

(* @dev: Migrate token balance to specified contract *)
(* @dev: Only called by self, address cast workaround *)
transition MigrateTokens(
  recipient: ByStr20,
  token_list: List (ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end)
)
  IsSelf _sender;

  token_and_recipient_list = list_append_recipient token_list recipient;
  forall token_and_recipient_list MigrateToken
end

(* @dev: Update tokens_held map *)
(* @dev: Only called by self, address cast workaround *)
transition UpdateTokenBalance(
  token: ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end
)
  IsSelf _sender;

  maybe_token_balance <- & token.balances[_this_address];
  match maybe_token_balance with
  | Some token_balance =>
    is_zero_balance = builtin eq token_balance zero;
    match is_zero_balance with
    | True => delete tokens_held[token]
    | False => tokens_held[token] := true
    end
  | None => delete tokens_held[token]
  end
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
(* works on v8.1.0 (testnet, mainnet) but not v8.0.4 (ceres local) *)
(* transition Migrate(recipient: ByStr20)
  IsOwner _sender;

  zil_balance <- _balance;
  has_no_zil_balance = builtin eq zil_balance zero;
  match has_no_zil_balance with
  | True =>
  | False =>
    SendZil recipient zil_balance
  end;


  current_tokens_held <- tokens_held;
  token_list = map_to_list current_tokens_held;

  some_token_item = get_first_addr token_list;
  match some_token_item with
  | None =>
  | Some _ =>
    token_and_recipient_list = list_append_recipient token_list recipient;
    forall token_and_recipient_list MigrateToken

    // MigrateToken
    maybe_token_contract <- & token as ByStr20 with contract
      field balances: Map ByStr20 Uint128
    end;
    match maybe_token_contract with
    | Some token_contract =>
      maybe_token_balance <- & token_contract.balances[_this_address];
      match maybe_token_balance with
      | Some token_balance =>
        SendToken recipient token token_balance
      | None =>
      end
    | None =>
    end
  end
end *)

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e;

  ResetPendingTx
end

(***************************************)
(*             Callbacks               *)
(***************************************)

(* receive fee/tax *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op *)
end
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow sending tokens to bank *)
end
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow withdraw multisign tx *)
end
