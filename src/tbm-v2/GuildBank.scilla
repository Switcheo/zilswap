scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import ListUtils
library GuildBank

let true = True
let false = False
let zero = Uint128 0
let one = Uint128 1
let none = None {ByStr20}
let empty = ""
let scale_denom = Uint128 10000 (* 1 bps *)
let zil_address = 0x0000000000000000000000000000000000000000

type ControlMode =
  | CaptainOnly
  | CaptainAndOneOfficer
  | CaptainAndTwoOfficers

type GuildBankSettings =
  | GuildBankSettings of Uint128 Uint128 ControlMode (* joining fee, weekly tax, multisig control mode *)

type TxParams =
  | UpdateConfigTxParams of GuildBankSettings
  | WithdrawTxParams of (* recipient, token, amount *)
    ByStr20
    ByStr20 with contract 
      field balances : Map ByStr20 Uint128,
      field allowances : Map ByStr20 (Map ByStr20 Uint128)
    end
    Uint128
  | DepositHiveTxParams of Uint128 Uint128 Uint128 (* min contribution, max token amount, deadline blocks offset *)

type BankTx =
  | BankTx of String ByStr20 TxParams (* message, initiator, params *)

type TaxParam =
  | TaxParam of ByStr20 Uint32 (* payer, epoch number *)

type PendingTx =
  | PendingTx of BankTx (List ByStr20) (* tx, approvals *)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodePendingTxDoesNotExist
  | CodePendingTxExists
  | CodeInvalidTxInsufficientBalance
  | CodeAmountRecievedMismatch
  | CodeNoTokenBalance

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                        => Int32 -1
      | CodeNotPendingOwner                 => Int32 -2
      | CodePendingOwnerNotEmpty            => Int32 -3
      | CodePendingTxDoesNotExist           => Int32 -4
      | CodePendingTxExists                 => Int32 -5
      (* CodeInvalidTxInsufficientBalance is also thrown when withdraw tx token address *)
      (* is not a valid ZRC2 token contract address *)
      | CodeInvalidTxInsufficientBalance    => Int32 -6
      | CodeAmountRecievedMismatch          => Int32 -7
      | CodeNoTokenBalance                  => Int32 -8
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end

let get_min =
  fun (a : Uint128) =>
  fun (b : Uint128) =>
    let a_is_min = builtin lt a b in
    match a_is_min with
    | True => a
    | False => b
    end

let get_max =
  fun (a : Uint128) =>
  fun (b : Uint128) =>
    let a_is_max = builtin lt b a in
    match a_is_max with
    | True => a
    | False => b
    end

let get_control_mode =
  fun (power : Uint32) =>
    let five = Uint32 5 in
    let two_officers = builtin eq power five in
    match two_officers with
    | True => CaptainAndTwoOfficers
    | False =>
      let four = Uint32 4 in
      let one_officer = builtin eq power four in
      match one_officer with
      | True => CaptainAndOneOfficer
      | False => CaptainOnly
      end
    end

let get_required_power =
  fun (mode : ControlMode) =>
      match mode with
      | CaptainOnly             => Uint32 3
      | CaptainAndOneOfficer    => Uint32 4
      | CaptainAndTwoOfficers   => Uint32 5
      end

let get_power = 
  fun (officers : List ByStr20) =>
  fun (captain : ByStr20) =>
  fun (member : ByStr20) =>
    let officer_find = @list_find (ByStr20) in
    let fn = fun (officer: ByStr20) => builtin eq officer member in
    let maybe_officer = officer_find fn officers in
    match maybe_officer with
      | Some address => Uint32 1 (* officer has 1 power *)
      | None =>
        let maybe_captain = builtin eq captain member in
        match maybe_captain with
          | True => Uint32 3 (* captain has 3 power *)
          | False => Uint32 0 (* member not privileged *)
        end
     end

let get_current_power =
  fun (signers : List ByStr20) =>
  fun (officers : List ByStr20) =>
  fun (captain : ByStr20) =>
    let fold = @list_foldl_while ByStr20 Uint32 in
    let fn = 
      fun (power: Uint32) => 
      fun (signer: ByStr20) =>
        let signer_power = get_power officers captain signer in
        let new_power = builtin add signer_power power in
        Some {Uint32} new_power
    in
    let uint32_zero = Uint32 0 in
    fold fn uint32_zero signers

let create_pending_tx = 
  fun (tx : BankTx) => 
    let empty_list = Nil {ByStr20} in
    PendingTx tx empty_list

let add_tx_signer = 
  fun (tx : PendingTx) => 
  fun (signer : ByStr20) =>
    match tx with
    | PendingTx bank_tx signers => 
      let new_signers = Cons {ByStr20} signer signers in
      PendingTx bank_tx new_signers
    end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract GuildBank(
  initial_owner: ByStr20,
  initial_hive: ByStr20,
  huny_token: ByStr20 with contract
    field balances : Map ByStr20 Uint128
  end,
  initial_joining_fee: Uint128,
  initial_weekly_tax: Uint128,
  initial_control_mode_power: Uint32,
  initial_officers: List ByStr20
)

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

field hive : ByStr20 = initial_hive

field control_mode : ControlMode = get_control_mode initial_control_mode_power
field pending_tx : Option PendingTx = None {PendingTx}

field joining_fee : Uint128 = initial_joining_fee
field weekly_tax : Uint128 = initial_weekly_tax

field members : List ByStr20 = Nil {ByStr20}
field officers : List ByStr20 = initial_officers

field token_balances : List ByStr20 = Nil {ByStr20}

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsValidBankTx(bank_tx: BankTx)
  match bank_tx with
    | BankTx message initiator params =>
      match params with
        | UpdateConfigTxParams new_settings =>

        | WithdrawTxParams recipient token amount =>
          maybe_token_balance <- & token.balances[_this_address];
          match maybe_token_balance with
            | Some token_balance =>
              maybe_insufficient_balance = builtin lt token_balance amount;
              match maybe_insufficient_balance with
                | False => (* no-op - balance is sufficient *)
                | True =>
                  err = CodeInvalidTxInsufficientBalance;
                  ThrowError err
              end
            | None =>
              err = CodeInvalidTxInsufficientBalance;
              ThrowError err
          end

        | DepositHiveTxParams min_contribution max_token_amount deadline_block =>
      end
  end
end

procedure IsNotPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
    | Some current_pending_tx =>
      err = CodePendingTxExists;
      ThrowError err
    | None =>
  end
end

(* Validates BankTx params of the current PendingTx *)
(* throws if there is no PendingTx *)
(* throws conditions of PendingTx is not met  *)
procedure IsValidPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
    | Some current_pending_tx =>
      match current_pending_tx with
        | PendingTx bank_tx signers => IsValidBankTx bank_tx
      end
    | None =>
      err = CodePendingTxDoesNotExist;
      ThrowError err
  end
end

procedure ReceiveZil(amount: Uint128)
  maybe_match_amount = builtin eq amount _amount;
  match maybe_match_amount with
    | True =>
      accept
    | False =>
      err = CodeAmountRecievedMismatch;
      ThrowError err
  end
end

procedure SendZil(recipient: ByStr20, amount: Uint128)
  msg = { _tag : "AddFunds"; _recipient: recipient; _amount: amount };
  msgs = one_msg msg;
  send msgs
end

procedure ReceiveToken(from: ByStr20, token: ByStr20, amount: Uint128)
  msg_to_token = {
    _tag: "TransferFrom";
    _recipient: token;
    _amount: zero;
    from: from;
    to: _this_address;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs
end

procedure SendToken(recipient: ByStr20, token: ByStr20, amount: Uint128)
  msg_to_token = {
    _tag: "Transfer";
    _recipient: token;
    _amount: zero;
    to: recipient;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs
end

(* multi-sig authenticated operation *)
procedure UpdateGuildSettings(settings: GuildBankSettings)
  match settings with
    | GuildBankSettings new_joining_fee new_weekly_tax new_control_mode =>
      joining_fee := new_joining_fee;
      weekly_tax := new_weekly_tax;
      control_mode := new_control_mode;

      e = {_eventname: "BankSettingsUpdated"; settings: settings };
      event e
  end
end

(* multi-sig authenticated operation *)
procedure Withdraw(recipient: ByStr20, token: ByStr20, amount: Uint128)
  SendToken recipient token amount;

  e = {_eventname: "WithdrawComplete" };
  event e
end

(* multi-sig authenticated operation *)
procedure DepositHive()
  (* msg_to_token = {
    _tag: "AddLiquidity";
    _recipient: hive;
    _amount: zero;
    min_contribution_amount,
    max_token_amount,
    deadline_block,
  };
  msgs = one_msg msg_to_token;
  send msgs; *)

  e = {_eventname: "HiveDepositComplete" };
  event e
end


procedure ExecuteBankTx(bank_tx: BankTx)
  match bank_tx with
    | BankTx message initiator tx_params => 
      match tx_params with
        | UpdateConfigTxParams new_settings => UpdateGuildSettings new_settings
        | WithdrawTxParams recipient token amount => Withdraw recipient token amount
        | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset => DepositHive
      end
   end
end

procedure CheckConcludePendingTx(current_pending_tx: PendingTx)
  current_control_mode <- control_mode;
  required_power = get_required_power current_control_mode;
  match current_pending_tx with
    | PendingTx bank_tx signers =>
      current_officers <- officers;
      maybe_owner <- contract_owner;
      match maybe_owner with
        | Some current_captain =>
          current_power = get_current_power signers current_officers current_captain;
          maybe_insufficient_power = builtin lt current_power required_power;
          match maybe_insufficient_power with
            | True => (* insufficient power to execute *)
            | False => 
              ExecuteBankTx bank_tx;

              none_pending_tx = None {PendingTx};
              pending_tx := none_pending_tx;

              e = {_eventname: "TxExecuted"; pending_tx: current_pending_tx };
              event e
          end
        | None => (* impossible *)
       end
   end
end

procedure SignPendingTx(signer: ByStr20)
  IsValidPendingTx;

  maybe_tx <- pending_tx;
  match maybe_tx with
    | Some tx =>
      new_pending_tx = add_tx_signer tx signer;
      p = Some {PendingTx} new_pending_tx;
      pending_tx := p;
      
      e = {_eventname: "TxSigned"; signer: _sender; pending_tx: new_pending_tx };
      event e;
      
      CheckConcludePendingTx new_pending_tx
    | None => (* not possible *)
   end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Initiate a generic multisig transaction (depends on configuration *)
(* could resolve immediately if in single-signature mode) *)
transition InitiateTx(tx_params: TxParams, message: String)
  IsNotPendingTx;

  bank_tx = BankTx message _sender tx_params; 
  IsValidBankTx bank_tx;

  new_pending_tx = create_pending_tx bank_tx;
  p = Some {PendingTx} new_pending_tx;
  pending_tx := p;

  e = {_eventname: "TxInitiated"; initiator: _sender; pending_tx: new_pending_tx };
  event e;

  SignPendingTx _sender
end

(* @dev: Cancels a pending multisig transaction. *)
transition CancelTx()
  IsOwner _sender;

  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
    | Some cancelled_pending_tx =>
      no_pending_tx = None {PendingTx};
      pending_tx := no_pending_tx;

      e = {_eventname: "TxCancelled"; initiator: _sender; pending_tx: cancelled_pending_tx };
      event e
    | None =>
      err = CodePendingTxDoesNotExist;
      ThrowError err
   end
  
end

(* @dev: Sign a multisig transaction, resolves and executes if number of *)
(* required signing parties is met. *)
transition SignTx()
  SignPendingTx _sender
end

(* @dev: Charge joining fee to user, called once by user joining a guild *)
transition PayJoiningFee()
  list <- members;
  new_list = Cons {ByStr20} _sender list;
  members := new_list;

  current_joining_fee <- joining_fee;
  has_joining_fee = builtin lt zero current_joining_fee;
  match has_joining_fee with
    | False =>
    | True =>
      ReceiveToken _sender huny_token current_joining_fee
  end;

  e = {_eventname: "PaidJoiningFee"; member: _sender; token: huny_token; amount: current_joining_fee};
  event e
end

(* @dev: Transfers specified amount of tokens to guild bank *)
transition MakeDonation(token: ByStr20, amount: Uint128)
  is_token_zil = builtin eq zil_address token;
  match is_token_zil with
    | True =>
      ReceiveZil amount
    | False =>
      ReceiveToken _sender token amount
  end;

  e = {_eventname: "DonationReceived"; initiator: _sender; token: token; amount: amount };
  event e
end

(* @dev: Transfers tax from specified guild members to guild bank *)
transition CollectTax(params: List TaxParam)
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
transition MigrateToken(
  token: ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end,
  recipient: ByStr20
)
  IsOwner _sender;

  maybe_token_balance <- & token.balances[_this_address];
  match maybe_token_balance with
    | Some token_balance =>
      SendToken recipient token token_balance
    | None =>
      err = CodeNoTokenBalance;
      ThrowError err
  end
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
transition MigrateZil(recipient: ByStr20)
  IsOwner _sender;
  
  amount <- _balance;
  SendZil recipient amount
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end

(***************************************)
(*             Callbacks               *)
(***************************************)

(* receive fee/tax *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op *)
end
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow sending tokens to bank *)
end
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow withdraw multisign tx *)
end
