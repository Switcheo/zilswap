scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import ListUtils BoolUtils NatUtils
library GuildBank

let true = True
let false = False
let zero = Uint128 0
let one = Uint128 1
let thousand = Uint128 1000
let uint32_zero = Uint32 0
let none = None {ByStr20}
let zero_address = 0x0000000000000000000000000000000000000000

(* sets to contract substate bank_version *)
let guild_bank_version = Uint32 1

let max_officer_count = Uint32 2
let max_member_count = Uint32 30

type ControlMode =
  | CaptainOnly
  | CaptainAndOneOfficer
  | CaptainAndTwoOfficers

(* guild management fee allocation to captains and officers *)
type FeeAllocation =
  | FeeAllocation of Uint128 Uint128 (* captain bps, officers bps *)

(* fee settings for weekly tax and joining fee *)
type Fee =
  | Fee of Uint128 Uint128 Uint32 FeeAllocation (* amount, inflation, first epoch, fee allocation *)

(* all of a guild bank's configurations *)
type GuildBankSettings =
  | GuildBankSettings of Fee Fee ControlMode (* joining fee, weekly tax, multisig control mode *)

(* parameters for multisig transactions *)
type TxParams =
  | UpdateConfigTxParams of GuildBankSettings
  | WithdrawTxParams of (* recipient, token, amount *)
    ByStr20
    ByStr20 with contract 
      field balances : Map ByStr20 Uint128
    end
    Uint128
  | DepositHiveTxParams of Uint128 Uint128 Uint32 (* min contribution, max token amount, deadline blocks offset *)
  | WithdrawHiveTxParams of Uint128 Uint128 Uint128 Uint32 (* contribution, min zil amount, min token amount, deadline blocks offset *)

(* multisig transaction with metadata *)
type BankTx =
  | BankTx of String ByStr20 TxParams (* message, initiator, params *)

(* represents an existing multisig transaction. consists of the transaction with a list of approvers *)
type PendingTx =
  | PendingTx of BankTx (List ByStr20) (* tx, approvers *)

(* used for bulk collecting weekly tax *)
type TaxParam =
  | TaxParam of ByStr20 Uint32 (* payer, epoch number *)

(* used for recording tax owed per epoch *)
type TaxOwed =
  | TaxOwed of ByStr20 Uint32 Uint128 (* payer, epoch number, amount *)

(* used for migrating funds on this contract to another guild bank contract during an upgrade *)
type MigrateParam = 
  | MigrateParam of ByStr20 ByStr20 (* token contract, recipient *)

(* send token param for bulk sending tokens *)
type SendTokenParam = 
  | SendTokenParam of ByStr20 (ByStr20 with contract field balances : Map ByStr20 Uint128 end) Uint128 (* recipient, token contract, amount *)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotSelf
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodePendingTxDoesNotExist
  | CodePendingTxExists
  | CodeInvalidTxInsufficientBalance
  | CodeAmountRecievedMismatch
  | CodeInvalidTokenContract
  | CodeNoTokenBalance
  | CodeAlreadyTaxed
  | CodeIsAlreadyMember
  | CodeNotMember
  | CodeIsAlreadyOfficer
  | CodeNotOfficer
  | CodeOfficerLimitReached
  | CodeMemberLimitReached
  | CodeInvalidMembershipState
  | CodeMemberApplicationNotFound
  | CodeCaptainCannotLeave
  | CodeNotCaptainOrOfficer
  | CodeNotBankAuthority
  | CodeInvalidTaxParam

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                        => Int32 -1
      | CodeNotSelf                         => Int32 -2
      | CodeNotPendingOwner                 => Int32 -3
      | CodePendingOwnerNotEmpty            => Int32 -4
      | CodePendingTxDoesNotExist           => Int32 -5
      | CodePendingTxExists                 => Int32 -6
      (* CodeInvalidTxInsufficientBalance is also thrown when withdraw tx token address *)
      (* is not a valid ZRC2 token contract address *)
      | CodeInvalidTxInsufficientBalance    => Int32 -7
      | CodeAmountRecievedMismatch          => Int32 -8
      | CodeInvalidTokenContract            => Int32 -9
      | CodeNoTokenBalance                  => Int32 -10
      | CodeAlreadyTaxed                    => Int32 -11
      | CodeIsAlreadyMember                 => Int32 -12
      | CodeNotMember                       => Int32 -13
      | CodeIsAlreadyOfficer                => Int32 -14
      | CodeNotOfficer                      => Int32 -15
      | CodeOfficerLimitReached             => Int32 -16
      | CodeMemberLimitReached              => Int32 -17
      | CodeInvalidMembershipState          => Int32 -18
      | CodeMemberApplicationNotFound       => Int32 -19
      | CodeCaptainCannotLeave              => Int32 -20
      | CodeNotCaptainOrOfficer             => Int32 -21
      | CodeNotBankAuthority                => Int32 -22
      | CodeInvalidTaxParam                 => Int32 -23
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end

let get_uint128list_nth = @list_nth Uint128

let get_element_amount_or_zero =
  fun (list: List Uint128) =>
  fun (n: Uint32) =>
    let maybe_value = get_uint128list_nth n list in
    match maybe_value with
    | Some amt => amt
    | None => zero
    end

let get_fee =
  fun (fee_params : List Uint128) =>
  fun (current_epoch : Uint32) =>
    let uint32_one = Uint32 1 in
    let uint32_two = Uint32 2 in
    let uint32_three = Uint32 3 in
    let fee_initial_amount = get_element_amount_or_zero fee_params uint32_zero in
    let inflation = get_element_amount_or_zero fee_params uint32_one in
    let alloc_captain = get_element_amount_or_zero fee_params uint32_two in
    let alloc_officer = get_element_amount_or_zero fee_params uint32_three in
    let allocation = FeeAllocation alloc_captain alloc_officer in
    Fee fee_initial_amount inflation current_epoch allocation

let get_fee_amount =
  fun (fee : Fee) =>
  fun (current_epoch : Uint32) =>
    match fee with
    | Fee initial_amount inflation initial_epoch allocation =>
      let epochs_diff = builtin sub current_epoch initial_epoch in
      let maybe_epochs_diff = builtin to_uint128 epochs_diff in
      match maybe_epochs_diff with
      | None =>
        zero (* should not happen *)
      | Some uint128_epochs_diff => 
        let inflation_amount = builtin mul inflation uint128_epochs_diff in
        builtin add initial_amount inflation_amount
      end
    end

let get_amount_portion = 
  fun (amount : Uint128) =>
  fun (portion_bps : Uint128) =>
    let product = builtin mul amount portion_bps in
    builtin div product thousand
  
let get_control_mode =
  fun (power : Uint32) =>
    let five = Uint32 5 in
    let two_officers = builtin eq power five in
    match two_officers with
    | True => CaptainAndTwoOfficers
    | False =>
      let four = Uint32 4 in
      let one_officer = builtin eq power four in
      match one_officer with
      | True => CaptainAndOneOfficer
      | False => CaptainOnly
      end
    end

let get_required_power =
  fun (mode : ControlMode) =>
      match mode with
      | CaptainOnly             => Uint32 3
      | CaptainAndOneOfficer    => Uint32 4
      | CaptainAndTwoOfficers   => Uint32 5
      end

let get_power = 
  fun (officers : Map ByStr20 Bool) =>
  fun (captain : ByStr20) =>
  fun (member : ByStr20) =>
    let maybe_officer = builtin get officers member in
    match maybe_officer with
    | Some _ => Uint32 1 (* officer has 1 power *)
    | None =>
      let maybe_captain = builtin eq captain member in
      match maybe_captain with
      | True => Uint32 3 (* captain has 3 power *)
      | False => Uint32 0 (* member not privileged *)
      end
    end

let get_current_power =
  fun (signers : List ByStr20) =>
  fun (officers : Map ByStr20 Bool) =>
  fun (captain : ByStr20) =>
    let fold = @list_foldl ByStr20 Uint32 in
    let fn = 
      fun (power: Uint32) => 
      fun (signer: ByStr20) =>
        let signer_power = get_power officers captain signer in
        builtin add signer_power power
    in
    let uint32_zero = Uint32 0 in
    fold fn uint32_zero signers

let get_first_addr = 
  fun (addr_list : List ByStr20) =>
    let fn = @list_head ByStr20 in
    fn addr_list

let get_addr =
  fun (addr_list : List ByStr20) =>
  fun (target : ByStr20) =>
    let find = @list_find ByStr20 in
    let fn = fun (addr: ByStr20) => builtin eq target addr in
    find fn addr_list

let get_list_length = 
  fun (list : List ByStr20) =>
    let fn = @list_length ByStr20 in fn list
  
let create_pending_tx = 
  fun (tx : BankTx) => 
    let empty_list = Nil {ByStr20} in
    PendingTx tx empty_list

let insert_tx_signer = 
  fun (tx : PendingTx) => 
  fun (signer : ByStr20) =>
    match tx with
    | PendingTx bank_tx signers => 
      let new_signers = Cons {ByStr20} signer signers in
      PendingTx bank_tx new_signers
    end

let list_append_recipient =
  fun (token_list : List (ByStr20)) => 
  fun (recipient : ByStr20) =>
  let fold = @list_foldl (ByStr20) (List MigrateParam) in
    let fn = 
      fun (result_list: List MigrateParam) => 
      fun (token: (ByStr20)) =>
        let new_item = MigrateParam token recipient in
        Cons {MigrateParam} new_item result_list
    in
    let empty_list = Nil {MigrateParam} in
    fold fn empty_list token_list

let map_to_list =
  fun (tokens_held : Map ByStr20 Bool) => 
    let fold = @list_foldl (Pair ByStr20 Bool) (List ByStr20) in
    let fn = 
      fun (result_list: List ByStr20) => 
      fun (token_pair: Pair ByStr20 Bool) =>
        match token_pair with
          | Pair token _ =>
            Cons {ByStr20} token result_list
        end
    in
    let token_list = builtin to_list tokens_held in
    let empty_list = Nil {ByStr20} in
    fold fn empty_list token_list

let list_to_map =
  fun (list : List ByStr20) => 
    let fold = @list_foldl (ByStr20) (Map ByStr20 Bool) in
    let fn = 
      fun (result_map: Map ByStr20 Bool) => 
      fun (item: ByStr20) =>
        builtin put result_map item true
    in
    let empty_map = Emp ByStr20 Bool in
    fold fn empty_map list

(* returns True if all items in the list is True *)
let all_true =
  fun (list : List Bool) =>
    let identity = fun (a: Bool) => a in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool identity list

let is_list_subset =
  fun (set : List ByStr20) =>
  fun (candidate : List ByStr20) =>
    let fold = @list_foldl ByStr20 (List Bool) in
    let check_exists = @list_exists ByStr20 in
    let fn = 
      fun (result_list: List Bool) => 
      fun (item: ByStr20) =>
        let exist_fn = fun (set_item: ByStr20) => builtin eq set_item item in
        let is_element = check_exists exist_fn set in
        Cons {Bool} is_element result_list
    in
    let empty_list = Nil {Bool} in
    let result = fold fn empty_list candidate in
    all_true result
    
(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract GuildBank(
  initial_owner: ByStr20,
  bank_authority: ByStr20 with contract
    field current_epoch : Uint32,
    field hive : ByStr20,
    field huny : ByStr20 with contract
      field balances : Map ByStr20 Uint128
    end
  end,
  initial_epoch: Uint32,
  initial_joining_fee: List Uint128,
  initial_weekly_tax: List Uint128,
  initial_control_mode_power: Uint32,
  initial_members: List ByStr20,
  initial_officers: List ByStr20
)
with
  let officer_count = get_list_length initial_officers in
  let officer_overlimit = builtin lt max_officer_count officer_count in
  let officer_limit_ok = negb officer_overlimit in

  let member_count = get_list_length initial_members in
  let member_overlimit = builtin lt max_member_count member_count in
  let member_limit_ok = negb member_overlimit in
  
  let officer_list_ok = is_list_subset initial_officers initial_members in

  let l0 = Nil {Bool} in
  let l1 = Cons {Bool} officer_limit_ok l0 in
  let l2 = Cons {Bool} member_limit_ok l1 in
  let l3 = Cons {Bool} officer_list_ok l2 in
  all_true l3
=>

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

field bank_version : Uint32 = guild_bank_version

field control_mode : ControlMode = get_control_mode initial_control_mode_power
field pending_tx : Option PendingTx = None {PendingTx}

field joining_fee : Fee = get_fee initial_joining_fee initial_epoch
field weekly_tax : Fee = get_fee initial_weekly_tax initial_epoch

field last_updated_epoch : Uint32 = initial_epoch
field current_joining_fee : Uint128 = 
  let f = get_fee initial_joining_fee initial_epoch in
  get_fee_amount f initial_epoch

field members : Map ByStr20 Bool = list_to_map initial_members
field officers : Map ByStr20 Bool = list_to_map initial_officers

(* map of users requesting to join guild, can be approved by guild managers to complete join flow *)
field joining_requests : Map ByStr20 Bool = Emp ByStr20 Bool

(* map of joining fee paid per user *)
field joining_fee_paid : Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* map of token addresses that bank has balance of, used for migrate *)
field tokens_held : Map ByStr20 Bool = Emp ByStr20 Bool

(* map of tax collected per user by epoch *)
field tax_collected : Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128)

(* map of tax owed per user by epoch *)
field tax_owed : Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsNotOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
      err = CodeCaptainCannotLeave;
      ThrowError err
    | False => (* no-op *)
    end
  | None => (* no-op *)
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsSelf(address: ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure IsValidBankTx(bank_tx: BankTx)
  match bank_tx with
  | BankTx message initiator params =>
    match params with
    | UpdateConfigTxParams new_settings =>
      (* TODO: validate config params *)
    | WithdrawTxParams recipient token amount =>
      maybe_token_balance <- & token.balances[_this_address];
      match maybe_token_balance with
      | Some token_balance =>
        maybe_insufficient_balance = builtin lt token_balance amount;
        match maybe_insufficient_balance with
        | False => (* no-op - balance is sufficient *)
        | True =>
          err = CodeInvalidTxInsufficientBalance;
          ThrowError err
        end
      | None =>
        err = CodeInvalidTxInsufficientBalance;
        ThrowError err
      end

    | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset =>
      (* TODO: validate deposit params *)
    | WithdrawHiveTxParams contribution min_zil_amount min_token_amount deadline_block_offset =>
      (* TODO: validate withdraw params *)
    end
  end
end

procedure IsNotPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    err = CodePendingTxExists;
    ThrowError err
  | None =>
  end
end

procedure IsTaxable(member: ByStr20, epoch_number: Uint32)
  maybe_taxed <- tax_collected[epoch_number][member];
  match maybe_taxed with
  | None =>
    maybe_tax_owed <- tax_owed[epoch_number][member];
    match maybe_tax_owed with
    | Some tax_amount =>
    | None => (* tax not owed by member *)
      err = CodeInvalidTaxParam;
      ThrowError err
    end
  | Some tax_amount => (* tax already collected for member in given epoch *)
    err = CodeAlreadyTaxed;
    ThrowError err
  end
end

(* Validates BankTx params of the current PendingTx *)
(* throws if there is no PendingTx *)
(* throws conditions of BankTx is not met  *)
procedure IsValidPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    match current_pending_tx with
    | PendingTx bank_tx signers => IsValidBankTx bank_tx
    end
  | None =>
    err = CodePendingTxDoesNotExist;
    ThrowError err
  end
end

procedure IsApplicationActive(member: ByStr20)
  maybe_application <- joining_requests[member];
  match maybe_application with
  | Some application =>
    match application with
    | True => (* no-op *)
    | False =>
      err = CodeMemberApplicationNotFound;
      ThrowError err
    end
  | None =>
    err = CodeMemberApplicationNotFound;
    ThrowError err
   end
end

procedure IsCaptainOrOfficer(address: ByStr20)
  current_officers <- officers;
  maybe_captain <- contract_owner;
  match maybe_captain with
  | Some captain =>
    power = get_power current_officers captain address;
    is_no_power = builtin eq power uint32_zero;
    match is_no_power with
    | True =>
      err = CodeNotCaptainOrOfficer;
      ThrowError err
    | False => (* no op *)
    end
  | None =>
    err = CodeNotCaptainOrOfficer;
    ThrowError err
  end
end

procedure IsBankAuthority(address: ByStr20)
  is_bank_authority = builtin eq bank_authority address;
  match is_bank_authority with
  | False =>
    err = CodeNotBankAuthority;
    ThrowError err
  | True =>
  end
end

procedure IsNotMember(user: ByStr20)
  maybe_member <- members[user];
  match maybe_member with
  | Some member =>
    err = CodeIsAlreadyMember;
    ThrowError err
  | None =>
  end
end

procedure IsMember(user: ByStr20)
  maybe_member <- members[user];
  match maybe_member with
  | Some member =>
  | None =>
    err = CodeNotMember;
    ThrowError err
  end
end

procedure IsNotOfficer(user: ByStr20)
  maybe_officer <- officers[user];
  match maybe_officer with
  | Some officer =>
    err = CodeIsAlreadyOfficer;
    ThrowError err
  | None =>
  end
end

procedure IsOfficer(user: ByStr20)
  maybe_officer <- officers[user];
  match maybe_officer with
  | Some officer =>
  | None =>
    err = CodeNotOfficer;
    ThrowError err
  end
end

procedure ReceiveZil(amount: Uint128)
  maybe_match_amount = builtin eq amount _amount;
  match maybe_match_amount with
  | True =>
    accept
  | False =>
    err = CodeAmountRecievedMismatch;
    ThrowError err
  end
end

procedure SendZil(recipient: ByStr20, amount: Uint128)
  msg = { _tag : "AddFunds"; _recipient: recipient; _amount: amount };
  msgs = one_msg msg;
  send msgs
end

(* update tokens_held map *)
procedure UpdateTokenBalance(
  token: ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end
)
  maybe_token_balance <- & token.balances[_this_address];
  match maybe_token_balance with
  | Some token_balance =>
    is_zero_balance = builtin eq token_balance zero;
    match is_zero_balance with
    | True => delete tokens_held[token]
    | False => tokens_held[token] := true
    end
  | None => delete tokens_held[token]
  end
end

procedure ReceiveToken(
  from: ByStr20,
  token: ByStr20 with contract
    field balances : Map ByStr20 Uint128
  end, 
  amount: Uint128
)
  msg_to_token = {
    _tag: "TransferFrom";
    _recipient: token;
    _amount: zero;
    from: from;
    to: _this_address;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs
end

procedure SendToken(params: SendTokenParam)
  match params with
  | SendTokenParam recipient token amount =>
    msg_to_token = {
      _tag: "Transfer";
      _recipient: token;
      _amount: zero;
      to: recipient;
      amount: amount
    };
    msgs = one_msg msg_to_token;
    send msgs
  end
end

(* multi-sig authenticated operation *)
procedure UpdateGuildSettings(settings: GuildBankSettings)
  match settings with
  | GuildBankSettings new_joining_fee new_weekly_tax new_control_mode =>
    joining_fee := new_joining_fee;
    weekly_tax := new_weekly_tax;
    control_mode := new_control_mode;

    e = {_eventname: "BankSettingsUpdated"; settings: settings };
    event e
  end
end

(* multi-sig authenticated operation *)
procedure Withdraw(
  recipient: ByStr20,
  token: ByStr20 with contract
    field balances : Map ByStr20 Uint128
  end, 
  amount: Uint128
)
  params = SendTokenParam recipient token amount;
  SendToken params;

  e = {_eventname: "WithdrawComplete" };
  event e
end

(* multi-sig authenticated operation *)
procedure DepositHive(min_contribution: Uint128, max_token_amount: Uint128, deadline_block_offset: Uint32)
  current_block_number <- & BLOCKNUMBER;
  deadline_block = builtin badd current_block_number deadline_block_offset;
  hive_address <- & bank_authority.hive;
  msg_to_hive = {
    _tag: "AddLiquidity";
    _recipient: hive_address;
    _amount: zero;
    min_contribution_amount: min_contribution;
    max_token_amount: max_token_amount;
    deadline_block: deadline_block
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "HiveDepositComplete" };
  event e
end

(* multi-sig authenticated operation *)
procedure WithdrawHive(contribution: Uint128, min_zil_amount: Uint128, min_token_amount: Uint128, deadline_block_offset: Uint32)
  current_block_number <- & BLOCKNUMBER;
  deadline_block = builtin badd current_block_number deadline_block_offset;
  hive_address <- & bank_authority.hive;
  msg_to_hive = {
    _tag: "RemoveLiquidity";
    _recipient: hive_address;
    _amount: zero;
    amount: contribution;
    min_zil_amount: min_zil_amount;
    min_token_amount: min_token_amount;
    deadline_block: deadline_block
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "HiveWithdrawComplete" };
  event e
end

(* execute transaction specified in BankTx *)
procedure ExecuteBankTx(bank_tx: BankTx)
  match bank_tx with
  | BankTx message initiator tx_params => 
    match tx_params with
    | UpdateConfigTxParams new_settings => UpdateGuildSettings new_settings
    | WithdrawTxParams recipient token amount => Withdraw recipient token amount
    | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset => 
      DepositHive min_contribution max_token_amount deadline_block_offset
    | WithdrawHiveTxParams contribution min_zil_amount min_token_amount deadline_block_offset =>
      WithdrawHive contribution min_zil_amount min_token_amount deadline_block_offset
    end
  end
end

(* execute given PendingTx is multisig signature requirement has been met *)
procedure CheckConcludePendingTx(current_pending_tx: PendingTx)
  current_control_mode <- control_mode;
  required_power = get_required_power current_control_mode;
  match current_pending_tx with
  | PendingTx bank_tx signers =>
    maybe_owner <- contract_owner;
    match maybe_owner with
    | Some current_captain =>
      current_officers <- officers;
      current_power = get_current_power signers current_officers current_captain;
      maybe_insufficient_power = builtin lt current_power required_power;
      match maybe_insufficient_power with
      | True => (* insufficient power to execute *)
      | False => 
        ExecuteBankTx bank_tx;

        none_pending_tx = None {PendingTx};
        pending_tx := none_pending_tx;

        e = {_eventname: "TxExecuted"; pending_tx: current_pending_tx };
        event e
      end
    | None => (* impossible *)
    end
   end
end

procedure SignPendingTx(signer: ByStr20)
  IsValidPendingTx;

  maybe_tx <- pending_tx;
  match maybe_tx with
  | Some tx =>
    new_pending_tx = insert_tx_signer tx signer;
    p = Some {PendingTx} new_pending_tx;
    pending_tx := p;
    
    e = {_eventname: "TxSigned"; signer: _sender; pending_tx: new_pending_tx };
    event e;
    
    CheckConcludePendingTx new_pending_tx
  | None => (* not possible *)
   end
end

(* reset signature progress on guild multisig transaction *)
(* effected when any of guild officers or captain is changed *)
procedure ResetPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some current_pending_tx =>
    match current_pending_tx with
    | PendingTx bank_tx signers =>
      empty_signers = Nil {ByStr20};
      new_pending_tx = PendingTx bank_tx empty_signers;
      p = Some {PendingTx} new_pending_tx;
      pending_tx := p;
      e = {_eventname: "TxSigningReset"; pending_tx: new_pending_tx };
      event e
    end
  | None => (* no-op *)
  end
end

(* payout to captain and officers according to allocation *)
procedure PayoutManagementFee(
  fee: Fee,
  gross_amount: Uint128,
  token: ByStr20 with contract field balances: Map ByStr20 Uint128 end
)
  match fee with
  | Fee _ _ _ allocation =>
    match allocation with
    | FeeAllocation captain_bps officer_bps =>
      current_officers <- officers;
      officer_list = map_to_list current_officers;

      officer_amount = get_amount_portion gross_amount officer_bps;
      map_send_params = @list_map ByStr20 SendTokenParam;
      fn = fun (officer: ByStr20) => SendTokenParam officer token officer_amount;
      param_list = map_send_params fn officer_list;
      forall param_list SendToken;

      maybe_captain <- contract_owner;
      match maybe_captain with
      | Some captain =>
        captain_amount = get_amount_portion gross_amount captain_bps;
        params = SendTokenParam captain token captain_amount;
        SendToken params
      | None =>
      end
    end
  end
end


procedure ReceiveTax(param: TaxParam)
  current_tax <- weekly_tax;
  match param with
  | TaxParam member epoch_number =>
    IsTaxable member epoch_number;

    huny_token <- & bank_authority.huny;
    maybe_tax_owed <- tax_owed[epoch_number][member];
    match maybe_tax_owed with
    | None => 
      err = CodeInvalidTaxParam;
      ThrowError err
    | Some tax_amount =>
      ReceiveToken member huny_token tax_amount;
      tax_collected[epoch_number][member] := tax_amount;
      delete tax_owed[epoch_number][member];

      e = {_eventname: "TaxCollected"; payer: member; tax_amount: tax_amount; epoch_number: epoch_number };
      event e;
      PayoutManagementFee current_tax tax_amount huny_token
    end
  end
end

procedure MigrateToken(param: MigrateParam)
  match param with
  | MigrateParam token_address recipient =>
    maybe_token <- & token_address as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
    match maybe_token with
    | Some token =>
      maybe_token_balance <- & token.balances[_this_address];
      match maybe_token_balance with
      | Some token_balance =>
        params = SendTokenParam recipient token token_balance;
        SendToken params
      | None => (* no-op - should not happen *)
      end
    | None => (* no-op - should not happen *)
    end
  end
end

procedure RecordTaxOwed(tax: TaxOwed)
  match tax with
  | TaxOwed member epoch_number amount =>
    tax_owed[epoch_number][member] := amount
  end
end

(* advance epoch to given epoch number, must be last_updated_epoch + 1  *)
(* update joining fee if epoch has been updated                         *)
(* record weekly taxes into tax_owed if any                             *)
(* record weekly taxes into tax_owed if any                             *)
procedure AdvanceEpoch(current_epoch: Uint32)
  f <- joining_fee;

  new_joining_fee = get_fee_amount f current_epoch;
  current_joining_fee := new_joining_fee;

  current_members <- members;
  members_list = map_to_list current_members;

  current_tax <- weekly_tax;
  tax_amount = get_fee_amount current_tax current_epoch;

  list_convert = @list_map ByStr20 TaxOwed;
  fn = fun (member: ByStr20) => TaxOwed member current_epoch tax_amount;
  tax_list = list_convert fn members_list;
  forall tax_list RecordTaxOwed;

  last_updated_epoch := current_epoch;

  e = {_eventname: "EpochUpdated"; epoch: current_epoch };
  event e
end


(* check bank authority contract and update current epoch                     *)
(* executes AdvanceEpoch for every epoch since last_epoch until current_epoch *)
procedure UpdateEpoch()
  last_epoch <- last_updated_epoch;
  current_epoch <- & bank_authority.current_epoch;
  maybe_already_updated = builtin eq last_epoch current_epoch;
  match maybe_already_updated with
  | True => (* no op*)
  | False =>
    diff = builtin sub current_epoch last_epoch;
    diff_nat = builtin to_nat diff;
    fold = @nat_fold (List Uint32);
    fn = fun (list: List Uint32) => fun (nat: Nat) => 
      let step = nat_to_int nat in
      let offset = builtin sub diff step in
      let epoch_number = builtin add last_epoch offset in
      Cons {Uint32} epoch_number list;
    init = Nil {Uint32};
    epoch_list = fold fn init diff_nat;
    reverse_list = @list_reverse Uint32;
    epoch_list_reverse = reverse_list epoch_list; 
    forall epoch_list_reverse AdvanceEpoch
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Request to join guild                                                        *)
(* required before a member can join the guild by calling ApproveAndReceiveJoiningFee *)
transition ApplyForMembership()
  IsNotMember _sender;

  joining_requests[_sender] := true;

  e = {_eventname: "MemberApplicationCreated"; applicant: _sender};
  event e
end

(* @dev: Withdraw guild membership application *)
transition WithdrawMembershipApplication()
  IsApplicationActive _sender;

  delete joining_requests[_sender];

  e = {_eventname: "MemberApplicationWithdrawn"; applicant: _sender};
  event e
end

(* @dev: Initiate a generic multisig transaction (depends on configuration  *)
(* could resolve immediately if in single-signature mode)                   *)
(* @param tx_params: multisig transaction parameters                        *)
(* @param message: user message for the multisig transaction request        *)
transition InitiateTx(tx_params: TxParams, message: String)
  IsCaptainOrOfficer _sender;
  IsNotPendingTx;

  UpdateEpoch;

  bank_tx = BankTx message _sender tx_params; 
  IsValidBankTx bank_tx;

  new_pending_tx = create_pending_tx bank_tx;
  p = Some {PendingTx} new_pending_tx;
  pending_tx := p;

  e = {_eventname: "TxInitiated"; initiator: _sender; pending_tx: new_pending_tx };
  event e;

  SignPendingTx _sender
end

(* @dev: Cancels a pending multisig transaction. *)
transition CancelTx()
  IsOwner _sender;

  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
  | Some cancelled_pending_tx =>
    no_pending_tx = None {PendingTx};
    pending_tx := no_pending_tx;

    e = {_eventname: "TxCancelled"; initiator: _sender; pending_tx: cancelled_pending_tx };
    event e
  | None =>
    err = CodePendingTxDoesNotExist;
    ThrowError err
  end
  
end

(* @dev: Sign a multisig transaction, resolves and executes if number of *)
(* required signing parties is met. *)
transition SignTx()
  IsCaptainOrOfficer _sender;
  UpdateEpoch;

  SignPendingTx _sender
end

(* @dev: Promote a member from normal member to officer status *)
(* @param member: member to be promoted                        *)
transition PromoteMember(member: ByStr20)
  IsOwner _sender;

  IsNotOfficer member;
  IsMember member;

  current_officers <- officers;
  officer_list = map_to_list current_officers;
  officer_count = get_list_length officer_list;

  has_officer_capacity = builtin lt officer_count max_officer_count;
  match has_officer_capacity with
  | True =>
    officers[member] := true;

    e = {_eventname: "MemberPromoted"; member: _sender};
    event e;

    ResetPendingTx
  | False =>
    err = CodeOfficerLimitReached;
    ThrowError err
  end
end

(* @dev: Demote a member from officer to normal member status *)
(* @param member: member to be demoted                        *)
transition DemoteMember(member: ByStr20)
  IsOwner _sender;
  
  IsOfficer member;

  delete officers[member];

  e = {_eventname: "MemberDemoted"; member: _sender};
  event e;

  ResetPendingTx
end

(* @dev: Remove a member from the guild, can only be called by captain or *)
(* officer. Cannot remove self.                                           *)
(* @param member: member to be removed from guild                         *)
transition RemoveMember(member: ByStr20)
  IsCaptainOrOfficer _sender;
  IsMember member;
  IsNotOwner member;

  is_removing_self = builtin eq member _sender;
  match is_removing_self with
  | False =>
    delete members[member];
    e = {_eventname: "MemberLeft"; member: member};
    event e;

    maybe_officer <- officers[member];
    match maybe_officer with
    | Some officer =>
      delete officers[member];
      ResetPendingTx
    | None => (* no-op *)
    end
  | True =>
    err = CodeNotOwner;
    ThrowError err
  end
end

(* @dev: Remove caller from the guild, cannot be called by owner *)
transition LeaveGuild()
  IsNotOwner _sender;
  IsMember _sender;

  UpdateEpoch;

  delete members[_sender];
  e = {_eventname: "MemberLeft"; member: _sender};
  event e;

  maybe_officer <- officers[_sender];
  match maybe_officer with
  | Some officer =>
    delete officers[_sender];
    ResetPendingTx
  | None => (* no-op *)
  end
end

(* @dev: Approve membership application and charge joining fee to user.       *)
(* if member leaves and then eventually joins guild again, no fee is charged. *)
(* @param member: member to be charge fee and add to guild                    *)
transition ApproveAndReceiveJoiningFee(member: ByStr20)
  IsNotMember member;
  IsApplicationActive member;

  UpdateEpoch;

  (* add member to members *)
  members[member] := true;

  delete joining_requests[member];

  (* announce new membership *)
  e = {_eventname: "MemberJoined"; member: member};
  event e;

  (* check if joining fee paid *)
  maybe_paid_joining_fee <- joining_fee_paid[member];
  match maybe_paid_joining_fee with
  | Some _ => (* no-op - fee already paid previously *)
  | None =>

    (* check if joining fee is zero *)
    fee_amount <- current_joining_fee;
    has_joining_fee = builtin lt zero fee_amount;
    match has_joining_fee with
    | False => (* no-op - joining fee ≤ zero *)
    | True =>
      joining_fee_paid[member] := fee_amount;

      huny_token <- & bank_authority.huny;
      e = {_eventname: "PaidJoiningFee"; member: member; token: huny_token; amount: fee_amount};
      event e;

      ReceiveToken member huny_token fee_amount;

      fee_config <- joining_fee;
      PayoutManagementFee fee_config fee_amount huny_token
    end
   end
end

(* @dev: Transfers specified amount of tokens to guild bank *)
(* @param token: address of token to donate                 *)
(* @param amount: amount of token to donate                 *)
transition MakeDonation(
  token: ByStr20,
  amount: Uint128
)
  is_token_zil = builtin eq zero_address token;
  match is_token_zil with
  | True =>
    ReceiveZil amount
  | False =>
    maybe_token_address <- & token as ByStr20 with contract field balances : Map ByStr20 Uint128 end;
    match maybe_token_address with
    | Some token_address => ReceiveToken _sender token_address amount
    | None =>
    end
  end;

  e = {_eventname: "DonationReceived"; initiator: _sender; token: token; amount: amount};
  event e
end

(* @dev: Transfers tax from specified guild members to guild bank       *)
(* @param params: list of member and epoch number to collect taxes for  *)
transition CollectTax(params: List TaxParam)
  IsCaptainOrOfficer _sender;

  UpdateEpoch;
  forall params ReceiveTax
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
(* @param token: token contract               *)
(* @param recipient: contract to receive token balances               *)
transition Migrate(token: ByStr20, recipient: ByStr20)
  IsBankAuthority _sender;

  zil_balance <- _balance;
  has_no_zil_balance = builtin eq zil_balance zero;
  match has_no_zil_balance with
  | True =>
  | False =>
    SendZil recipient zil_balance
  end;

  param = MigrateParam token recipient;
  MigrateToken param
end

(* @dev: Claim Magic Hive rewards *)
transition ClaimHive()
  hive_address <- & bank_authority.hive;
  msg_to_hive = {
    _tag: "Claim";
    _recipient: hive_address;
    _amount: zero
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "ClaimedHive"; initiator: _sender};
  event e
end


(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e;

  ResetPendingTx
end

(***************************************)
(*             Callbacks               *)
(***************************************)

(* receive fee/tax *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op *)
end
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow sending tokens to bank *)
  maybe_token_address <- & _sender as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
  match maybe_token_address with
  | Some token_address => UpdateTokenBalance token_address
  | None => (* no-op *)
  end
end
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow withdraw multisign tx *)
  maybe_token_address <- & _sender as ByStr20 with contract field balances: Map ByStr20 Uint128 end;
  match maybe_token_address with
  | Some token_address => UpdateTokenBalance token_address
  | None => (* no-op *)
  end
end
