scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import ListUtils
library GuildBank

let true = True
let false = False
let zero = Uint128 0
let one = Uint128 1
let none = None {ByStr20}
let zero_address = 0x0000000000000000000000000000000000000000

type ControlMode =
  | CaptainOnly
  | CaptainAndOneOfficer
  | CaptainAndTwoOfficers

type GuildBankSettings =
  | GuildBankSettings of Uint128 Uint128 ControlMode (* joining fee, weekly tax, multisig control mode *)

type TxParams =
  | UpdateConfigTxParams of GuildBankSettings
  | WithdrawTxParams of (* recipient, token, amount *)
    ByStr20
    ByStr20 with contract 
      field balances : Map ByStr20 Uint128,
      field allowances : Map ByStr20 (Map ByStr20 Uint128)
    end
    Uint128
  | DepositHiveTxParams of Uint128 Uint128 Uint32 (* min contribution, max token amount, deadline blocks offset *)

type BankTx =
  | BankTx of String ByStr20 TxParams (* message, initiator, params *)

type TaxParam =
  | TaxParam of ByStr20 Uint32 (* payer, epoch number *)

type PendingTx =
  | PendingTx of BankTx (List ByStr20) (* tx, approvals *)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotSelf
  | CodeNotPendingOwner
  | CodePendingOwnerNotEmpty
  | CodePendingTxDoesNotExist
  | CodePendingTxExists
  | CodeInvalidTxInsufficientBalance
  | CodeAmountRecievedMismatch
  | CodeInvalidTokenContract
  | CodeNoTokenBalance
  | CodeAlreadyTaxed

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                        => Int32 -1
      | CodeNotSelf                         => Int32 -2
      | CodeNotPendingOwner                 => Int32 -3
      | CodePendingOwnerNotEmpty            => Int32 -4
      | CodePendingTxDoesNotExist           => Int32 -5
      | CodePendingTxExists                 => Int32 -6
      (* CodeInvalidTxInsufficientBalance is also thrown when withdraw tx token address *)
      (* is not a valid ZRC2 token contract address *)
      | CodeInvalidTxInsufficientBalance    => Int32 -7
      | CodeAmountRecievedMismatch          => Int32 -8
      | CodeInvalidTokenContract            => Int32 -9
      | CodeNoTokenBalance                  => Int32 -10
      | CodeAlreadyTaxed                    => Int32 -11
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero
    end
(* removed in favour of forall implementation
let build_tax_msgs = 
  fun (taxed_list : List TaxParam) => 
  fun (tax_amount : Uint128) => 
  fun (huny_token_address : ByStr20) => 
  fun (recipient : ByStr20) => 
    let fold = @list_foldl_while TaxParam (List Message) in
    let fn = 
      fun (msgs: List Message) => 
      fun (param: TaxParam) =>
        match param with
        | TaxParam member epoch_number =>
          let msg = { 
            _tag: "TransferFrom";
            _recipient: huny_token_address;
            _amount: zero;
            from: member;
            to: recipient;
            amount: tax_amount
          } in
          let new_msgs = Cons {Message} msg msgs in
          Some {(List Message)} new_msgs
        end
    in
    let empty_msgs = Nil {Message} in
    fold fn empty_msgs taxed_list *)

let get_control_mode =
  fun (power : Uint32) =>
    let five = Uint32 5 in
    let two_officers = builtin eq power five in
    match two_officers with
    | True => CaptainAndTwoOfficers
    | False =>
      let four = Uint32 4 in
      let one_officer = builtin eq power four in
      match one_officer with
      | True => CaptainAndOneOfficer
      | False => CaptainOnly
      end
    end

let get_required_power =
  fun (mode : ControlMode) =>
      match mode with
      | CaptainOnly             => Uint32 3
      | CaptainAndOneOfficer    => Uint32 4
      | CaptainAndTwoOfficers   => Uint32 5
      end

let get_power = 
  fun (officers : List ByStr20) =>
  fun (captain : ByStr20) =>
  fun (member : ByStr20) =>
    let officer_find = @list_find (ByStr20) in
    let fn = fun (officer: ByStr20) => builtin eq officer member in
    let maybe_officer = officer_find fn officers in
    match maybe_officer with
      | Some address => Uint32 1 (* officer has 1 power *)
      | None =>
        let maybe_captain = builtin eq captain member in
        match maybe_captain with
          | True => Uint32 3 (* captain has 3 power *)
          | False => Uint32 0 (* member not privileged *)
        end
     end

let get_current_power =
  fun (signers : List ByStr20) =>
  fun (officers : List ByStr20) =>
  fun (captain : ByStr20) =>
    let fold = @list_foldl_while ByStr20 Uint32 in
    let fn = 
      fun (power: Uint32) => 
      fun (signer: ByStr20) =>
        let signer_power = get_power officers captain signer in
        let new_power = builtin add signer_power power in
        Some {Uint32} new_power
    in
    let uint32_zero = Uint32 0 in
    fold fn uint32_zero signers

let create_pending_tx = 
  fun (tx : BankTx) => 
    let empty_list = Nil {ByStr20} in
    PendingTx tx empty_list

let add_tx_signer = 
  fun (tx : PendingTx) => 
  fun (signer : ByStr20) =>
    match tx with
    | PendingTx bank_tx signers => 
      let new_signers = Cons {ByStr20} signer signers in
      PendingTx bank_tx new_signers
    end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract GuildBank(
  initial_owner: ByStr20,
  initial_hive: ByStr20,
  huny_token: ByStr20 with contract
    field balances : Map ByStr20 Uint128
  end,
  initial_joining_fee: Uint128,
  initial_weekly_tax: Uint128,
  initial_control_mode_power: Uint32,
  initial_officers: List ByStr20
)

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

field hive : ByStr20 = initial_hive

field control_mode : ControlMode = get_control_mode initial_control_mode_power
field pending_tx : Option PendingTx = None {PendingTx}

field joining_fee : Uint128 = initial_joining_fee
field weekly_tax : Uint128 = initial_weekly_tax

field members : List ByStr20 = Nil {ByStr20}
field officers : List ByStr20 = initial_officers

field token_balances : List ByStr20 = Nil {ByStr20}
field tax_collected: Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

procedure IsSelf(address: ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure IsValidBankTx(bank_tx: BankTx)
  match bank_tx with
    | BankTx message initiator params =>
      match params with
        | UpdateConfigTxParams new_settings =>

        | WithdrawTxParams recipient token amount =>
          maybe_token_balance <- & token.balances[_this_address];
          match maybe_token_balance with
            | Some token_balance =>
              maybe_insufficient_balance = builtin lt token_balance amount;
              match maybe_insufficient_balance with
                | False => (* no-op - balance is sufficient *)
                | True =>
                  err = CodeInvalidTxInsufficientBalance;
                  ThrowError err
              end
            | None =>
              err = CodeInvalidTxInsufficientBalance;
              ThrowError err
          end

        | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset =>
      end
  end
end

procedure IsNotPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
    | Some current_pending_tx =>
      err = CodePendingTxExists;
      ThrowError err
    | None =>
  end
end

procedure IsTaxable(member: ByStr20, epoch_number: Uint32)
  maybe_taxed <- tax_collected[epoch_number][member];
  match maybe_taxed with
    | None =>
    | Some tax_amount =>
      err = CodeAlreadyTaxed;
      ThrowError err
  end
end

(* Validates BankTx params of the current PendingTx *)
(* throws if there is no PendingTx *)
(* throws conditions of PendingTx is not met  *)
procedure IsValidPendingTx()
  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
    | Some current_pending_tx =>
      match current_pending_tx with
        | PendingTx bank_tx signers => IsValidBankTx bank_tx
      end
    | None =>
      err = CodePendingTxDoesNotExist;
      ThrowError err
  end
end

procedure ReceiveZil(amount: Uint128)
  maybe_match_amount = builtin eq amount _amount;
  match maybe_match_amount with
    | True =>
      accept
    | False =>
      err = CodeAmountRecievedMismatch;
      ThrowError err
  end
end

procedure SendZil(recipient: ByStr20, amount: Uint128)
  msg = { _tag : "AddFunds"; _recipient: recipient; _amount: amount };
  msgs = one_msg msg;
  send msgs
end

procedure ReceiveToken(from: ByStr20, token: ByStr20, amount: Uint128)
  msg_to_token = {
    _tag: "TransferFrom";
    _recipient: token;
    _amount: zero;
    from: from;
    to: _this_address;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs
end

procedure SendToken(recipient: ByStr20, token: ByStr20, amount: Uint128)
  msg_to_token = {
    _tag: "Transfer";
    _recipient: token;
    _amount: zero;
    to: recipient;
    amount: amount
  };
  msgs = one_msg msg_to_token;
  send msgs
end

(* multi-sig authenticated operation *)
procedure UpdateGuildSettings(settings: GuildBankSettings)
  match settings with
    | GuildBankSettings new_joining_fee new_weekly_tax new_control_mode =>
      joining_fee := new_joining_fee;
      weekly_tax := new_weekly_tax;
      control_mode := new_control_mode;

      e = {_eventname: "BankSettingsUpdated"; settings: settings };
      event e
  end
end

(* multi-sig authenticated operation *)
procedure Withdraw(recipient: ByStr20, token: ByStr20, amount: Uint128)
  SendToken recipient token amount;

  e = {_eventname: "WithdrawComplete" };
  event e
end

(* multi-sig authenticated operation *)
procedure DepositHive(min_contribution: Uint128, max_token_amount: Uint128, deadline_block_offset: Uint32)
  current_block_number <- & BLOCKNUMBER;
  deadline_block = builtin badd current_block_number deadline_block_offset;
  hive_address <- hive;
  msg_to_hive = {
    _tag: "AddLiquidity";
    _recipient: hive_address;
    _amount: zero;
    min_contribution_amount: min_contribution;
    max_token_amount: max_token_amount;
    deadline_block: deadline_block
  };
  msgs = one_msg msg_to_hive;
  send msgs;

  e = {_eventname: "HiveDepositComplete" };
  event e
end


procedure ExecuteBankTx(bank_tx: BankTx)
  match bank_tx with
    | BankTx message initiator tx_params => 
      match tx_params with
        | UpdateConfigTxParams new_settings => UpdateGuildSettings new_settings
        | WithdrawTxParams recipient token amount => Withdraw recipient token amount
        | DepositHiveTxParams min_contribution max_token_amount deadline_block_offset => 
          DepositHive min_contribution max_token_amount deadline_block_offset
      end
   end
end

procedure CheckConcludePendingTx(current_pending_tx: PendingTx)
  current_control_mode <- control_mode;
  required_power = get_required_power current_control_mode;
  match current_pending_tx with
    | PendingTx bank_tx signers =>
      current_officers <- officers;
      maybe_owner <- contract_owner;
      match maybe_owner with
        | Some current_captain =>
          current_power = get_current_power signers current_officers current_captain;
          maybe_insufficient_power = builtin lt current_power required_power;
          match maybe_insufficient_power with
            | True => (* insufficient power to execute *)
            | False => 
              ExecuteBankTx bank_tx;

              none_pending_tx = None {PendingTx};
              pending_tx := none_pending_tx;

              e = {_eventname: "TxExecuted"; pending_tx: current_pending_tx };
              event e
          end
        | None => (* impossible *)
       end
   end
end

procedure SignPendingTx(signer: ByStr20)
  IsValidPendingTx;

  maybe_tx <- pending_tx;
  match maybe_tx with
    | Some tx =>
      new_pending_tx = add_tx_signer tx signer;
      p = Some {PendingTx} new_pending_tx;
      pending_tx := p;
      
      e = {_eventname: "TxSigned"; signer: _sender; pending_tx: new_pending_tx };
      event e;
      
      CheckConcludePendingTx new_pending_tx
    | None => (* not possible *)
   end
end

procedure ReceiveTax(param: TaxParam)
  tax_amount <- weekly_tax;
  match param with
    | TaxParam member epoch_number =>
      IsTaxable member epoch_number;
      ReceiveToken member huny_token tax_amount;

      tax_collected[epoch_number][member] := tax_amount;

      e = {_eventname: "TaxCollected"; payer: member; tax_amount: tax_amount; epoch_number: epoch_number };
      event e
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Initiate a generic multisig transaction (depends on configuration *)
(* could resolve immediately if in single-signature mode) *)
transition InitiateTx(tx_params: TxParams, message: String)
  IsNotPendingTx;

  bank_tx = BankTx message _sender tx_params; 
  IsValidBankTx bank_tx;

  new_pending_tx = create_pending_tx bank_tx;
  p = Some {PendingTx} new_pending_tx;
  pending_tx := p;

  e = {_eventname: "TxInitiated"; initiator: _sender; pending_tx: new_pending_tx };
  event e;

  SignPendingTx _sender
end

(* @dev: Cancels a pending multisig transaction. *)
transition CancelTx()
  IsOwner _sender;

  maybe_pending_tx <- pending_tx;
  match maybe_pending_tx with
    | Some cancelled_pending_tx =>
      no_pending_tx = None {PendingTx};
      pending_tx := no_pending_tx;

      e = {_eventname: "TxCancelled"; initiator: _sender; pending_tx: cancelled_pending_tx };
      event e
    | None =>
      err = CodePendingTxDoesNotExist;
      ThrowError err
   end
  
end

(* @dev: Sign a multisig transaction, resolves and executes if number of *)
(* required signing parties is met. *)
transition SignTx()
  SignPendingTx _sender
end

(* @dev: Charge joining fee to user, called once by user joining a guild *)
transition PayJoiningFee()
  list <- members;
  new_list = Cons {ByStr20} _sender list;
  members := new_list;

  current_joining_fee <- joining_fee;
  has_joining_fee = builtin lt zero current_joining_fee;
  match has_joining_fee with
    | False =>
    | True =>
      ReceiveToken _sender huny_token current_joining_fee
  end;

  e = {_eventname: "PaidJoiningFee"; member: _sender; token: huny_token; amount: current_joining_fee};
  event e
end

(* @dev: Transfers specified amount of tokens to guild bank *)
transition MakeDonation(token: ByStr20, amount: Uint128)
  is_token_zil = builtin eq zero_address token;
  match is_token_zil with
    | True =>
      ReceiveZil amount
    | False =>
      ReceiveToken _sender token amount
  end;

  e = {_eventname: "DonationReceived"; initiator: _sender; token: token; amount: amount };
  event e
end

(* @dev: Transfers tax from specified guild members to guild bank *)
transition CollectTax(params: List TaxParam)
  forall params ReceiveTax
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
transition Migrate(recipient: ByStr20, token: ByStr20)
  IsOwner _sender;

  is_token_zil = builtin eq zero_address token;
  match is_token_zil with
    | True =>
      amount <- _balance;
      SendZil recipient amount
    | False =>
      msg_to_self = {
        _tag: "MigrateToken";
        _recipient: _this_address;
        _amount: zero;
        recipient: recipient;
        token: token
      };
      msgs = one_msg msg_to_self;
      send msgs
  end
end

(* @dev: Migrate token balance to specified contract *)
(* @dev: Only called by self, address cast workaround *)
transition MigrateToken(
  recipient: ByStr20,
  token: ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end
)
  IsSelf _sender;

  maybe_token_balance <- & token.balances[_this_address];
  match maybe_token_balance with
    | Some token_balance =>
      SendToken recipient token token_balance
    | None =>
      err = CodeNoTokenBalance;
      ThrowError err
  end
end

(* @dev: Migrate balance to specified contract - for contract upgrade *)
(* works on v8.1.0 (testnet, mainnet) but not v8.0.4 (ceres local) *)
(* transition Migrate(recipient: ByStr20, token: ByStr20)
  IsOwner _sender;

  is_token_zil = builtin eq zero_address token;
  match is_token_zil with
  | True =>
    amount <- _balance;
    SendZil recipient amount
  | False =>
    maybe_token_contract <- & token as ByStr20 with contract
      field balances: Map ByStr20 Uint128
    end;
    match maybe_token_contract with
    | Some token_contract =>
      maybe_token_balance <- & token_contract.balances[_this_address];
      match maybe_token_balance with
      | Some token_balance =>
        SendToken recipient token token_balance
      | None =>
        err = CodeNoTokenBalance;
        ThrowError err
      end
    | None =>
      err = CodeInvalidTokenContract;
      ThrowError err
    end
  end
end *)

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end

(***************************************)
(*             Callbacks               *)
(***************************************)

(* receive fee/tax *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op *)
end
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow sending tokens to bank *)
end
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op - allow withdraw multisign tx *)
end
