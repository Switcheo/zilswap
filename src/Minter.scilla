scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils IntUtils ListUtils PairUtils
library Minter

(* Global variables *)
let zero = Uint128 0
let zero_uint32 = Uint32 0
let one = Uint256 1
let false = False
let true = True
let json = ".json"

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_qty =
  fun (some_qty: Option Uint128) =>
    match some_qty with
      | Some qty => qty
      | None => zero
    end

let build_pair = 
  fun (to_address: ByStr20) => 
  fun (token_uri: String) =>
    Pair {ByStr20 String} to_address token_uri

let build_list : String -> ByStr20 -> Uint32 -> List (Pair ByStr20 String) =
  fun (token_uri_url: String) => fun (to: ByStr20) => fun (m: Uint32) =>
    let zero_lt_m = builtin lt zero_uint32 m in
    match zero_lt_m with
    | True =>
        (* m is the nat to recurse on *)
        let m_nat = builtin to_nat m in
        let nil = Nil {(Pair ByStr20 String)} in
        let list_init = nil in
        let step = fun (list :  List (Pair ByStr20 String)) => fun (ignore : Nat) =>
          let new_pair = build_pair to token_uri_url in
          let new_list = Cons {(Pair ByStr20 String)} new_pair list in
          new_list
        in
        let fold = @nat_fold (List (Pair ByStr20 String)) in
        let xs_m = fold step list_init m_nat in
        xs_m
    | False => Nil {(Pair ByStr20 String)}
    end
    
(* Error exception *)
type Error =
  | CodeNotContractOwner
  | CodeSaleNotActive
  | CodeExceedSupply
  | CodeExceedMaxPurchaseLimit   
  | CodeInsufficientAmount

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotContractOwner             => Int32 -1
      | CodeSaleNotActive                => Int32 -2
      | CodeExceedSupply                 => Int32 -3
      | CodeExceedMaxPurchaseLimit       => Int32 -4
      | CodeInsufficientAmount           => Int32 -5
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Minter
(
  contract_owner: ByStr20,
  max_nft_supply: Uint256,
  zrc_address: ByStr20,
  token_uri_url: String
)

(* Mutable fields *)

(* Total token count *)
field total_supply: Uint256 = Uint256 0

(* Price of NFT for sale *)
field bear_price: Uint128 = Uint128 1

(* Maximum number of tokens to mint in one transaction *)
field max_nft_purchase: Uint32 = Uint32 20

(* Flag to indicate if sale is active. Tokens will be mintable during a sale only *)
field sale_is_active: Bool = False

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure IsSaleActive()
  is_sale_active <- sale_is_active;
  match is_sale_active with
    | True =>
    | False =>
      err = CodeSaleNotActive;
      ThrowError err
  end
end

procedure IsNotExceedingSupply()
  current_supply <- total_supply;
  new_count = builtin add current_supply one;
  is_not_exceeding = uint256_le new_count max_nft_supply;
  match is_not_exceeding with
    | True =>
    | False =>
      err = CodeExceedSupply;
      ThrowError err
  end
end

procedure IsBelowMaxPurchaseLimit(quantity: Uint32)
  max_purchase_limit <- max_nft_purchase;
  is_not_exceeding = uint32_le quantity max_purchase_limit;
  match is_not_exceeding with
    | True =>
    | False =>
      err = CodeExceedMaxPurchaseLimit;
      ThrowError err
  end
end


procedure IsAmountSufficient(amount: Uint128)
  price <- bear_price;
  is_sufficient = uint128_le price amount;
  match is_sufficient with
    | True =>
    | False =>
      err = CodeInsufficientAmount;
      ThrowError err
  end
end

procedure IsBatchAmountSufficient(amount: Uint128, quantity: Option Uint128)
  price <- bear_price;
  qty = get_qty quantity;
  expected_amount = builtin mul price qty;
  is_sufficient = uint128_le expected_amount amount;
  match is_sufficient with
    | True =>
    | False =>
      err = CodeInsufficientAmount;
      ThrowError err
  end
end

procedure MintHelper(input_pair: Pair ByStr20 String)
  (* Require sale to be active to mint *)
  IsSaleActive;
  (* Require new mint to not exceed max supply *)
  IsNotExceedingSupply;
  (* Require transfer amount to be equal to NFT price *)
  IsAmountSufficient _amount;
  accept;
  (* Add to total_supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply;
  (* Deconstruct input_pair *)
  to = let fst_string_bystr20 = @fst ByStr20 String in
  fst_string_bystr20 input_pair;
  token_uri_url = let snd_string_bystr20 = @snd ByStr20 String in
  snd_string_bystr20 input_pair;
  token_id_string = builtin to_string new_supply;
  uri_path = builtin concat token_id_string json;
  token_uri = builtin concat token_uri_url uri_path;
  (* Initiate token_id and check conditions *)  
  token_id = new_supply;
  msg1 = { _tag: "IsTokenExists"; _recipient: zrc_address; _amount: Uint128 0; 
            token_id: token_id };
  (* Add to owner count *)
  msg2 = { _tag: "AddAndSetToken"; _recipient: zrc_address; _amount: Uint128 0;
            address: to; token_id: token_id; to: to; token_uri: token_uri };
  msgs = two_msgs msg1 msg2;
  send msgs;
  (* Emit event *)
  e = { _eventname: "AddApprovalSuccess"; initiator: _sender; token: token_id };
  event e;
  e = {_eventname: "MintSuccess"; by: _sender; recipient: to;
        token_id: token_id; token_uri: token_uri};
  event e
end

(* @dev:    Mint new tokens.                                  *)
(* @param:  to        - Address of the token recipient        *)
(* @param:  token_uri - URI of the the new token to be minted *)
transition Mint(to: ByStr20)
  input_pair = build_pair to token_uri_url;
  MintHelper input_pair;
  token_id <- total_supply;
  msg_to_recipient = { _tag : "RecipientAcceptMint"; _recipient : to; _amount : Uint128 0 };
  msg_to_sender = { _tag : "MintCallBack"; _recipient : _sender; _amount : Uint128 0;
                    recipient : to; token_id : token_id };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev:   Mint multiple new tokens.                             *)
(* @param: to        - Address of the token recipient            *)
(* @param: token_uri_list - URIs of the new tokens to be minted  *)
transition BatchMint(to: ByStr20, size: Uint32)
  (* Require number of tokens to mint is below limit *)
  IsBelowMaxPurchaseLimit size;
  (* Require amount to be sufficient to mint tokens. *)
  size_uint128 = builtin to_uint128 size;
  IsBatchAmountSufficient _amount size_uint128;
  input_list = build_list token_uri_url to size;
  forall input_list MintHelper;
  msg_to_sender = { _tag : "BatchMintCallBack"; _recipient : _sender; _amount : Uint128 0 };
  msgs = one_msg msg_to_sender;
  send msgs
end


(* @dev: Toggles the boolean flag for sale of tokens. Only owner can toggle *)
transition ToggleSaleActive()
  IsContractOwner;
  sale_active <- sale_is_active;
  match sale_active with
    | True =>
      sale_is_active := false;
      msg_to_sender = { _tag : "ToggleSaleActiveSuccessCallBack"; _recipient : _sender; _amount : Uint128 0;
                        sale_status : false};
    msgs = one_msg msg_to_sender;
    msgs = one_msg msg_to_sender;
    send msgs
    | False =>
      sale_is_active := true;
      msg_to_sender = { _tag : "ToggleSaleActiveSuccessCallBack"; _recipient : _sender; _amount : Uint128 0;
                        sale_status : true};
    msgs = one_msg msg_to_sender;
    send msgs
  end
end