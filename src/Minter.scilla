scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils IntUtils ListUtils PairUtils
library Minter

(* Global variables *)
let zero = Uint128 0
let one = Uint256 1
let false = False
let true = True
let token_uri_url = "https://ipfs.io/ipfs/QmUKgFcQuHHkQVCVwaC41VARB9EvDnnK4Jm3PyAhsbxNBd/"
let json = ".json"

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_qty =
  fun (some_qty: Option Uint128) =>
    match some_qty with
      | Some qty => qty
      | None => zero
    end

let build_pair = 
  fun (to_address: ByStr20) => 
  fun (token_uri: String) =>
    Pair {ByStr20 String} to_address token_uri

(* Error exception *)
type Error =
  | CodeNotContractOwner
  | CodeSaleNotActive
  | CodeExceedSupply
  | CodeInsufficientAmount

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotContractOwner             => Int32 -1
      | CodeSaleNotActive                => Int32 -2
      | CodeExceedSupply                 => Int32 -3
      | CodeInsufficientAmount           => Int32 -4
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Minter
(
  contract_owner: ByStr20,
  max_nft_supply: Uint256,
  zrc_address: ByStr20
)

(* Mutable fields *)

(* Total token count *)
field total_supply: Uint256 = Uint256 0

(* Price of NFT for sale *)
field bear_price: Uint128 = Uint128 1

(* Maximum number of tokens to mint in one transaction *)
field max_nft_purchase: Uint256 = Uint256 20

(* Flag to indicate if sale is active. Tokens will be mintable during a sale only *)
field sale_is_active: Bool = False

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure IsSaleActive()
  is_sale_active <- sale_is_active;
  match is_sale_active with
    | True =>
    | False =>
      err = CodeSaleNotActive;
      ThrowError err
  end
end

procedure IsExceedingSupply()
  current_supply <- total_supply;
  new_count = builtin add current_supply one;
  is_not_exceeding = uint256_le new_count max_nft_supply;
  match is_not_exceeding with
    | True =>
    | False =>
      err = CodeExceedSupply;
      ThrowError err
  end
end

procedure IsAmountSufficient(amount: Uint128)
  price <- bear_price;
  is_sufficient = uint128_le price amount;
  match is_sufficient with
    | True =>
    | False =>
      err = CodeInsufficientAmount;
      ThrowError err
  end
end

procedure IsBatchAmountSufficient(amount: Uint128, quantity: Option Uint128)
  price <- bear_price;
  qty = get_qty quantity;
  expected_amount = builtin mul price qty;
  is_sufficient = uint128_le expected_amount amount;
  match is_sufficient with
    | True =>
    | False =>
      err = CodeInsufficientAmount;
      ThrowError err
  end
end

procedure MintHelper(input_pair: Pair ByStr20 String)
  (* Require sale to be active to mint *)
  IsSaleActive;
  (* Require new mint to not exceed max supply *)
  IsExceedingSupply;
  (* Require transfer amount to be equal to NFT price *)
  IsAmountSufficient _amount;
  accept;
  (* Add to total_supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply;
  (* Deconstruct input_pair *)
  to = let fst_string_bystr20 = @fst ByStr20 String in
  fst_string_bystr20 input_pair;
  token_uri = let snd_string_bystr20 = @snd ByStr20 String in
  snd_string_bystr20 input_pair;
  (* Initiate token_id and check conditions *)  
  token_id = new_supply;
  msg1 = { _tag: "IsTokenExists"; _recipient: zrc_address; _amount: Uint128 0; 
            token_id: token_id };
  (* Add to owner count *)
  msg2 = { _tag: "AddAndSetToken"; _recipient: zrc_address; _amount: Uint128 0;
            address: to; token_id: token_id; to: to; token_uri: token_uri };
  msgs = two_msgs msg1 msg2;
  send msgs;
  (* Emit event *)
  e = { _eventname: "AddApprovalSuccess"; initiator: _sender; token: token_id };
  event e;
  e = {_eventname: "MintSuccess"; by: _sender; recipient: to;
        token_id: token_id; token_uri: token_uri};
  event e
end

(* @dev:    Mint new tokens.                                  *)
(* @param:  to        - Address of the token recipient        *)
(* @param:  token_uri - URI of the the new token to be minted *)
transition Mint(to: ByStr20, token_uri: String)
  input_pair = build_pair to token_uri;
  MintHelper input_pair;
  token_id <- total_supply;
  msg_to_recipient = { _tag : "RecipientAcceptMint"; _recipient : to; _amount : Uint128 0 };
  msg_to_sender = { _tag : "MintCallBack"; _recipient : _sender; _amount : Uint128 0;
                    recipient : to; token_id : token_id; token_uri : token_uri };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev:   Mint multiple new tokens.                             *)
(* @param: to        - Address of the token recipient            *)
(* @param: token_uri_list - URIs of the new tokens to be minted  *)
transition BatchMint(to: ByStr20, token_uri_list: List String)
  list_length_string = @list_length String;
  size = list_length_string token_uri_list;
  size_uint128 = builtin to_uint128 size;
  IsBatchAmountSufficient _amount size_uint128;
  pair_token_uri_list = @list_map String (Pair ByStr20 String);
  tmp_fun = build_pair to;
  input_list = pair_token_uri_list tmp_fun token_uri_list;
  forall input_list MintHelper;
  msg_to_sender = { _tag : "BatchMintCallBack"; _recipient : _sender; _amount : Uint128 0 };
  msgs = one_msg msg_to_sender;
  send msgs
end


(* @dev: Toggles the boolean flag for sale of tokens. Only owner can toggle *)
transition ToggleSaleActive()
  IsContractOwner;
  sale_active <- sale_is_active;
  match sale_active with
    | True =>
      sale_is_active := false;
      msg_to_sender = { _tag : "ToggleSaleActiveSuccessCallBack"; _recipient : _sender; _amount : Uint128 0;
                        sale_status : false};
    msgs = one_msg msg_to_sender;
    msgs = one_msg msg_to_sender;
    send msgs
    | False =>
      sale_is_active := true;
      msg_to_sender = { _tag : "ToggleSaleActiveSuccessCallBack"; _recipient : _sender; _amount : Uint128 0;
                        sale_status : true};
    msgs = one_msg msg_to_sender;
    send msgs
  end
end