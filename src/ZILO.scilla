scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

library ZILO

(* Error events *)
type Error =
| CodeNotOwner
| CodeNotPendingOwner
| CodePendingOwnerNotEmpty
| CodeAmountNotPositive
| CodeAmountTooLarge
| CodeInvalidDuration
| CodeOfferingNotFound
| CodeContributionNotFound
| CodeCannotContributeNow
| CodeCannotClaimNow
| CodeCannotCompleteNow
| CodeIntegerOverflow

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner              => Int32 -1
      | CodeNotPendingOwner       => Int32 -2
      | CodePendingOwnerNotEmpty  => Int32 -3
      | CodeAmountNotPositive     => Int32 -4
      | CodeAmountTooLarge        => Int32 -5
      | CodeInvalidDuration       => Int32 -6
      | CodeOfferingNotFound      => Int32 -7
      | CodeContributionNotFound  => Int32 -8
      | CodeCannotContributeNow   => Int32 -9
      | CodeCannotClaimNow        => Int32 -10
      | CodeCannotCompleteNow     => Int32 -11
      | CodeIntegerOverflow       => Int32 -12
      end
    in
    { _exception : "Error"; code : result_code }

(* TODO: add success events *)

(* ZILO ADTs *)
type Distribution = | Distribution of ByStr20 Uint128 (* tokenAddr distributionAmt *)
type Target = | Target of Uint128 Uint128 (* targetQAs targetZWAPs *)
type Duration = | Duration of BNum BNum (* startBlock endBlock *)
type Resolution = | Resolution of Uint128 Uint128 ByStr20 ByStr20 (* minimumQAs lpQAs ownerAddr lpAddr *)
type Offering = | Offering of Distribution Target Duration Resolution
type State =
| Pending (* initialized but waiting for start block *)
| Active (* can send zil / zwap *)
| Failed (* refund all *)
| Completed (* can claim *)

(* Constants *)
let zero = Uint128 0
let one = Uint128 1
let none = None {ByStr20}

(* converts a Uint128 to a Uint256 *)
let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* unwraps a Uint128 from a Option Uint128, returning 0 if Option resolves to None. *)
let getSomeInt =
  fun (x: Option Uint128) =>
  match x with
  | Some a => a
  | None => zero
  end

(* returns the minimum of x and y *)
let min =
  fun (x: Uint128) =>
  fun (y: Uint128) =>
  let x_lt_y = builtin lt x y in
  match x_lt_y with
  | True => x
  | False => y
  end

(* computes the amount of the fraction x / d that is in y *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128 =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

(* computes the offering state *)
let getState =
  fun (duration: Duration) =>
  fun (resolution: Resolution) =>
  fun (current_block: BNum) =>
  fun (raised_amount: Uint128) =>
  match duration with
  | Duration start_block end_block =>
    match resolution with
    | Resolution min_amount _ _ _ =>
      let before = builtin blt current_block start_block in
      match before with
      | True =>
        Pending
      | False =>
        let ended = builtin blt end_block current_block in
        match ended with
        | True =>
          let failed = builtin lt raised_amount min_amount in
          match failed with
          | True => Failed
          | False => Completed
          end
        | False =>
          Active
        end
      end
    end
  end

let getTargetQAs =
  fun (target: Target) =>
  match target with
  | Target targetQAs _ => targetQAs
  end

(* wraps a single message in a list ADT for sending *)
let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ZILO
(
  zwap_token_contract : ByStr20,
  initial_owner : ByStr20
)

(* Mutable fields *)

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none
field offerings : Map Uint32 Offering = Emp Uint32 Offering
field offerings_count : Uint32 = Uint32 0
field raised_amounts : Map Uint32 Uint128 = Emp Uint32 Uint128 (* in QAs *)
field contributions : Map Uint32 (Map ByStr20 Uint128) = Emp Uint32 (Map ByStr20 Uint128) (* in QAs *)

(**************************************)
(*             Procedures             *)
(**************************************)

(* @dev: Throws the given error. *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* @dev: Asserts that the given address is the contract owner. Throws otherwise. *)
procedure AssertIsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

(* @dev: Asserts that the given address is the pending contract owner. Throws otherwise. *)
procedure AssertIsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

(* @dev: Asserts that there is no pending contract owner. Throws otherwise. *)
procedure AssertNoPendingOwner()
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | None =>
  | Some p =>
    err = CodePendingOwnerNotEmpty;
    ThrowError err
  end
end

(* @dev: Asserts that then given amount is not zero. Throws otherwise. *)
procedure AssertNotZero(amount: Uint128)
  is_zero = builtin eq amount zero;
  match is_zero with
  | False =>
  | True =>
    err = CodeAmountNotPositive;
    ThrowError err
  end
end

(* @dev: Asserts that the first given block number is strictly less than then second. Throws otherwise. *)
procedure AssertIsBefore(before: BNum, after: BNum)
  is_before = builtin blt before after;
  match is_before with
  | True =>
  | False =>
    err = CodeInvalidDuration;
    ThrowError err
  end
end

(* @dev: Asserts that the first given uint128 is strictly less than then second. Throws otherwise. *)
procedure AssertIsLessThan(x: Uint128, y: Uint128)
  is_less_than = builtin lt x y;
  match is_less_than with
  | True =>
  | False =>
    err = CodeAmountTooLarge;
    ThrowError err
  end
end

(* @dev: Adds the given offering to state, incrementing the total offerings count *)
procedure AddOffering(offering: Offering)
  count <- offerings_count;
  offerings[count] := offering;
  new_offerings_count =
    let one = Uint32 1 in
    builtin add count one;
  offerings_count := new_offerings_count
end

(* @dev: Computes the amount of ZWAP required for the transferred _amount in relation to the target amounts,
  then the tries to transfer the required ZWAP. *)
procedure TransferZWAP(target: Target)
  match target with
  | Target targetQAs targetZWAPs =>
    maybe_amt = frac _amount targetQAs targetZWAPs;
    match maybe_amt with
    | None =>
      err = CodeIntegerOverflow;
      ThrowError err
    | Some amt =>
      amount = builtin add amt one; (* round up *)
      msg_to_zwap = {
        _tag : "TransferFrom"; _recipient: zwap_token_contract; _amount: zero;
        from: _sender; to: _this_address; amount: amount
      };
      msgs = oneMsg msg_to_zwap;
      send msgs
    end
  end
end

procedure Distribute(distribution: Distribution, target: Target, contribution: Uint128)
  match distribution with
  | Distribution token targetTKNs =>
    match target with
    | Target targetQAs _ =>
      amount = let x = frac contribution targetTKNs targetQAs in
        getSomeInt x; (* safe because frac should not overflow as contribution is always <= targetQAs *)
      msg_to_token =  {
        _tag : "Transfer"; _recipient: token; _amount: zero;
        to: _sender; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    end
  end
end

procedure Refund(distribution: Distribution, target: Target, amount: Uint128)
  match target with
  | Target targetQAs targetZWAPs =>
    zwap_refund = let x = frac amount targetQAs targetZWAPs in
      getSomeInt x; (* safe because a larger computation neccesarily would have passed before *)

    (* refund zwap *)
    msg_to_zwap =  {
      _tag : "Transfer"; _recipient: zwap_token_contract; _amount: zero;
      to: _sender; amount: amount
    };

    (* refund zil *)
    msg_to_sender = { _tag : "AddFunds"; _recipient: _sender; _amount: amount };

    msgs = let nil_msg = Nil {Message} in
      let one_msg = Cons {Message} msg_to_zwap nil_msg in
      Cons {Message} msg_to_sender one_msg;

    send msgs
  end
end


(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Removes the contract_owner, meaning that new offerings can no longer be added. Must not have a pending owner. *)
(* transition RevokeOwnership()
  AssertIsOwner _sender;
  AssertNoPendingOwner;
  contract_owner := none;
  e = {_eventname : "OwnershipRevoked"; contract_owner : _sender};
  event e
end *)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  AssertIsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  AssertIsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end

transition Create(offering: Offering)
  AssertIsOwner _sender;

  (* Validate offering *)
  match offering with
  | Offering distribution target duration resolution =>
    match distribution with
    | Distribution token amt_tkn =>
      AssertNotZero amt_tkn;
      (* send distribution amt now to avoid the possibility that contributions cannot be claimed later *)
      msg_to_token = {
        _tag : "TransferFrom"; _recipient: zwap_token_contract; _amount: zero;
        from: _sender; to: _this_address; amount: amt_tkn
      };
      msgs = oneMsg msg_to_token;
      send msgs
    end;
    match target with
    | Target amt_zil amt_zwap =>
      AssertNotZero amt_zil;
      AssertNotZero amt_zwap;
      match resolution with
      | Resolution _ lp_zil _ _ =>
        (* validate resolution - lp share < total amt *)
        AssertIsLessThan lp_zil amt_zil
      end
    end;
    match duration with
    | Duration start_block end_block =>
      current_block <- & BLOCKNUMBER;
      AssertIsBefore current_block start_block;
      AssertIsBefore start_block end_block
    end
  end;

  AddOffering offering
end

transition Contribute(id: Uint32)
  (* load offering *)
  maybe_offering <- offerings[id];
  match maybe_offering with
  | None =>
    err = CodeOfferingNotFound;
    ThrowError err
  | Some offering =>
    match offering with
    | Offering distribution target duration resolution =>
      (* check offering state *)
      current_block <- & BLOCKNUMBER;
      maybe_raised_amount <- raised_amounts[id];
      raised_amount = getSomeInt maybe_raised_amount;
      state = getState duration resolution current_block raised_amount;
      match state with
      | Active =>
        AssertNotZero _amount;

        (* update contribution and total raise amt  *)
        maybe_contributed <- contributions[id][_sender];
        contributed = getSomeInt maybe_contributed;
        new_contribution = builtin add contributed _amount;
        contributions[id][_sender] := new_contribution;
        new_raised_amount = builtin add raised_amount _amount;
        raised_amounts[id] := new_raised_amount;

        (* transfer zwap and zils *)
        TransferZWAP target;
        accept
      | _ =>
        err = CodeCannotContributeNow;
        ThrowError err
      end
    end
  end
end

(* @dev: Completes an offering. Not required to begin claiming / refunding.
  If raise amt is more than or equal to the minimum threshold:
    - transfers the raised amount to the token owner and lp address by on a pro-rata basis,
      up to the maximum given by the offering target and
    - burns all ZWAP collected.
  If raise amt is less than then minimum threshold,
    - refunds the tkn distribution amt to the token owner.
*)
transition Complete(id: Uint32)
  (* transfer zils by ratio *)
  (* burn zwap - due to rounding up, there may be some extra zwap locked in the contract - but
    it's probably not worth adding complexity to burn those tokens as they are permenantly locked anyway *)
  maybe_offering <- offerings[id];
  match maybe_offering with
  | None =>
    err = CodeOfferingNotFound;
    ThrowError err
  | Some offering =>
    (* unwrap all vars *)
    match offering with
    | Offering distribution target duration resolution =>
      match distribution with
      | Distribution token max_tkn =>
        match target with
        | Target max_zil max_zwap =>
          match resolution with
          | Resolution _ lp_share project_addr lp_addr =>
            (* get state *)
            current_block <- & BLOCKNUMBER;
            maybe_raised_amount <- raised_amounts[id];
            raised_amount = let x = getSomeInt maybe_raised_amount in min x max_zil;
            state = getState duration resolution current_block raised_amount;
            match state with
            | Failed =>
              (* refund all tkns *)
              msg_to_token =  {
                _tag : "Transfer"; _recipient: token; _amount: zero;
                to: project_addr; amount: max_tkn
              };
              msgs = oneMsg msg_to_token;
              send msgs
            | Completed =>
              (* compute lp amt *)
              lp_amount = let x = frac raised_amount lp_share max_zil in
                getSomeInt x; (* safe because lp_share < max_zil *)
              msg_to_lp = { _tag : "AddFunds"; _recipient: lp_addr; _amount: lp_amount };

              (* compute project amt *)
              project_amount = builtin sub raised_amount lp_amount;
              msg_to_project = { _tag : "AddFunds"; _recipient: project_addr; _amount: project_amount };

              (* compute zwap burn amt *)
              zwap_to_burn = let x = frac max_zwap raised_amount max_zil in
                getSomeInt x; (* safe because raised_amount <= max_zil *)
              msg_to_zwap =  {
                _tag : "Burn"; _recipient: zwap_token_contract; _amount: zero;
                burn_account: _this_address; amount: zwap_to_burn
              };

              (* compute tkn refund amt *)
              refund_amount =
                let x = frac max_tkn raised_amount max_zil in
                let distr = getSomeInt x in (* safe because raised_amount <= max_zil *)
                let distr_ceil = builtin add distr one in (* round up *)
                builtin sub max_tkn distr_ceil;
              msg_to_token =  {
                _tag : "Transfer"; _recipient: token; _amount: zero;
                to: project_addr; amount: refund_amount
              };

              (* send and burn! *)
              msgs =
                let nil_msg = Nil {Message} in
                let one_msg = Cons {Message} msg_to_project nil_msg in
                let two_msg = Cons {Message} msg_to_lp one_msg in
                let three_msg = Cons {Message} msg_to_zwap two_msg in
                Cons {Message} msg_to_token three_msg;
              send msgs
            | _ =>
              err = CodeCannotCompleteNow;
              ThrowError err
            end
          end
        end
      end
    end
  end
end

(* @dev: Transfers the allocated amount of tokens and refunds unused contribution
  to the sender if the offering is Completed. If the offering is Failed, all contribution
  is refunded. Reverts if the offering is in any other state. *)
transition Claim(id: Uint32)
  maybe_offering <- offerings[id];
  match maybe_offering with
  | None =>
    err = CodeOfferingNotFound;
    ThrowError err
  | Some offering =>
    match offering with
    | Offering distribution target duration resolution =>
      (* check contribution *)
      maybe_contributed <- contributions[id][_sender];
      match maybe_contributed with
      | None =>
        err = CodeContributionNotFound;
        ThrowError err
      | Some contribution =>
        (* check offering state *)
        current_block <- & BLOCKNUMBER;
        maybe_raised_amount <- raised_amounts[id];
        raised_amount = getSomeInt maybe_raised_amount;
        state = getState duration resolution current_block raised_amount;
        match state with
        | Completed =>
          target_amount = getTargetQAs target;
          above_target = builtin lt target_amount raised_amount;
          match above_target with
          | False =>
            (* if not above target cap, use amt directly *)
            Distribute distribution target contribution
          | True =>
            (* if above target cap, find pro-rated amt and refund remainder *)
            prorated_contribution =
              let x = frac contribution target_amount raised_amount in (* rounded down *)
              getSomeInt x; (* safe because target_amount < raised_amount *)
            refund =
              let r = builtin sub contribution prorated_contribution in
              builtin sub r one; (* refund slightly less to avoid issues caused by rounding down *)
            Distribute distribution target prorated_contribution;
            Refund distribution target refund
          end
        | Failed =>
          (* refund all *)
          Refund distribution target contribution
        | _ =>
          err = CodeCannotClaimNow;
          ThrowError err
        end
      end
    end
  end
end

(***************************************)
(*             Callbacks               *)
(***************************************)

transition TransferSuccessCallBack(sender : ByStr20, recipient : ByStr20, amount : Uint128)
  (* no-op *)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  (* no-op *)
end

transition BurnSuccessCallBack(burner: ByStr20, burn_account: ByStr20, amount: Uint128)
  (* no-op *)
end
