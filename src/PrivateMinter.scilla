scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
library PrivateMinter

(* Global variables *)
let zero = Uint128 0
let zero_uint256 = Uint256 0
let zero_uint32 = Uint32 0
let one = Uint256 1
let false = False
let true = True

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_uint256 =
  fun (some_uint256: Option Uint256) =>
    match some_uint256 with
    | Some num => num
    | None => zero_uint256
    end

let build_list : ByStr20 -> Uint32 -> List (ByStr20) =
  fun (to: ByStr20) => fun (m: Uint32) =>
    let zero_lt_m = builtin lt zero_uint32 m in
    match zero_lt_m with
    | True =>
        (* m is the nat to recurse on *)
        let m_nat = builtin to_nat m in
        let nil = Nil {ByStr20} in
        let list_init = nil in
        let step = fun (list :  List (ByStr20)) => fun (ignore : Nat) =>
          let new_list = Cons {ByStr20} to list in
          new_list
        in
        let fold = @nat_fold (List (ByStr20)) in
        let xs_m = fold step list_init m_nat in
        xs_m
    | False => Nil {ByStr20}
    end

(* Error exception *)
type Error =
  | CodeNotContractOwner 

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotContractOwner             => Int32 -1
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Minter
(
  contract_owner: ByStr20,
  zrc_address: ByStr20
)

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure MintHelper(to: ByStr20)
  msg1 = { _tag: "AddAndSetToken"; _recipient: zrc_address; _amount: Uint128 0;
          to: to };
  msg = one_msg msg1;
  send msg
end

(* @dev:    Mint new tokens privately.                        *)
(* @param:  to        - Address of the token recipient        *)
transition PrivateMint(to: ByStr20)
  IsContractOwner;
  MintHelper to;
  msg_to_recipient = { _tag : "RecipientAcceptMint"; _recipient : to; _amount : Uint128 0 };
  msg_to_sender = { _tag : "MintCallBack"; _recipient : _sender; _amount : Uint128 0;
                    recipient : to };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs;
  e = { _eventname: "AddApprovalSuccess"; initiator: _sender };
  event e;
  e = { _eventname: "MintSuccess"; by: _sender; recipient: to };
  event e
end

(* @dev:   BatchMint multiple new tokens privately.              *)
(* @param: to        - Address of the token recipient            *)
(* @param: size      - Number of tokens to mint                  *)
transition PrivateBatchMint(to: ByStr20, size: Uint32)
  IsContractOwner;
  size_uint128 = builtin to_uint128 size;
  input_list = build_list to size;
  size_uint256 = builtin to_uint256 size;
  get_size = get_uint256 size_uint256;
  (* Add to owner count *)
  msg1 = { _tag: "AddAndSetTokens"; _recipient: zrc_address; _amount: Uint128 0;
            input_list: input_list; size: get_size };
  msg_to_sender = { _tag : "BatchMintCallBack"; _recipient : _sender; _amount : Uint128 0 };
  msgs = two_msgs msg1 msg_to_sender;
  send msgs;
  e = { _eventname: "BatchAddApprovalSuccess"; initiator: _sender };
  event e;
  e = { _eventname: "BatchMintSuccess"; by: _sender; recipient: to };
  event e
end