scilla_version 0

import BoolUtils IntUtils ListUtils

library ZilSwapPool

type ReserveData =
| ReserveData of Uint128 Uint128 Uint128 Uint128 (* reserve0, reserve1, vReserve0, vReserve1 *)

let zero_address = 0x0000000000000000000000000000000000000000
let zero_amount = Uint128 0
let zero_block = BNum 0
let minimum_liquidity = Uint128 1000
let bps = Uint128 10000
let half_bps = Uint128 5000
let precision = Uint256 1000000000000000000 (* for decimal calculations (18dp precision) *)
let short_alpha = Uint256 370301795963710 (* 2 * precision / 5401 *)
let long_alpha = Uint256 185168039996296 (* (2 * precision) / 10801 *)

(* returns True if all items in the list is True *)
let all_true =
  fun (list : List Bool) =>
    let identity = fun (a: Bool) => a in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool identity list

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero_amount
    end

(* gets the virtual reserve if pool is amplified, or the real reserve otherwise *)
let get_reserve =
  fun (is_amp_pool : Bool) =>
  fun (virtual_reserve : Uint128) =>
  fun (real_reserve : Uint128) =>
    match is_amp_pool with
    | True => virtual_reserve
    | False => real_reserve
    end

let min =
  fun (a : Uint128) =>
  fun (b : Uint128) =>
    let a_lt_b = builtin lt a b in
    match a_lt_b with
    | True => a
    | False => b
    end

let max =
  fun (a : Uint128) =>
  fun (b : Uint128) =>
    let a_lt_b = builtin lt a b in
    match a_lt_b with
    | True => b
    | False => a
    end

(* @dev: (x * y) / z *)
let frac =
  fun (x : Uint128) =>
  fun (y : Uint128) =>
  fun (z : Uint128) =>
    let xy = builtin mul x y in
    builtin div xy z

let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

let shrink =
  fun (var : Int256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end

let reduce =
  fun (var : Uint256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end

(* @dev: ((precision - alpha) * ema + alpha * value) / precision; *)
let ema =
  fun (ema : Uint128) =>
  fun (alpha : Uint256) =>
  fun (value : Uint128) =>
    let e = grow ema in
    let v = grow value in
    let i_a = builtin sub precision alpha in
    let a = builtin mul i_a e in
    let b = builtin mul a v in
    let n = builtin add a b in
    builtin div n precision

(* @dev: returns r_factor_in_precision in Uint256 from short_ema and long_ema *)
(* function calculateRFactor(uint256 _shortEMA, uint256 _longEMA)
  internal
  pure
  returns (uint256)
{
  if (_longEMA == 0) {
      return 0;
  }
  return (_shortEMA * MathExt.PRECISION) / _longEMA;
} *)
let calculate_r_factor = 
  fun (short_ema : Uint256) =>
  fun (long_ema : Uint256) =>
    let zero_amount = Uint256 0 in 
    let is_eq = builtin eq long_ema zero_amount in 
    match is_eq with
    | True => zero_amount
    | False =>
      let s_e = builtin mul short_ema precision in 
      builtin div s_e long_ema
    end

(* @dev: returns final_fee in Uint128*)
(* function getFinalFee(uint256 feeInPrecision, uint32 _ampBps) internal pure returns (uint256) {
    if (_ampBps <= 20000) {
      return feeInPrecision;
    } else if (_ampBps <= 50000) {
      return (feeInPrecision * 20) / 30;
    } else if (_ampBps <= 200000) {
      return (feeInPrecision * 10) / 30;
    } else {
      return (feeInPrecision * 4) / 30;
    } 
*)
let get_final_fee = 
  fun (fee_in_precision : Uint256) =>
  fun (amp_bps : Uint128) =>
    let fee_in_precision_u128 = reduce fee_in_precision in
    let four = Uint128 4 in
    let ten = Uint128 10 in
    let twenty = Uint128 20 in
    let thirty = Uint128 30 in
    let two_bps = Uint128 20000 in
    let five_bps = Uint128 50000 in
    let twenty_bps = Uint128 200000 in
    let le_two_bps = uint128_le amp_bps two_bps in 
    match le_two_bps with
    | True => fee_in_precision_u128
    | False =>
      let le_five_bps = uint128_le amp_bps five_bps in
      match le_five_bps with 
      | True => 
        frac fee_in_precision_u128 twenty thirty 
      | False =>
        let le_twenty_bps = uint128_le amp_bps twenty_bps in
        match le_twenty_bps with
        | True => 
          frac fee_in_precision_u128 ten thirty
        | False => 
          frac fee_in_precision_u128 four thirty
        end
      end
    end
    
    
(* Error events *)
type Error =
| CodeIsSender
| CodeInsufficientFunds
| CodeInsufficientAllowance
| CodeNotFactory
| CodeInsufficientInput
| CodeInsufficientOutput
| CodeInsufficientLiquidity
| CodeInvalidToAddress
| CodeUnsyncedReserves
| CodeInvalidBalance

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeIsSender              => Int32 -1
      | CodeInsufficientFunds     => Int32 -2
      | CodeInsufficientAllowance => Int32 -3
      | CodeNotFactory            => Int32 -4
      | CodeInsufficientInput     => Int32 -5
      | CodeInsufficientOutput    => Int32 -6
      | CodeInsufficientLiquidity => Int32 -7
      | CodeInvalidToAddress      => Int32 -8
      | CodeUnsyncedReserves      => Int32 -9
      | CodeInvalidBalance        => Int32 -10
      end
    in
    { _exception : "Error"; code : result_code }

(* Dummy user-defined ADT *)
type Unit =
| Unit

contract ZilSwapPool
(
  init_token0 : ByStr20 with contract
    field total_supply : Uint128,
    field balances: Map ByStr20 Uint128,
    field allowances: Map ByStr20 (Map ByStr20 Uint128)
  end,
  init_token1 : ByStr20 with contract
    field total_supply : Uint128,
    field balances: Map ByStr20 Uint128,
    field allowances: Map ByStr20 (Map ByStr20 Uint128)
  end,
  init_factory : ByStr20 with contract
    field fee_configuration : Pair ByStr20 Uint128
  end,
  init_amp_bps : Uint128,
  (* zrc-2 required vars *)
  contract_owner: ByStr20,
  name : String,
  symbol : String,
  decimals : Uint32,
  init_supply : Uint128
)

with
  let not_identical_address = let eql = builtin eq init_token0 init_token1 in negb eql in
  let not_zero_address = let eql = builtin eq init_token0 zero_address in negb eql in
  let valid_bps = uint128_ge init_amp_bps bps in
  let valid_token_order = let a = builtin to_uint256 init_token0 in let b = builtin to_uint256 init_token1 in builtin lt a b in
  (* validate zrc-2 required vars *)
  let valid_owner = builtin eq init_factory contract_owner in
  let valid_init_supply = builtin eq init_supply zero_amount in
  let valid_decimals = let twelve = Uint32 12 in builtin eq decimals twelve in
  (* @dev: symbol and name is validated by initializer *)

  let l0 = Nil {Bool} in
  let l1 = Cons {Bool} not_identical_address l0 in
  let l2 = Cons {Bool} not_zero_address l1 in
  let l3 = Cons {Bool} valid_bps l2 in
  let l4 = Cons {Bool} valid_token_order l3 in
  let l5 = Cons {Bool} valid_owner l4 in
  let l6 = Cons {Bool} valid_init_supply l5 in
  let l7 = Cons {Bool} valid_decimals l6 in
  all_true l7
=>

(* @dev: to allow reading of these values by other contracts, these vars are not immutable even though
   @dev: they are never changed and cannot be changed. *)
field factory : ByStr20 with contract
  field fee_configuration : Pair ByStr20 Uint128 (* _feeTo, _governanceFeeBps *)
end = init_factory
field token0 : ByStr20 with contract
  field total_supply : Uint128,
  field balances: Map ByStr20 Uint128,
  field allowances: Map ByStr20 (Map ByStr20 Uint128)
end = init_token0
field token1 : ByStr20 with contract
  field total_supply : Uint128,
  field balances: Map ByStr20 Uint128,
  field allowances: Map ByStr20 (Map ByStr20 Uint128)
end = init_token1

field reserve0 : Uint128 = zero_amount
field reserve1 : Uint128 = zero_amount
field amp_bps : Uint128 = init_amp_bps

(* @dev: only used when amp factor > 1 *)
field v_reserve0 : Uint128 = zero_amount
field v_reserve1 : Uint128 = zero_amount

field k_last : Uint128 = zero_amount
field current_block_volume : Uint128 = zero_amount
field short_ema : Uint256 = Uint256 0
field long_ema : Uint256 = Uint256 0
field last_trade_block : BNum = zero_block

(* @dev: zrc-2 *)
field total_supply : Uint128 = zero_amount
field balances: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(*** zrc-2 ***)

procedure IsNotSender(address: ByStr20)
  is_sender = builtin eq _sender address;
  match is_sender with
  | True =>
    err = CodeIsSender;
    ThrowError err
  | False =>
  end
end

procedure AuthorizedMoveIfSufficientBalance(from: ByStr20, to: ByStr20, amount: Uint128)
  o_from_bal <- balances[from];
  bal = get_amount_or_zero o_from_bal;
  can_do = uint128_le amount bal;
  match can_do with
  | True =>
    (* Subtract amount from from and add it to to address *)
    new_from_bal = builtin sub bal amount;
    balances[from] := new_from_bal;
    (* Adds amount to to address *)
    get_to_bal <- balances[to];
    new_to_bal = match get_to_bal with
    | Some bal => builtin add bal amount
    | None => amount
    end;
    balances[to] := new_to_bal
  | False =>
    (* Balance not sufficient *)
    err = CodeInsufficientFunds;
    ThrowError err
  end
end

procedure AuthorizedMint(recipient: ByStr20, amount: Uint128)
  o_recipient_bal <- balances[recipient];
  bal = get_amount_or_zero o_recipient_bal;
  new_balance = builtin add amount bal;
  balances[recipient] := new_balance;
  current_total_supply <- total_supply;
  new_total_supply = builtin add current_total_supply amount;
  total_supply := new_total_supply;
  e = {_eventname: "Minted"; minter: _sender; recipient: recipient; amount: amount};
  event e
end

procedure AuthorizedBurnIfSufficientBalance(from: ByStr20, amount: Uint128)
  o_get_bal <- balances[from];
  bal = get_amount_or_zero o_get_bal;
  can_burn = uint128_le amount bal;
  match can_burn with
  | True =>
    (* Subtract amount from from *)
    new_balance = builtin sub bal amount;
    balances[from] := new_balance;
    current_total_supply <- total_supply;
    new_total_supply = builtin sub current_total_supply amount;
    total_supply := new_total_supply;
    e = {_eventname: "Burnt"; burner: _sender; burn_account: from; amount: amount};
    event e
  | False =>
    err = CodeInsufficientFunds;
    ThrowError err
  end
end

(*** pool ***)

procedure IsFactory(address: ByStr20)
  f <- factory;
  is_factory = builtin eq f address;
  match is_factory with
  | True =>
  | False =>
    err = CodeNotFactory;
    ThrowError err
  end
end

(* @dev: mints fee to fee address via liquidity tokens *)
procedure MintFee(is_amp_pool: Bool)
  fee_config <- & init_factory.fee_configuration;
  match fee_config with
  | Pair fee_to fee_bps =>
    is_fee_on = let is_zero_addr = builtin eq fee_to zero_address in negb is_zero_addr;
    match is_fee_on with
    | False =>
    | True =>
      kl <- k_last;
      v_r0_ <- v_reserve0;
      v_r1_ <- v_reserve1;
      r0_ <- reserve0;
      r1_ <- reserve1;
      r0 = match is_amp_pool with | False => r0_ | True => v_r0_ end;
      r1 = match is_amp_pool with | False => r1_ | True => v_r1_ end;
      t = builtin mul kl r0;
      t_r0 = builtin div t r0;
      is_eq = builtin eq t_r0 kl;
      collected_fee = match is_eq with (* value is in token 0 *)
      | True =>
        (* _vReserve0.sub(MathExt.sqrt(_tmp.div(_vReserve1))); *)
        let t_r1 = builtin div t r1 in
        let sqrt = builtin isqrt t_r1 in
        builtin sub r0 t_r1
      | False =>
        (* _vReserve0.sub(MathExt.sqrt(_kLast.div(_vReserve1).mul(_vReserve0))); *)
        let kl_r1 = builtin div kl r1 in
        let kl_r1_r0 = builtin mul kl_r1 r0 in
        let sqrt = builtin isqrt kl_r1_r0 in
        builtin sub r0 sqrt
      end;
      pool_value = let r1_value = frac r1_ r0 r1 in builtin add r0_ r1_value; (* value in token0 *)
      ts <- total_supply;
      liquidity =
        let numerator = let a = builtin mul ts collected_fee in builtin mul a fee_bps in
        let denominator = let a = builtin sub pool_value collected_fee in builtin mul a half_bps in
        builtin div numerator denominator;
      has_fee = builtin eq liquidity zero_amount;
      match has_fee with | False =>
      | True =>
        AuthorizedMint fee_to liquidity
      end
    end
  end
end

(* @dev: update reserves *)
procedure Update(is_amp_pool: Bool, data: ReserveData)
  match data with
  | ReserveData r0 r1 vr0 vr1 =>
    reserve0 := r0;
    reserve1 := r1;
    match is_amp_pool with
    | False =>
    | True =>
      v_reserve0 := vr0;
      v_reserve1 := vr1
    end
  end;
  e = {_eventname : "Sync"; data: data};
  event e
end

(* @dev: update last k value *)
procedure UpdateLastK(is_amp_pool: Bool, data: ReserveData)
  match data with
  | ReserveData r0 r1 vr0 vr1 =>
    match is_amp_pool with
    | True =>
      k = builtin mul vr0 vr1;
      k_last := k
    | False =>
      k = builtin mul r0 r1;
      k_last := k
    end
  end
end

(* @dev: Updates blocknumber *)
procedure RecordVolume(volume: Uint128)
  (*
    // this can not be underflow because block.number always increases
    uint256 skipBlock = blockNumber - lastTradeBlock;
    if (skipBlock == 0) {
        currentBlockVolume = safeUint128(
            uint256(currentBlockVolume).add(value),
            "volume exceeds valid range"
        );
        return calculateRFactor(uint256(shortEMA), uint256(longEMA));
    }
    uint128 _currentBlockVolume = currentBlockVolume;
    uint256 _shortEMA = newEMA(shortEMA, SHORT_ALPHA, currentBlockVolume);
    uint256 _longEMA = newEMA(longEMA, LONG_ALPHA, currentBlockVolume);
    // ema = ema * (1-aplha) ^(skipBlock -1)
    _shortEMA = _shortEMA.mulInPrecision(
        (PRECISION - SHORT_ALPHA).unsafePowInPrecision(skipBlock - 1)
    );
    _longEMA = _longEMA.mulInPrecision(
        (PRECISION - LONG_ALPHA).unsafePowInPrecision(skipBlock - 1)
    );
    shortEMA = safeUint128(_shortEMA);
    longEMA = safeUint128(_longEMA);
    currentBlockVolume = safeUint128(value);
    lastTradeBlock = safeUint128(blockNumber);

    emit UpdateEMA(_shortEMA, _longEMA, _currentBlockVolume, skipBlock);

    return calculateRFactor(_shortEMA, _longEMA);
  *)
  current_block <- & BLOCKNUMBER;
  last <- last_trade_block;
  is_first_trade = builtin eq last zero_block;
  last_block = match is_first_trade with
  | True => current_block
  | False => last
  end;
  blocks_skipped_u256 = builtin bsub current_block last_block;
  blocks_skipped = shrink blocks_skipped_u256;
  already_updated = builtin eq blocks_skipped zero_amount;
  match already_updated with
  | True =>
    v <- current_block_volume;
    new_volume = builtin add volume v;
    current_block_volume := new_volume
  | False =>
    current_block_volume := volume;
    prev_short_ema <- short_ema;
    prev_long_ema <- long_ema

    (* Where is this from? *)
    (* WIP
      s_e = get_ema prev_short_ema short_alpha current_block_volume;
      l_e = get_ema prev_long_ema long_alpha current_block_volume;
    *)
  end
end

procedure VerifyBalanceAndUpdateEMA(
  amount0_in: Uint128,
  amount1_in: Uint128,
  before_reserve0: Uint128,
  before_reserve1: Uint128,
  after_reserve0: Uint128,
  after_reserve1: Uint128
)
  (*
    uint256 volume = beforeReserve0.mul(amount1In).div(beforeReserve1).add(amount0In);
    uint256 rFactorInPrecision = recordNewUpdatedVolume(block.number, volume);
    feeInPrecision = getFinalFee(FeeFomula.getFee(rFactorInPrecision), ampBps);
    // verify balance update matches with fomula
    uint256 balance0Adjusted = afterReserve0.mul(PRECISION);
    balance0Adjusted = balance0Adjusted.sub(amount0In.mul(feeInPrecision));
    balance0Adjusted = balance0Adjusted / PRECISION;
    uint256 balance1Adjusted = afterReserve1.mul(PRECISION);
    balance1Adjusted = balance1Adjusted.sub(amount1In.mul(feeInPrecision));
    balance1Adjusted = balance1Adjusted / PRECISION;
    require(
        balance0Adjusted.mul(balance1Adjusted) >= beforeReserve0.mul(beforeReserve1),
        "DMM: K"
    );
  *)
  volume = let amt1_in_0 = frac before_reserve0 amount1_in before_reserve1 in builtin add amt1_in_0 amount0_in;
  RecordVolume volume;
  amp <- amp_bps;
  s_e <- short_ema;
  l_e <- long_ema;
  r_factor_in_precision = calculate_r_factor s_e l_e;
  fee_in_precision = get_final_fee r_factor_in_precision amp;

  balance_0_adjusted = 
    let after_reserve0_u256 = grow after_reserve0 in 
    let fee_in_precision_u256 = grow fee_in_precision in 
    let amount0_in_u256 = grow amount0_in in 
    let b0 = builtin mul after_reserve0_u256 precision in 
    let b0_a = builtin mul amount0_in_u256 fee_in_precision_u256 in 
    let b0_b = builtin sub b0 b0_a in 
    builtin div b0_b precision;
  
  balance_1_adjusted = 
    let after_reserve1_u256 = grow after_reserve1 in 
    let fee_in_precision_u256 = grow fee_in_precision in 
    let amount1_in_u256 = grow amount1_in in 
    let b1 = builtin mul after_reserve1_u256 precision in 
    let b1_a = builtin mul amount1_in_u256 fee_in_precision_u256 in 
    let b1_b = builtin sub b1 b1_a in 
    builtin div b1_b precision;
  
  before_adjustment = let before_adjustment_128 = builtin mul before_reserve0 before_reserve1 in grow before_adjustment_128;
  after_adjustment = builtin mul balance_0_adjusted balance_1_adjusted;
  is_ge = uint256_ge after_adjustment before_adjustment;
  match is_ge with
  | True =>
      e = {
        _eventname: "VerifyBalanceAndUpdateEMASuccess"; 
        amount0_in: amount0_in; 
        amount1_in: amount1_in;
        before_reserve0: before_reserve0;
        before_reserve1: before_reserve1;
        after_reserve0: after_reserve0;
        after_reserve1: after_reserve1
      };
      event e
  | False =>
      err = CodeInvalidBalance;
      ThrowError err
  end
end

(***************************************)
(*         ZRC-2 Transitions           *)
(***************************************)

(* @dev: Increase the allowance of an approved_spender over the caller tokens. Only token_owner allowed to invoke.   *)
(* param spender:      Address of the designated approved_spender.                                                   *)
(* param amount:       Number of tokens to be increased as allowance for the approved_spender.                       *)
transition IncreaseAllowance(spender: ByStr20, amount: Uint128)
  IsNotSender spender;
  some_current_allowance <- allowances[_sender][spender];
  current_allowance = get_amount_or_zero some_current_allowance;
  new_allowance = builtin add current_allowance amount;
  allowances[_sender][spender] := new_allowance;
  e = {_eventname : "IncreasedAllowance"; token_owner : _sender; spender: spender; new_allowance : new_allowance};
  event e
end

(* @dev: Decrease the allowance of an approved_spender over the caller tokens. Only token_owner allowed to invoke. *)
(* param spender:      Address of the designated approved_spender.                                                 *)
(* param amount:       Number of tokens to be decreased as allowance for the approved_spender.                     *)
transition DecreaseAllowance(spender: ByStr20, amount: Uint128)
  IsNotSender spender;
  some_current_allowance <- allowances[_sender][spender];
  current_allowance = get_amount_or_zero some_current_allowance;
  new_allowance =
    let amount_le_allowance = uint128_le amount current_allowance in
      match amount_le_allowance with
      | True => builtin sub current_allowance amount
      | False => zero_amount
      end;
  allowances[_sender][spender] := new_allowance;
  e = {_eventname : "DecreasedAllowance"; token_owner : _sender; spender: spender; new_allowance : new_allowance};
  event e
end

(* @dev: Moves an amount tokens from _sender to the recipient. Used by token_owner. *)
(* @dev: Balance of recipient will increase. Balance of _sender will decrease.      *)
(* @param to:  Address of the recipient whose balance is increased.                 *)
(* @param amount:     Amount of tokens to be sent.                                  *)
transition Transfer(to: ByStr20, amount: Uint128)
  AuthorizedMoveIfSufficientBalance _sender to amount;
  e = {_eventname : "TransferSuccess"; sender : _sender; recipient : to; amount : amount};
  event e;
  (* Prevent sending to a contract address that does not support transfers of token *)
  msg_to_recipient = {_tag : "RecipientAcceptTransfer"; _recipient : to; _amount : zero_amount;
                      sender : _sender; recipient : to; amount : amount};
  msg_to_sender = {_tag : "TransferSuccessCallBack"; _recipient : _sender; _amount : zero_amount;
                  sender : _sender; recipient : to; amount : amount};
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev: Move a given amount of tokens from one address to another using the allowance mechanism. The caller must be an approved_spender. *)
(* @dev: Balance of recipient will increase. Balance of token_owner will decrease.                                                        *)
(* @param from:    Address of the token_owner whose balance is decreased.                                                                 *)
(* @param to:      Address of the recipient whose balance is increased.                                                                   *)
(* @param amount:  Amount of tokens to be transferred.                                                                                    *)
transition TransferFrom(from: ByStr20, to: ByStr20, amount: Uint128)
  o_spender_allowed <- allowances[from][_sender];
  allowed = get_amount_or_zero o_spender_allowed;
  can_do = uint128_le amount allowed;
  match can_do with
  | True =>
    AuthorizedMoveIfSufficientBalance from to amount;
    e = {_eventname : "TransferFromSuccess"; initiator : _sender; sender : from; recipient : to; amount : amount};
    event e;
    new_allowed = builtin sub allowed amount;
    allowances[from][_sender] := new_allowed;
    (* Prevent sending to a contract address that does not support transfers of token *)
    msg_to_recipient = {_tag: "RecipientAcceptTransferFrom"; _recipient : to; _amount: zero_amount;
                        initiator: _sender; sender : from; recipient: to; amount: amount};
    msg_to_sender = {_tag: "TransferFromSuccessCallBack"; _recipient: _sender; _amount: zero_amount;
                    initiator: _sender; sender: from; recipient: to; amount: amount};
    msgs = two_msgs msg_to_recipient msg_to_sender;
    send msgs
  | False =>
    err = CodeInsufficientAllowance;
    ThrowError err
  end
end

(***************************************)
(*          Pool Transitions           *)
(***************************************)


(* @dev This low-level function should be called from a contract
   which performs important safety checks *)
transition Mint(to : ByStr20)
  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  r0 <- reserve0;
  r1 <- reserve1;
  vr0 <- v_reserve0;
  vr1 <- v_reserve1;

  m_r0 <- & init_token0.balances[_this_address];
  new_r0 = get_amount_or_zero m_r0;
  m_r1 <- & init_token1.balances[_this_address];
  new_r1 = get_amount_or_zero m_r1;

  amount0 = builtin sub new_r0 r0;
  amount1 = builtin sub new_r1 r1;

  MintFee is_amp_pool;

  supply <- total_supply;
  is_zero = builtin eq supply zero_amount;
  result = match is_zero with
  | True =>
    (* new pool *)
    let data = match is_amp_pool with
    | False =>
      ReserveData new_r0 new_r1 zero_amount zero_amount
    | True =>
      let v_r0 = let n0 = builtin mul new_r0 amp in builtin div n0 bps in
      let v_r1 = let n1 = builtin mul new_r1 amp in builtin div n1 bps in
      ReserveData new_r0 new_r1 v_r0 v_r1
    end in
    let liquidity = let x = builtin mul amount0 amount1 in let y = builtin isqrt x in builtin sub y minimum_liquidity in
    Pair {Uint128 ReserveData} liquidity data
  | False =>
    let liquidity =
      let a = frac amount0 supply r0 in
      let b = frac amount1 supply r1 in
      min a b
    in
    let data = match is_amp_pool with
    | False =>
      ReserveData new_r0 new_r1 zero_amount zero_amount
    | True =>
      let ls = builtin add liquidity supply in
      let v_r0 = let n0 = frac vr0 ls supply in max n0 new_r0 in
      let v_r1 = let n1 = frac vr1 ls supply in max n1 new_r1 in
      ReserveData new_r0 new_r1 v_r0 v_r1
    end in
    Pair {Uint128 ReserveData} liquidity data
  end;

  match is_zero with
  | False => | True =>
    (* permanently lock the first minimum_liquidity tokens *)
    AuthorizedMint zero_address minimum_liquidity
  end;

  match result with
  | Pair liquidity data =>
    mint_failed = builtin eq liquidity zero_amount;
    match mint_failed with
    | False => | True =>
      err = CodeInsufficientLiquidity;
      ThrowError err
    end;

    AuthorizedMint to liquidity;
    Update is_amp_pool data;
    UpdateLastK is_amp_pool data;

    e = {_eventname: "PoolMinted"; minter: _sender; amount0: amount0; amount1: amount1};
    event e
  end
end

(* @dev This low-level function should be called from a contract
   which performs important safety checks.
   User must transfer LP token to this contract before call burn *)
transition Burn(to : ByStr20)
  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  supply <- total_supply;
  r0 <- reserve0;
  r1 <- reserve1;
  v_r0 <- v_reserve0;
  v_r1 <- v_reserve1;

  m_b0 <- & init_token0.balances[_this_address];
  balance0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  balance1 = get_amount_or_zero m_b1;

  is_reserves_synced =
    let b0_ok = uint128_ge balance0 r0 in
    let b1_ok = uint128_ge balance1 r0 in
    andb b0_ok b1_ok;
  match is_reserves_synced with
  | True =>
  | False =>
    err = CodeUnsyncedReserves;
    ThrowError err
  end;

  MintFee is_amp_pool;

  supply <- total_supply;
  m_l <- balances[_this_address];
  liquidity = get_amount_or_zero m_l;

  amount0 = frac liquidity balance0 supply;
  amount1 = frac liquidity balance1 supply;

  is_sufficient_liquidity_burnt =
    let a0_ok = uint128_gt amount0 zero_amount in
    let a1_ok = uint128_gt amount1 zero_amount in
    andb a0_ok a1_ok;
  match is_sufficient_liquidity_burnt with
  | True =>
  | False =>
    err = CodeInsufficientLiquidity;
    ThrowError err
  end;

  AuthorizedBurnIfSufficientBalance _this_address liquidity;

  msg_to_token0 = {
    _tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
    to: _sender; amount: amount0
  };

  msg_to_token1 = {
    _tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
    to: _sender; amount: amount1
  };

  msgs = two_msgs msg_to_token0 msg_to_token1;
  send msgs;

  new_r0 = builtin sub balance0 amount0;
  new_r1 = builtin sub balance1 amount1;

  data = match is_amp_pool with
  | True =>
    let x = frac new_r0 supply r0 in
    let y = frac new_r1 supply r1 in
    let b = min x y in
    let vx = frac v_r0 b supply in
    let vy = frac v_r1 b supply in
    let v_r0 = max vx r0 in
    let v_r1 = max vy r1 in
    ReserveData new_r0 new_r1 v_r0 v_r1
  | False =>
    ReserveData new_r0 new_r1 zero_amount zero_amount
  end;

  Update is_amp_pool data;
  UpdateLastK is_amp_pool data;

  e = {_eventname: "PoolBurnt"; burner: _sender; amount0: amount0; amount1: amount1};
  event e
end

(* @dev This low-level function should be called from a contract
   which performs important safety checks *)
transition Swap(
  amount0_out: Uint128,
  amount1_out: Uint128,
  to: ByStr20
)
  (* validates if amount is not zero *)
  (* andb is logical and *)
  is_sending_t0 = uint128_gt amount0_out zero_amount; 
  is_sending_t1 = uint128_gt amount1_out zero_amount;

  is_sufficient_output = andb is_sending_t0 is_sending_t1;
  match is_sufficient_output with
  | True =>
  | False =>
    err = CodeInsufficientOutput;
    ThrowError err
  end;

  (* What is amp_bps? *)
  amp <- amp_bps; 
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  (* Assigning immutable params to local variables *)
  (* what does each of the params mean? *)
  supply <- total_supply;
  r0 <- reserve0;
  r1 <- reserve1;
  v_r0 <- v_reserve0;
  v_r1 <- v_reserve1;

  (* Checks if amount is less than amount in the pool *)
  is_sufficient_liquidity =
    let a0_ok = builtin lt amount0_out r0 in
    let a1_ok = builtin lt amount1_out r1 in
    andb a0_ok a1_ok;
    match is_sufficient_liquidity with
    | True =>
    | False =>
      err = CodeInsufficientLiquidity;
      ThrowError err
    end;

  (* Checks if the token address is the same as the to address? *)
  is_valid_to =
    let t0_ok = let e0 = builtin eq init_token0 to in negb e0 in
    let t1_ok = let e1 = builtin eq init_token1 to in negb e1 in
    andb t0_ok t1_ok;
  match is_valid_to with
  | True =>
  | False =>
    err = CodeInvalidToAddress;
    ThrowError err
  end;

  (* Transfers token0 to _sender*)
  (* _sender is the person/ contract calling this transition *)
  (* who is _sender? *)
  (* Transfer is only for token owner. In this case, ZilswapPool is the token owner *)
  match is_sending_t0 with
  | False =>
  | True =>
    msg_to_token0 = {
      _tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
      to: _sender; amount: amount0_out
    };
    msgs = one_msg msg_to_token0;
    send msgs
  end;

  match is_sending_t1 with
  | False =>
  | True =>
    msg_to_token1 = {
      _tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
      to: _sender; amount: amount1_out
    };
    msgs = one_msg msg_to_token1;
    send msgs
  end;

  (* init_token0 and init_token1 are zrc 2 contract addresses. *)
  (* Balance is a mutable field in zrc 2 contracts *)
  (* The balance of this pool contract is can be obtained by reading the state of the mutable fields *)
  m_b0 <- & init_token0.balances[_this_address];
  b0 = get_amount_or_zero m_b0;
  new_r0 = builtin sub b0 amount0_out;
  m_b1 <- & init_token1.balances[_this_address];
  b1 = get_amount_or_zero m_b1;
  new_r1 = builtin sub b1 amount1_out;

  (* what does amp_pool mean *)
  new_data = match is_amp_pool with
  | True =>
    let new_vr0 = let a = builtin add v_r0 new_r0 in builtin sub a r0 in
    let new_vr1 = let b = builtin add v_r1 new_r1 in builtin sub b r1 in
    ReserveData new_r0 new_r1 new_vr0 new_vr1
  | False =>
    ReserveData new_r0 new_r1 zero_amount zero_amount
  end;

  amount0_in =
    let has_input = uint128_gt new_r0 r0 in
    match has_input with
    | False => zero_amount
    | True => builtin sub new_r0 r0
    end;

  amount1_in =
    let has_input = uint128_gt new_r1 r1 in
    match has_input with
    | False => zero_amount
    | True => builtin sub new_r1 r1
    end;

  is_sufficient_input =
    let a0_ok = uint128_gt amount0_in zero_amount in
    let a1_ok = uint128_gt amount1_in zero_amount in
    andb a0_ok a1_ok;
  match is_sufficient_input with
  | True =>
  | False =>
    err = CodeInsufficientInput;
    ThrowError err
  end;

  match new_data with
  | ReserveData _ _ new_v_r0 new_v_r1 =>
    before_r0 = get_reserve is_amp_pool v_r0 r0;
    before_r1 = get_reserve is_amp_pool v_r1 r1;
    after_r0 = get_reserve is_amp_pool new_v_r0 new_r0;
    after_r1 = get_reserve is_amp_pool new_v_r1 new_r1;

    VerifyBalanceAndUpdateEMA
      amount0_in
      amount1_in
      before_r0
      before_r1
      after_r0
      after_r1
  end;

  Update is_amp_pool new_data;

  e = {
    _eventname: "PoolSwapped"; origin: _origin; sender: _sender;
    amount0_in: amount0_in; amount1_in: amount1_in;
    amount0_out: amount0_out; amount1_out: amount1_out;
    to: to
  };
  event e
end

(* @dev: Transfers tokens such that balances match reserves *)
transition Skim(
  to: ByStr20
)
(*
  token0.safeTransfer(to, token0.balanceOf(address(this)).sub(reserve0));
  token1.safeTransfer(to, token1.balanceOf(address(this)).sub(reserve1));
*)
  r_0 <- reserve0;
  r_1 <- reserve1;
  m_b0 <- & init_token0.balances[_this_address];
  balance0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  balance1 = get_amount_or_zero m_b1;

  amount0 = builtin sub balance0 r_0;
  amount1 = builtin sub balance1 r_1;

  msg_to_token0  = {
    _tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
    to: to; amount: amount0
  };

  msg_to_token1  = {
    _tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
    to: to; amount: amount1
  };

  msgs = two_msgs msg_to_token0 msg_to_token1;
  send msgs
end

(* @dev: force reserves to match balances *)
transition Sync()
  (* TODO:
    (bool isAmpPool, ReserveData memory data) = getReservesData();
    bool feeOn = _mintFee(isAmpPool, data);
    ReserveData memory newData;
    newData.reserve0 = IERC20(token0).balanceOf(address(this));
    newData.reserve1 = IERC20(token1).balanceOf(address(this));
    // update virtual reserves if this is amp pool
    if (isAmpPool) {
        uint256 _totalSupply = totalSupply();
        uint256 b = Math.min(
            newData.reserve0.mul(_totalSupply) / data.reserve0,
            newData.reserve1.mul(_totalSupply) / data.reserve1
        );
        newData.vReserve0 = Math.max(data.vReserve0.mul(b) / _totalSupply, newData.reserve0);
        newData.vReserve1 = Math.max(data.vReserve1.mul(b) / _totalSupply, newData.reserve1);
    }
    _update(isAmpPool, newData);
    if (feeOn) kLast = getK(isAmpPool, newData);
  *)

  r0 <- reserve0;
  r1 <- reserve1;
  vr0 <- v_reserve0;
  vr1 <- v_reserve1;

  m_b0 <- & init_token0.balances[_this_address];
  balance0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  balance1 = get_amount_or_zero m_b1;

  new_r0 = balance0;
  new_r1 = balance1;

  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  supply <- total_supply;

  b = 
    let c = frac new_r0 supply r0 in 
    let d = frac new_r1 supply r1 in
    min c d;

  data = match is_amp_pool with 
  | False =>
    ReserveData new_r0 new_r1 vr0 vr1
  | True =>
    let new_vr0 = 
      let x = frac vr0 b supply in 
      max x new_r0 in
    let new_vr1 = 
      let y = frac vr1 b supply in 
      max y new_r1 in
    ReserveData new_r0 new_r1 new_vr0 new_vr1
  end;

  Update is_amp_pool data;

  fee_config <- & init_factory.fee_configuration;
  match fee_config with
  | Pair fee_to fee_bps =>
    is_fee_on = let is_zero_addr = builtin eq fee_to zero_address in negb is_zero_addr;
    match is_fee_on with
    | False =>
    | True =>
      UpdateLastK is_amp_pool data
    end
  end
end
