scilla_version 0

import BoolUtils IntUtils ListUtils
library ZilSwapRouter

let zero_address = 0x0000000000000000000000000000000000000000
let zero_amount = Uint128 0
let zero_amount_u256 = Uint256 0
let minimum_liquidity = Uint128 1000
let bps = Uint128 10000
let none = None {ByStr20}
let two = Uint128 2
let one_hundred_and_two = Uint32 112
let q112 = builtin pow two one_hundred_and_two

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

(* Convert Uint128 to Uint256 *)
let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* @dev: (x * y) / z *)
let frac =
  fun (x : Uint128) =>
  fun (y : Uint128) =>
  fun (z : Uint128) =>
    let xy = builtin mul x y in
    builtin div xy z

(* amountB = amountA.mul(reserveB) / reserveA *)
let quote =
  fun (amountA : Uint128) =>
  fun (reserveA : Uint128) =>
  fun (reserveB : Uint128) =>
    frac amountA reserveB reserveA


let list_exists_bystr20 = @list_exists ByStr20

let list_or_empty =
  fun (maybe_list : Option (List ByStr20)) =>
  match maybe_list with
  | Some list => list
  | None => Nil {ByStr20}
  end

let add_once =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => list
    | False => Cons {ByStr20} item list
    end

let pool_exists =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => True
    | False => False
    end

(* Error events *)
type Error =
| CodeNotSelf
| CodeNotGovernor
| CodeNotPendingGovernor
| CodeDuplicateUnamplifiedPool
| CodeInvalidPool
| CodeInsufficientAmount
| CodeInsufficientLiquidity
| CodeBlockExpired

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotSelf                   => Int32 -1
      | CodeNotGovernor               => Int32 -2
      | CodeNotPendingGovernor        => Int32 -3
      | CodeDuplicateUnamplifiedPool  => Int32 -4
      | CodeInvalidPool               => Int32 -5
      | CodeInsufficientAmount        => Int32 -6
      | CodeInsufficientLiquidity     => Int32 -7
      | CodeBlockExpired              => Int32 -8
      end
    in
    { _exception : "Error"; code : result_code }

contract ZilSwapRouter
(
  init_governor : ByStr20
)

field governor : ByStr20 = init_governor
field pending_governor : Option ByStr20 = none
field fee_configuration : Pair ByStr20 Uint128 = Pair {ByStr20 Uint128} zero_address zero_amount

field all_pools : List ByStr20 = Nil {ByStr20}
field pools : Map ByStr20 (Map ByStr20 (List ByStr20)) = Emp ByStr20 (Map ByStr20 (List ByStr20))
field unamplified_pools : Map ByStr20 (Map ByStr20 ByStr20) = Emp ByStr20 (Map ByStr20 ByStr20)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(*** Factory ***)

procedure IsSelf(address : ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure AddOnceToPools(tokenA : ByStr20, tokenB : ByStr20, pool : ByStr20)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  p_new = add_once list pool;
  pools[tokenA][tokenB] := p_new
end

procedure VerifyPoolAddress( 
  tokenA : ByStr20, 
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end
  end
)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  e = pool_exists list pool;
  match e with 
  | True =>
  | False =>
    err = CodeInvalidPool;
    ThrowError err
  end
end

procedure Quote(amountA : Uint128, reserveA : Uint128, reserveB : Uint128)
  is_sufficient_amt = uint128_gt amountA zero_amount;
  match is_sufficient_amt with
  | True =>
    is_sufficient_liquidity = 
      let reserveA_ = uint128_gt reserveA zero_amount in 
      let reserveB_ = uint128_gt reserveB zero_amount in 
      andb reserveA_ reserveB_;
    match is_sufficient_liquidity with
    | True =>
    | False =>
      err = CodeInsufficientLiquidity;
      ThrowError err
    end
  | False =>
    err = CodeInsufficientAmount;
    ThrowError err
  end
end

(* Checks if amountA >= AmountB *)
procedure VerifyAmount(amountA : Uint128, amountB : Uint128)
  is_sufficient_amount = uint128_ge amountA amountB;
  match is_sufficient_amount with
  | True =>
  | False =>
    err = CodeInsufficientAmount;
    ThrowError err
  end
end

(* Checks if amountA >= AmountB *)
procedure VerifyBlock(deadline : BNum)
  current_block <- & BLOCKNUMBER;
  is_expired = builtin blt current_block deadline;
  match is_expired with
  | True =>
    err = CodeBlockExpired;
    ThrowError err
  | False =>
  end
end

(* Transfer ZRC-2 tokens to pool *)
procedure TransferZRC2ToPool(pool: ByStr20, token0: ByStr20, token1: ByStr20, amount0: Uint128, amount1: Uint128)
  msg_to_token0 = {_tag: "TransferFrom"; _recipient: token0; _amount: zero_amount;
                  from: _sender; to: pool; amount: amount0};
  msg_to_token1 = {_tag: "TransferFrom"; _recipient: token1; _amount: zero_amount;
                  from: _sender; to: pool; amount: amount1};
  msgs = two_msgs msg_to_token0 msg_to_token1;
  send msgs
end

(*** Governance ***)

procedure IsGovernor(address: ByStr20)
  g <- governor;
  is_owner = builtin eq g address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotGovernor;
    ThrowError err
  end
end

procedure IsPendingGovernor(address: ByStr20)
  maybe_pending_governor <- pending_governor;
  match maybe_pending_governor with
  | Some new_govenor =>
    is_pending_governor = builtin eq new_govenor address;
    match is_pending_governor with
    | True =>
    | False =>
      err = CodeNotPendingGovernor;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingGovernor;
    ThrowError err
  end
end

(***************************************)
(*         Factory Transitions         *)
(***************************************)

transition AddPool(
  pool : ByStr20 with contract
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field factory : ByStr20 with contract
      field fee_configuration : Pair ByStr20 Uint128
    end,
    field amp_bps : Uint128
  end
)
  (* validate factory *)
  f <- & pool.factory;
  IsSelf f;

  (* TODO: not possible now as init var cannot be fetched *)
  (* validate name and symbol *)
  (* t0 <- & pool.token0;
  symbol <- & t0 as ByStr20 with contract field symbol : String end;
  match symbol with
  | Some _ =>
  | None =>
    err = CodeNotSelf;
    ThrowError err
  end *)

  (* populate pool mapping for both directions *)
  token0 <- & pool.token0;
  token1 <- & pool.token1;
  AddOnceToPools token0 token1 pool;
  AddOnceToPools token1 token0 pool;

  amp_bps <- & pool.amp_bps;
  is_unamplified = builtin eq bps amp_bps;
  match is_unamplified with
  | False =>
  | True =>
    (* only allow one umaplified pool *)
    is_exists <- exists unamplified_pools[token0][token1];
    match is_exists with
    | False =>
    | True =>
      err = CodeDuplicateUnamplifiedPool;
      ThrowError err
    end;
    unamplified_pools[token0][token1] := pool;
    unamplified_pools[token1][token0] := pool
  end;

  ap <- all_pools;
  new_ap = add_once ap pool;
  all_pools := new_ap;

  e = {_eventname: "PoolCreated"; token0: token0; token1: token1; amp_bps: amp_bps};
  event e
end

(*** Governance ***)

transition SetFeeConfiguration(config: Pair ByStr20 Uint128)
    fee_configuration := config;
    e = {_eventname: "FeeConfigurationSet"; fee_configuration: config};
    event e
end

(* @dev: Transfers contract governorship to a new address. The new address must call the AcceptGovernorship transition to finalize the transfer. *)
(* @param new_governor: Address of the new governor.                                                                                    *)
transition SetGovernor(new_governor: ByStr20)
  IsGovernor _sender;
  g = Some {ByStr20} new_governor;
  pending_governor := g;
  e = {_eventname : "GovernanceTransferInitiated"; governor : _sender; pending_governor : new_governor};
  event e
end

(* @dev: Finalizes transfer of contract governance. Must be called by the pending governor. *)
transition AcceptGovernance()
  IsPendingGovernor _sender;
  previous_governor <- governor;
  governor := _sender;
  pending_governor := none;
  e = {_eventname : "GovernanceTransferAccepted"; previous_governor : previous_governor; governor : _sender};
  event e
end

(***************************************)
(*          Router Transitions         *)
(***************************************)

(*** LIQUIDITY ***)

(* function addLiquidity(
  IERC20 tokenA,
  IERC20 tokenB,
  address pool,
  uint256 amountADesired,
  uint256 amountBDesired,
  uint256 amountAMin,
  uint256 amountBMin,
  uint256[2] memory vReserveRatioBounds,
  address to,
  uint256 deadline
)
  public
  virtual
  override
  ensure(deadline)
  returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
  )
{
  verifyPoolAddress(tokenA, tokenB, pool);
  (amountA, amountB) = _addLiquidity(
      tokenA,
      tokenB,
      pool,
      amountADesired,
      amountBDesired,
      amountAMin,
      amountBMin,
      vReserveRatioBounds
  );
  // using tokenA.safeTransferFrom will get "Stack too deep"
  SafeERC20.safeTransferFrom(tokenA, msg.sender, pool, amountA);
  SafeERC20.safeTransferFrom(tokenB, msg.sender, pool, amountB);
  liquidity = IDMMPool(pool).mint(to);
} *)
(* @params: tokenA < tokenB (ie tokenA == token0, tokenB == token1 on Pool) *)
transition AddLiquidity(
  tokenA : ByStr20,
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128
  end,
  amountA_desired: Uint128,
  amountB_desired: Uint128,
  amountA_min: Uint128,
  amountB_min: Uint128,
  v_reserve_ratio_bounds: Uint128,
  to: ByStr20,
  deadline: BNum
)
  VerifyBlock deadline;
  VerifyPoolAddress tokenA tokenB pool;

  r_a <- & pool.reserve0;
  r_b <- & pool.reserve1;
  v_r_a <- & pool.v_reserve0;
  v_r_b <- & pool.v_reserve1;

  e = 
    let r_a_ = builtin eq r_a zero_amount in 
    let r_b_ = builtin eq r_b zero_amount in 
    andb r_a_ r_b_;
  match e with 
  | True =>
    amountA = amountA_desired;
    amountB = amountB_desired;
    TransferZRC2ToPool pool tokenA tokenB amountA amountB
  | False =>
    Quote amountA_desired r_a r_b;
    amountB_optimal = quote amountA_desired r_a r_b;
    is_sufficient_amountA = uint128_le amountB_optimal amountB_desired;
    match is_sufficient_amountA with
    | True =>
      VerifyAmount amountB_optimal amountB_min;
      amountA = amountA_desired;
      amountB = amountB_optimal;
      TransferZRC2ToPool pool tokenA tokenB amountA amountB
    | False =>
      amountA_optimal = quote amountB_desired r_b r_a;
      VerifyAmount amountA_desired amountA_optimal;
      VerifyAmount amountA_optimal amountA_min;
      amountA = amountA_optimal;
      amountB = amountB_desired;
      TransferZRC2ToPool pool tokenA tokenB amountA amountB
    end;
    current_rate = frac v_r_b q112 v_r_a

    (* _addLiquidity *)
    (* require(
      currentRate >= vReserveRatioBounds[0] && currentRate <= vReserveRatioBounds[1],
      "DMMRouter: OUT_OF_BOUNDS_VRESERVE"
    ); *)
  end;

  (* Calls Mint transition on Pool *)
  msg_to_pool = {_tag: "Mint"; _recipient: pool; _amount: zero_amount; to: to};
  msg = one_msg msg_to_pool;
  send msg
end

transition AddLiquidityZIL()
  (* TODO *)
end

(* // **** REMOVE LIQUIDITY ****
function removeLiquidity(
    IERC20 tokenA,
    IERC20 tokenB,
    address pool,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
) public override ensure(deadline) returns (uint256 amountA, uint256 amountB) {
    verifyPoolAddress(tokenA, tokenB, pool);
    IERC20(pool).safeTransferFrom(msg.sender, pool, liquidity); // send liquidity to pool
    (uint256 amount0, uint256 amount1) = IDMMPool(pool).burn(to);
    (IERC20 token0, ) = DMMLibrary.sortTokens(tokenA, tokenB);
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
    require(amountA >= amountAMin, "DMMRouter: INSUFFICIENT_A_AMOUNT");
    require(amountB >= amountBMin, "DMMRouter: INSUFFICIENT_B_AMOUNT");
} *)
(* @params: tokenA < tokenB (ie tokenA == token0, tokenB == token1 on Pool) *)
transition RemoveLiquidity(
  tokenA : ByStr20,
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128
  end,
  liquidity: Uint128,
  amountA_min: Uint128,
  amountB_min: Uint128,
  to: ByStr20,
  deadline: BNum
)
  VerifyBlock deadline;
  VerifyPoolAddress tokenA tokenB pool;

  (* require(amountA >= amountAMin, "DMMRouter: INSUFFICIENT_A_AMOUNT");
  require(amountB >= amountBMin, "DMMRouter: INSUFFICIENT_B_AMOUNT"); *)

  (* Sends liquidity to Pool *)
  msg_to_pool_1 = {_tag: "TransferFrom"; _recipient: pool; _amount: zero_amount; 
                from: _sender; to: pool; amount: liquidity};
  (* Calls Burn transition on Pool *)
  msg_to_pool_2 = {_tag: "Burn"; _recipient: pool; _amount: zero_amount; to: to};
  msgs = two_msgs msg_to_pool_1 msg_to_pool_2;
  send msgs
end

transition RemoveLiquidityZIL()
  (* TODO *)
end

(*** SWAP ***)

transition SwapExactTokensForTokens()
  (* TODO *)
end

transition SwapTokensForExactTokens()
  (* TODO *)
end

transition SwapExactZILForTokens()
  (* TODO *)
end

transition SwapTokensForExactZIL()
  (* TODO *)
end

transition SwapExactTokensForZIL()
  (* TODO *)
end

transition SwapZILForExactTokens()
  (* TODO *)
end


(*************************************)
(*             Callbacks             *)
(*************************************)

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using Transfer transition *)
transition TransferSuccessCallBack (sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end