scilla_version 0

import BoolUtils IntUtils ListUtils
library ZilSwapRouter

type ReserveData =
| ReserveData of Uint128 Uint128 Uint128 Uint128 (* reserve0, reserve1, vReserve0, vReserve1 *)

let zero_address = 0x0000000000000000000000000000000000000000
let zero_amount = Uint128 0
let zero_amount_u256 = Uint256 0
let minimum_liquidity = Uint128 1000
let bps = Uint128 10000
let none = None {ByStr20}
let two_u256 = Uint256 2
let one_hundred_and_twelve = Uint32 112
let q112 = builtin pow two_u256 one_hundred_and_twelve
let bps = Uint128 10000
let precision = Uint256 1000000000000000000 (* for decimal calculations (18dp precision) *)
let short_alpha = Uint256 370301795963710 (* 2 * precision / 5401 *)
let long_alpha = Uint256 185168039996296 (* (2 * precision) / 10801 *)


let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let list_exists_bystr20 = @list_exists ByStr20
let list_length_bystr20 = @list_length(ByStr20)
let list_zip_poolspath_path = @list_zip ByStr20 (Pair ByStr20 ByStr20)

(* @dev: (x * y) / z *)
let frac =
  fun (x : Uint128) =>
  fun (y : Uint128) =>
  fun (z : Uint128) =>
    let xy = builtin mul x y in
    builtin div xy z

(* @dev: amountB = amountA.mul(reserveB) / reserveA *)
let quote =
  fun (amountA : Uint128) =>
  fun (reserveA : Uint128) =>
  fun (reserveB : Uint128) =>
    frac amountA reserveB reserveA

(* @dev: Convert Uint128 to Uint256 *)
let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* @dev: Convert Uint256 to Uint128 *)
let reduce =
  fun (var : Uint256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end

let list_or_empty =
  fun (maybe_list : Option (List ByStr20)) =>
  match maybe_list with
  | Some list => list
  | None => Nil {ByStr20}
  end

let add_once =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => list
    | False => Cons {ByStr20} item list
    end

let pool_exists =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => True
    | False => False
    end

(* @dev: Returns init_token pair *)
let sort_token = 
  fun (path: Pair ByStr20 ByStr20 ) =>
  match path with
  | Pair token_in token_out =>
    let token_in_u256 = builtin to_uint256 token_in in
    let token_out_u256 = builtin to_uint256 token_out in
    let is_init_token0 = uint256_le token_in_u256 token_out_u256 in
    match is_init_token0 with 
    | True => path
    | False => Pair {ByStr20 ByStr20} token_out token_in
    end
  end

let get_trade_info = 
  fun (r_0: Uint128) =>
  fun (r_1: Uint128) =>
  fun (v_r_0: Uint128) =>
  fun (v_r_1: Uint128) =>
  fun (is_eq: Bool) =>
  fun (is_same_order: Bool) =>
  match is_eq with
  | True =>
    match is_same_order with
    | True =>
      ReserveData r_0 r_1 r_0 r_1
    | False =>
      ReserveData r_1 r_0 r_1 r_0
    end
  | False =>
    match is_same_order with
    | True =>
      ReserveData r_0 r_1 v_r_0 v_r_1
    | False =>
      ReserveData r_1 r_0 v_r_1 v_r_0
    end
  end


let calculate_r_factor = 
  fun (short_ema : Uint256) =>
  fun (long_ema : Uint256) =>
    let zero_amount = Uint256 0 in 
    let is_eq = builtin eq long_ema zero_amount in 
    match is_eq with
    | True => zero_amount
    | False =>
      let s_e = builtin mul short_ema precision in 
      builtin div s_e long_ema
    end

let get_final_fee = 
  fun (fee_in_precision : Uint256) =>
  fun (amp_bps : Uint128) =>
    let fee_in_precision_u128 = reduce fee_in_precision in
    let four = Uint128 4 in
    let ten = Uint128 10 in
    let twenty = Uint128 20 in
    let thirty = Uint128 30 in
    let two_bps = Uint128 20000 in
    let five_bps = Uint128 50000 in
    let twenty_bps = Uint128 200000 in
    let le_two_bps = uint128_le amp_bps two_bps in 
    match le_two_bps with
    | True => fee_in_precision_u128
    | False =>
      let le_five_bps = uint128_le amp_bps five_bps in
      match le_five_bps with 
      | True => 
        frac fee_in_precision_u128 twenty thirty 
      | False =>
        let le_twenty_bps = uint128_le amp_bps twenty_bps in
        match le_twenty_bps with
        | True => 
          frac fee_in_precision_u128 ten thirty
        | False => 
          frac fee_in_precision_u128 four thirty
        end
      end
    end

(* function getAmountOut(
  uint256 amountIn,
  uint256 reserveIn,
  uint256 reserveOut,
  uint256 vReserveIn,
  uint256 vReserveOut,
  uint256 feeInPrecision
) internal pure returns (uint256 amountOut) {
  require(amountIn > 0, "DMMLibrary: INSUFFICIENT_INPUT_AMOUNT");
  require(reserveIn > 0 && reserveOut > 0, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
  uint256 amountInWithFee = amountIn.mul(PRECISION.sub(feeInPrecision)).div(PRECISION);
  uint256 numerator = amountInWithFee.mul(vReserveOut);
  uint256 denominator = vReserveIn.add(amountInWithFee);
  amountOut = numerator.div(denominator);
  require(reserveOut > amountOut, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
} *)

let get_amount_out = 
  fun (amount_in: Uint128) =>
  fun (reserve_in: Uint128) =>
  fun (reserve_out: Uint128) =>
  fun (v_reserve_in: Uint128) =>
  fun (v_reserve_out: Uint128) =>
  fun (fee_in_precision: Uint128) =>
    let precision_u128 = reduce precision in
    let a = builtin sub precision_u128 fee_in_precision in
    let amount_in_with_fee = frac amount_in a precision_u128 in
    let numerator = builtin mul amount_in_with_fee v_reserve_out in
    let denominator = builtin add v_reserve_in amount_in_with_fee in
    builtin div numerator denominator


(* // given an output amount of an asset and pool reserves, returns a required input amount of the other asset
function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut,
    uint256 vReserveIn,
    uint256 vReserveOut,
    uint256 feeInPrecision
) internal pure returns (uint256 amountIn) {
    require(amountOut > 0, "DMMLibrary: INSUFFICIENT_OUTPUT_AMOUNT");
    require(reserveIn > 0 && reserveOut > amountOut, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
    uint256 numerator = vReserveIn.mul(amountOut);
    uint256 denominator = vReserveOut.sub(amountOut);
    amountIn = numerator.div(denominator).add(1);
    // amountIn = floor(amountIN *PRECISION / (PRECISION - feeInPrecision));
    numerator = amountIn.mul(PRECISION);
    denominator = PRECISION.sub(feeInPrecision);
    amountIn = numerator.add(denominator - 1).div(denominator);
} *)


let get_amount_in = 
  fun (amount_out: Uint128) =>
  fun (reserve_in: Uint128) =>
  fun (reserve_out: Uint128) =>
  fun (v_reserve_in: Uint128) =>
  fun (v_reserve_out: Uint128) =>
  fun (fee_in_precision: Uint128) =>
    let one = Uint128 1 in
    let precision_u128 = reduce precision in
    let n = builtin mul v_reserve_in amount_out in
    let d = builtin sub v_reserve_out amount_out in
    let a_i = builtin div n d in
    let amount_in = builtin add a_i one in
    let numerator = builtin mul amount_in precision_u128 in
    let denominator = builtin sub precision_u128 fee_in_precision in
    let d_minus_one = builtin sub numerator one in
    let n_a = builtin add numerator d_minus_one in
    builtin div n_a denominator

(* Error events *)
type Error =
| CodeNotSelf
| CodeNotGovernor
| CodeNotPendingGovernor
| CodeDuplicateUnamplifiedPool
| CodeInvalidPool
| CodeInsufficientAmount
| CodeInsufficientLiquidity
| CodeBlockExpired
| CodeOutOfBoundVReserve
| CodeInsufficientInputAmt
| CodeInsufficientOutputAmt
| CodeExcessiveInputAmt

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotSelf                   => Int32 -1
      | CodeNotGovernor               => Int32 -2
      | CodeNotPendingGovernor        => Int32 -3
      | CodeDuplicateUnamplifiedPool  => Int32 -4
      | CodeInvalidPool               => Int32 -5
      | CodeInsufficientAmount        => Int32 -6
      | CodeInsufficientLiquidity     => Int32 -7
      | CodeBlockExpired              => Int32 -8
      | CodeOutOfBoundVReserve        => Int32 -9
      | CodeInsufficientInputAmt      => Int32 -10
      | CodeInsufficientOutputAmt     => Int32 -11
      | CodeExcessiveInputAmt         => Int32 -12
      end
    in
    { _exception : "Error"; code : result_code }

contract ZilSwapRouter
(
  init_governor : ByStr20,
  init_codehash : ByStr32
)

field governor : ByStr20 = init_governor
field pending_governor : Option ByStr20 = none
field pool_codehash : ByStr32 = init_codehash
field fee_configuration : Pair ByStr20 Uint128 = Pair {ByStr20 Uint128} zero_address zero_amount

field all_pools : List ByStr20 = Nil {ByStr20}
field pools : Map ByStr20 (Map ByStr20 (List ByStr20)) = Emp ByStr20 (Map ByStr20 (List ByStr20))
field unamplified_pools : Map ByStr20 (Map ByStr20 ByStr20) = Emp ByStr20 (Map ByStr20 ByStr20)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(*** Factory ***)

procedure IsSelf(address : ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

(* validate the pool contract with correct codehash *)
procedure IsValidPoolContract(pool_address : ByStr20)
  maybe_pool <- & pool_address as ByStr20 with _codehash end;
  match maybe_pool with
  | None =>
  | Some p =>
    required_codehash <- pool_codehash;
    codehash <- & p._codehash;
    is_valid_pool = builtin eq codehash required_codehash;
    match is_valid_pool with
    | True =>
    | False =>
      err = CodeInvalidPool;
      ThrowError err
    end
  end
end

procedure AddOnceToPools(tokenA : ByStr20, tokenB : ByStr20, pool : ByStr20)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  p_new = add_once list pool;
  pools[tokenA][tokenB] := p_new
end

procedure VerifyPoolAddress( 
  tokenA : ByStr20, 
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end
  end
)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  e = pool_exists list pool;
  match e with 
  | True =>
  | False =>
    err = CodeInvalidPool;
    ThrowError err
  end
end

procedure Quote(amountA : Uint128, reserveA : Uint128, reserveB : Uint128)
  is_sufficient_amt = uint128_gt amountA zero_amount;
  match is_sufficient_amt with
  | True =>
    is_sufficient_liquidity = 
      let reserveA_ = uint128_gt reserveA zero_amount in 
      let reserveB_ = uint128_gt reserveB zero_amount in 
      andb reserveA_ reserveB_;
    match is_sufficient_liquidity with
    | True =>
    | False =>
      err = CodeInsufficientLiquidity;
      ThrowError err
    end
  | False =>
    err = CodeInsufficientAmount;
    ThrowError err
  end
end

(* Checks if amountA >= AmountB *)
procedure VerifyAmount(amountA : Uint128, amountB : Uint128)
  is_sufficient_amount = uint128_ge amountA amountB;
  match is_sufficient_amount with
  | True =>
  | False =>
    err = CodeInsufficientAmount;
    ThrowError err
  end
end

(* Checks if current_block >= deadline_block *)
procedure VerifyBlock(deadline_block : BNum)
  current_block <- & BLOCKNUMBER;
  is_expired = builtin blt deadline_block current_block;
  match is_expired with
  | True =>
    err = CodeBlockExpired;
    ThrowError err
  | False =>
  end
end

(* Transfer ZRC-2 tokens to pool *)
procedure TransferZRC2ToPool(pool: ByStr20, token0: ByStr20, token1: ByStr20, amount0: Uint128, amount1: Uint128)
  msg_to_token0 = {_tag: "TransferFrom"; _recipient: token0; _amount: zero_amount;
                  from: _sender; to: pool; amount: amount0};
  msg_to_token1 = {_tag: "TransferFrom"; _recipient: token1; _amount: zero_amount;
                  from: _sender; to: pool; amount: amount1};
  msgs = two_msgs msg_to_token0 msg_to_token1;
  send msgs
end

procedure Send(amount: Uint128, to_address : ByStr20)
  msg = { _tag : "AddFunds"; _recipient: to_address; _amount: amount };
  msgs = one_msg msg;
  send msgs
end


procedure VerifySufficientLiquidity(r_in: Uint128, r_out: Uint128, amount_in: Uint128, amount_out: Uint128)
  is_sufficient_liquidity = 
    let a = uint128_gt r_in amount_in in
    let b = uint128_gt r_out amount_out in
    andb a b;
  match is_sufficient_liquidity with
  | True =>
  | False =>
  err = CodeInsufficientLiquidity;
  ThrowError err
  end
end

(* function verifyPoolsPathSwap(address[] memory poolsPath, IERC20[] memory path) internal view {
  require(path.length >= 2, "DMMRouter: INVALID_PATH");
  require(poolsPath.length == path.length - 1, "DMMRouter: INVALID_POOLS_PATH");
  for (uint256 i = 0; i < poolsPath.length; i++) {
      verifyPoolAddress(path[i], path[i + 1], poolsPath[i]);
  }
} *)
(* procedure VerifyPoolsPathSwap(merged_path: Pair ByStr20 (Pair ByStr20 ByStr20))
  match merged_path with
  | Pair pool token_pair =>
    pool_ <- & pool as ByStr20 with contract 
      field token0 : ByStr20 with contract
        field total_supply : Uint128,
        field balances: Map ByStr20 Uint128,
        field allowances: Map ByStr20 (Map ByStr20 Uint128)
      end,
      field token1 : ByStr20 with contract
        field total_supply : Uint128,
        field balances: Map ByStr20 Uint128,
        field allowances: Map ByStr20 (Map ByStr20 Uint128)
      end
    end;
    match pool_ with
    | Some pool_address =>
      match token_pair with
      | Pair init_token0 init_token1 =>
        VerifyPoolAddress init_token0 init_token1 pool_address
      end
    | None =>
      err = CodeInvalidSwapPath;
      ThrowError err
    end
  end
end *)

(* function getAmountOut(
  uint256 amountIn,
  uint256 reserveIn,
  uint256 reserveOut,
  uint256 vReserveIn,
  uint256 vReserveOut,
  uint256 feeInPrecision
) internal pure returns (uint256 amountOut) {
  require(amountIn > 0, "DMMLibrary: INSUFFICIENT_INPUT_AMOUNT");
  require(reserveIn > 0 && reserveOut > 0, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
  uint256 amountInWithFee = amountIn.mul(PRECISION.sub(feeInPrecision)).div(PRECISION);
  uint256 numerator = amountInWithFee.mul(vReserveOut);
  uint256 denominator = vReserveIn.add(amountInWithFee);
  amountOut = numerator.div(denominator);
  require(reserveOut > amountOut, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
} *)

(* function getAmountsOut(
  uint256 amountIn,
  address[] memory poolsPath,
  IERC20[] memory path
) internal view returns (uint256[] memory amounts) {
  amounts = new uint256[](path.length);
  amounts[0] = amountIn;
  for (uint256 i; i < path.length - 1; i++) {
      (
          uint256 reserveIn,
          uint256 reserveOut,
          uint256 vReserveIn,
          uint256 vReserveOut,
          uint256 feeInPrecision
      ) = getTradeInfo(poolsPath[i], path[i], path[i + 1]);
      amounts[i + 1] = getAmountOut(
          amounts[i],
          reserveIn,
          reserveOut,
          vReserveIn,
          vReserveOut,
          feeInPrecision
      );
  }
} *)


(*** Governance ***)

procedure IsGovernor(address: ByStr20)
  g <- governor;
  is_owner = builtin eq g address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotGovernor;
    ThrowError err
  end
end

procedure IsPendingGovernor(address: ByStr20)
  maybe_pending_governor <- pending_governor;
  match maybe_pending_governor with
  | Some new_govenor =>
    is_pending_governor = builtin eq new_govenor address;
    match is_pending_governor with
    | True =>
    | False =>
      err = CodeNotPendingGovernor;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingGovernor;
    ThrowError err
  end
end

(***************************************)
(*         Factory Transitions         *)
(***************************************)

transition AddPool(
  pool : ByStr20 with contract
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field factory : ByStr20 with contract
      field fee_configuration : Pair ByStr20 Uint128
    end,
    field amp_bps : Uint128
  end
)
  (* validate factory *)
  f <- & pool.factory;
  IsSelf f;

  IsValidPoolContract pool;

  (* TODO: not possible now as init var cannot be fetched *)
  (* validate name and symbol *)
  (* t0 <- & pool.token0;
  symbol <- & t0 as ByStr20 with contract field symbol : String end;
  match symbol with
  | Some _ =>
  | None =>
    err = CodeNotSelf;
    ThrowError err
  end *)

  (* populate pool mapping for both directions *)
  token0 <- & pool.token0;
  token1 <- & pool.token1;
  AddOnceToPools token0 token1 pool;
  AddOnceToPools token1 token0 pool;

  amp_bps <- & pool.amp_bps;
  is_unamplified = builtin eq bps amp_bps;
  match is_unamplified with
  | False =>
  | True =>
    (* only allow one umaplified pool *)
    is_exists <- exists unamplified_pools[token0][token1];
    match is_exists with
    | False =>
    | True =>
      err = CodeDuplicateUnamplifiedPool;
      ThrowError err
    end;
    unamplified_pools[token0][token1] := pool;
    unamplified_pools[token1][token0] := pool
  end;

  ap <- all_pools;
  new_ap = add_once ap pool;
  all_pools := new_ap;

  e = {_eventname: "PoolCreated"; token0: token0; token1: token1; amp_bps: amp_bps};
  event e
end

(*** Governance ***)

transition SetFeeConfiguration(config: Pair ByStr20 Uint128)
    fee_configuration := config;
    e = {_eventname: "FeeConfigurationSet"; fee_configuration: config};
    event e
end

(* @dev: Transfers contract governorship to a new address. The new address must call the AcceptGovernorship transition to finalize the transfer. *)
(* @param new_governor: Address of the new governor.                                                                                    *)
transition SetGovernor(new_governor: ByStr20)
  IsGovernor _sender;
  g = Some {ByStr20} new_governor;
  pending_governor := g;
  e = {_eventname : "GovernanceTransferInitiated"; governor : _sender; pending_governor : new_governor};
  event e
end

(* @dev: Finalizes transfer of contract governance. Must be called by the pending governor. *)
transition AcceptGovernance()
  IsPendingGovernor _sender;
  previous_governor <- governor;
  governor := _sender;
  pending_governor := none;
  e = {_eventname : "GovernanceTransferAccepted"; previous_governor : previous_governor; governor : _sender};
  event e
end

(***************************************)
(*          Router Transitions         *)
(***************************************)

(*** LIQUIDITY ***)

(* function addLiquidity(
  IERC20 tokenA,
  IERC20 tokenB,
  address pool,
  uint256 amountADesired,
  uint256 amountBDesired,
  uint256 amountAMin,
  uint256 amountBMin,
  uint256[2] memory vReserveRatioBounds,
  address to,
  uint256 deadline
)
  public
  virtual
  override
  ensure(deadline)
  returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
  )
{
  verifyPoolAddress(tokenA, tokenB, pool);
  (amountA, amountB) = _addLiquidity(
      tokenA,
      tokenB,
      pool,
      amountADesired,
      amountBDesired,
      amountAMin,
      amountBMin,
      vReserveRatioBounds
  );
  // using tokenA.safeTransferFrom will get "Stack too deep"
  SafeERC20.safeTransferFrom(tokenA, msg.sender, pool, amountA);
  SafeERC20.safeTransferFrom(tokenB, msg.sender, pool, amountB);
  liquidity = IDMMPool(pool).mint(to);
} *)
(* @params: tokenA < tokenB (ie tokenA == token0, tokenB == token1 on Pool) *)
(* @params: v_reserve_ratio_bounds only applies for amp_pool *)
transition AddLiquidity(
  tokenA : ByStr20,
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field amp_bps : Uint128
  end,
  amountA_desired: Uint128,
  amountB_desired: Uint128,
  amountA_min: Uint128,
  amountB_min: Uint128,
  v_reserve_ratio_bounds: Pair Uint256 Uint256,
  to: ByStr20,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  VerifyPoolAddress tokenA tokenB pool;

  r_a <- & pool.reserve0;
  r_b <- & pool.reserve1;
  v_r_a <- & pool.v_reserve0;
  v_r_b <- & pool.v_reserve1;

  e = 
    let r_a_ = builtin eq r_a zero_amount in 
    let r_b_ = builtin eq r_b zero_amount in 
    andb r_a_ r_b_;
  match e with 
  | True =>
  (* pool with no liquidity *)
    amountA = amountA_desired;
    amountB = amountB_desired;
    TransferZRC2ToPool pool tokenA tokenB amountA amountB
  | False =>
  (* pool with existing liquidity *)
    Quote amountA_desired r_a r_b;
    amountB_optimal = quote amountA_desired r_a r_b;
    is_sufficient_amountB = uint128_le amountB_optimal amountB_desired;
    match is_sufficient_amountB with
    | True =>
      VerifyAmount amountB_optimal amountB_min;
      amountA = amountA_desired;
      amountB = amountB_optimal;
      TransferZRC2ToPool pool tokenA tokenB amountA amountB
    | False =>
      amountA_optimal = quote amountB_desired r_b r_a;
      VerifyAmount amountA_desired amountA_optimal;
      VerifyAmount amountA_optimal amountA_min;
      amountA = amountA_optimal;
      amountB = amountB_desired;
      TransferZRC2ToPool pool tokenA tokenB amountA amountB
    end;

    amp <- & pool.amp_bps;
    is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;
    match is_amp_pool with 
    | False => 
    | True =>
    (* only for amp pool *)
      current_rate = 
        let v_r_a_u256 = grow v_r_a in
        let v_r_b_u256 = grow v_r_b in
        let a = builtin mul v_r_b_u256 q112 in
        builtin div a v_r_a_u256;
      (* require(
        currentRate >= vReserveRatioBounds[0] && currentRate <= vReserveRatioBounds[1],
        "DMMRouter: OUT_OF_BOUNDS_VRESERVE"
      ); *)
      (* Always returns CodeOutOfBoundVReserve *)
      match v_reserve_ratio_bounds with
      | Pair l_bound u_bound =>
        is_not_out_of_bound_vreserve = 
          let l_b = uint256_ge current_rate l_bound in
          let u_b = uint256_le current_rate u_bound in
          andb l_b u_b;
        match is_not_out_of_bound_vreserve with 
        | True =>
        | False =>
          err = CodeOutOfBoundVReserve;
          ThrowError err
        end
      end
    end
  end;

  (* Calls Mint transition on Pool *)
  msg_to_pool = {_tag: "Mint"; _recipient: pool; _amount: zero_amount; to: to};
  msg = one_msg msg_to_pool;
  send msg
end

(* function addLiquidityETH(
  IERC20 token,
  address pool,
  uint256 amountTokenDesired,
  uint256 amountTokenMin,
  uint256 amountETHMin,
  uint256[2] memory vReserveRatioBounds,
  address to,
  uint256 deadline
)
  public
  override
  payable
  ensure(deadline)
  returns (
      uint256 amountToken,
      uint256 amountETH,
      uint256 liquidity
  )
{
  verifyPoolAddress(token, weth, pool);
  (amountToken, amountETH) = _addLiquidity(
      token,
      weth,
      pool,
      amountTokenDesired,
      msg.value,
      amountTokenMin,
      amountETHMin,
      vReserveRatioBounds
  );
  token.safeTransferFrom(msg.sender, pool, amountToken);
  weth.deposit{value: amountETH}();
  weth.safeTransfer(pool, amountETH);
  liquidity = IDMMPool(pool).mint(to);
  // refund dust eth, if any
  if (msg.value > amountETH) {
      TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
  }
} *)

(* transition should be called with _amount *)
transition AddLiquidityZIL(
  token : ByStr20,
  wZIL : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128
  end,
  amount_token_desired: Uint128,
  amount_wZIL_desired: Uint128,
  amount_token_min: Uint128,
  amount_wZIL_min: Uint128,
  v_reserve_ratio_bounds: Pair Uint128 Uint128,
  to: ByStr20,
  deadline_block: BNum
)
  (* VerifyBlock deadline_block; *)
  (* VerifyPoolAddress token wZIL pool; *)(* Order should not matter here *)

  (* r_a <- & pool.reserve0;
  r_b <- & pool.reserve1;
  v_r_a <- & pool.v_reserve0;
  v_r_b <- & pool.v_reserve1;

  e = 
    let r_a_ = builtin eq r_a zero_amount in 
    let r_b_ = builtin eq r_b zero_amount in 
    andb r_a_ r_b_;
  match e with 
  | True =>
    amount_token = amount_token_desired;
    amount_wZIL = amount_wZIL_desired; *)

    (* Send ZIL to wZIL contract and mint wZIL *)
    (* accept;
    msg_to_wZIL = { _tag: "Mint"; _recipient: wZIL; _amount: amount_wZIL };
    msg = one_msg msg_to_wZIL;
    send msg;
    TransferZRC2ToPool pool token wZIL amount_token amount_wZIL

  | False =>
    Quote amount_token_desired r_a r_b;
    amount_wZIL_optimal = quote amount_token_desired r_a r_b;

    is_sufficient_wZIL = uint128_le amount_wZIL_optimal amount_wZIL_desired;
    match is_sufficient_wZIL with
    | True =>
      VerifyAmount amount_wZIL_optimal amount_wZIL_min;
      amount_token = amount_token_desired;
      amount_wZIL = amount_wZIL_optimal;

      accept;
      msg_to_wZIL = { _tag: "Mint"; _recipient: wZIL; _amount: amount_wZIL };
      msg = one_msg msg_to_wZIL;
      send msg;
      refund = builtin sub _amount amount_wZIL;
      Send refund _sender;
      TransferZRC2ToPool pool token wZIL amount_token amount_wZIL
      
    | False =>
      amount_token_optimal = quote amount_wZIL_desired r_b r_a;
      VerifyAmount amount_token_desired amount_token_optimal;
      VerifyAmount amount_wZIL_optimal amount_wZIL_min;
      amount_token = amount_token_optimal;
      amount_wZIL = amount_wZIL_desired;

      accept;
      msg_to_wZIL = { _tag: "Mint"; _recipient: wZIL; _amount: amount_wZIL };
      msg = one_msg msg_to_wZIL;
      send msg;
      TransferZRC2ToPool pool token wZIL amount_token amount_wZIL

    end;
    current_rate = frac v_r_b q112 v_r_a;
    match v_reserve_ratio_bounds with
    | Pair l_bound u_bound =>
      is_out_of_bound_vreserve = 
        let l_b = uint128_ge current_rate l_bound in
        let u_b = uint128_le current_rate u_bound in
        andb l_b u_b;
      match is_out_of_bound_vreserve with 
      | True =>
      | False =>
        err = CodeOutOfBoundVReserve;
        ThrowError err
      end
    end
  end; *)
  
  (* Calls Mint transition on Pool *)
  (* msg_to_pool = {_tag: "Mint"; _recipient: pool; _amount: zero_amount; to: to};
  msg = one_msg msg_to_pool;
  send msg *)
end

(* // **** REMOVE LIQUIDITY ****
function removeLiquidity(
    IERC20 tokenA,
    IERC20 tokenB,
    address pool,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
) public override ensure(deadline) returns (uint256 amountA, uint256 amountB) {
    verifyPoolAddress(tokenA, tokenB, pool);
    IERC20(pool).safeTransferFrom(msg.sender, pool, liquidity); // send liquidity to pool
    (uint256 amount0, uint256 amount1) = IDMMPool(pool).burn(to);
    (IERC20 token0, ) = DMMLibrary.sortTokens(tokenA, tokenB);
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
    require(amountA >= amountAMin, "DMMRouter: INSUFFICIENT_A_AMOUNT");
    require(amountB >= amountBMin, "DMMRouter: INSUFFICIENT_B_AMOUNT");
} *)
(* @params: tokenA < tokenB (ie tokenA == token0, tokenB == token1 on Pool) *)
transition RemoveLiquidity(
  tokenA : ByStr20,
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128
  end,
  liquidity: Uint128,
  amountA_min: Uint128,
  amountB_min: Uint128,
  to: ByStr20,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  VerifyPoolAddress tokenA tokenB pool;

  (* Sends LP tokens to Pool *)
  msg_to_pool_1 = {_tag: "TransferFrom"; _recipient: pool; _amount: zero_amount; 
                from: _sender; to: pool; amount: liquidity};
  (* Calls Burn transition on Pool *)
  msg_to_pool_2 = {_tag: "Burn"; _recipient: pool; _amount: zero_amount; to: to};
  msgs = two_msgs msg_to_pool_1 msg_to_pool_2;
  send msgs
end

transition RemoveLiquidityZIL()
  (* TODO *)
end

(*** SWAP ***)

(* function swapExactTokensForTokens(
  uint256 amountIn,
  uint256 amountOutMin,
  address[] memory poolsPath,
  IERC20[] memory path,
  address to,
  uint256 deadline
) public virtual override ensure(deadline) returns (uint256[] memory amounts) {
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsOut(amountIn, poolsPath, path);
  require(
      amounts[amounts.length - 1] >= amountOutMin,
      "DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT"
  );
  IERC20(path[0]).safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, to);
} *)

(* @dev: pools_path: pool_address *)
(* @dev: path: token_in, token_out *)
(* @dev: to refers to the address of the last pool *)
transition SwapExactTokensForTokens(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool_path: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256
  end,
  path: Pair ByStr20 ByStr20,
  to: ByStr20,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  is_valid_amount_in = uint128_gt amount_in zero_amount;
  match is_valid_amount_in with
  | True =>
  | False =>
    err = CodeInsufficientInputAmt;
    ThrowError err
  end;

  match path with 
  | Pair token_in token_out =>
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      VerifyPoolAddress init_token0 init_token1 pool_path;
      r_0 <- & pool_path.reserve0;
      r_1 <- & pool_path.reserve1;
      v_r_0 <- & pool_path.v_reserve0;
      v_r_1 <- & pool_path.v_reserve1;
      amp <- & pool_path.amp_bps;
      s_e <- & pool_path.short_ema;
      l_e <- & pool_path.long_ema;
      r_factor_in_precision = calculate_r_factor s_e l_e;
      fee_in_precision = get_final_fee r_factor_in_precision amp;
  
      is_eq = builtin eq amp bps;
      is_same_order = builtin eq token_in init_token0;
  
      (* getAmountsOut *)
      data = get_trade_info r_0 r_1 v_r_0 v_r_1 is_eq is_same_order;
      match data with 
      | ReserveData r_in r_out v_r_in v_r_out =>
        amount_out = get_amount_out amount_in r_in r_out v_r_in v_r_out fee_in_precision;
        amount = Pair {Uint128 Uint128} amount_in amount_out;
  
        VerifySufficientLiquidity r_in r_out zero_amount zero_amount;

        is_valid_amount_out_min = uint128_gt amount_out amount_out_min;
        match is_valid_amount_out_min with 
        | True => | False => 
          err = CodeInsufficientOutputAmt;
          ThrowError err
        end;

        is_valid_reserve_out = uint128_gt r_out amount_out;
        match is_valid_reserve_out with 
        | True => | False => 
          err = CodeInsufficientLiquidity;
          ThrowError err
        end;

        (* _swap *)
        match is_same_order with
        | True =>
        (* Swap exact amt of init_token0 for init_token1 *)
          amount0_out = zero_amount;
          amount1_out = amount_out;
          msg_to_token = {_tag: "TransferFrom"; _recipient: init_token0; _amount: zero_amount;
                          from: _sender; to: pool_path; amount: amount_in};
          msg_to_pool = {_tag: "Swap"; _recipient: pool_path; _amount: zero_amount;
                        amount0_out: amount0_out; amount1_out: amount1_out; to: pool_path};
          msgs = two_msgs msg_to_token msg_to_pool;
          send msgs
        | False =>
        (* Swap exact amt of init_token1 for init_token0 *)
          amount0_out = amount_out;
          amount1_out = zero_amount;
          msg_to_token = {_tag: "TransferFrom"; _recipient: init_token1; _amount: zero_amount;
                          from: _sender; to: pool_path; amount: amount_in};
          msg_to_pool = {_tag: "Swap"; _recipient: pool_path; _amount: zero_amount;
                        amount0_out: amount0_out; amount1_out: amount1_out; to: pool_path};
          msgs = two_msgs msg_to_token msg_to_pool;
          send msgs
        end
      end
    end
  end
end

(* function swapTokensForExactTokens(
  uint256 amountOut,
  uint256 amountInMax,
  address[] memory poolsPath,
  IERC20[] memory path,
  address to,
  uint256 deadline
) public override ensure(deadline) returns (uint256[] memory amounts) {
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsIn(amountOut, poolsPath, path);
  require(amounts[0] <= amountInMax, "DMMRouter: EXCESSIVE_INPUT_AMOUNT");
  path[0].safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, to);
} *)

(* @dev: pools_path: pool_address *)
(* @dev: path: token_in, token_out *)
(* @dev: to refers to the address of the last pool *)
transition SwapTokensForExactTokens(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool_path: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256
  end,
  path: Pair ByStr20 ByStr20,
  to: ByStr20,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  is_valid_amount_out = uint128_gt amount_out zero_amount;
  match is_valid_amount_out with
  | True =>
  | False =>
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  match path with
  | Pair token_in token_out => 
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      VerifyPoolAddress init_token0 init_token1 pool_path;

      r_0 <- & pool_path.reserve0;
      r_1 <- & pool_path.reserve1;
      v_r_0 <- & pool_path.v_reserve0;
      v_r_1 <- & pool_path.v_reserve1;
      amp <- & pool_path.amp_bps;
      s_e <- & pool_path.short_ema;
      l_e <- & pool_path.long_ema;
      r_factor_in_precision = calculate_r_factor s_e l_e;
      fee_in_precision = get_final_fee r_factor_in_precision amp;

      is_eq = builtin eq amp bps;
      is_same_order = builtin eq token_in init_token0;

      (* getAmountsIn *)
      data = get_trade_info r_0 r_1 v_r_0 v_r_1 is_eq is_same_order;
      match data with 
      | ReserveData r_in r_out v_r_in v_r_out =>
        amount_in = get_amount_in amount_out r_in r_out v_r_in v_r_out fee_in_precision;
        amount = Pair {Uint128 Uint128} amount_in amount_out;

        VerifySufficientLiquidity r_in r_out zero_amount amount_out;

        is_valid_amount_in = uint128_le amount_in amount_in_max;
        match is_valid_amount_in with 
        | True => | False =>
          err = CodeExcessiveInputAmt;
          ThrowError err
        end;

        (* _swap *)
        match is_same_order with
        | True =>
        (* Swap exact amt of init_token0 for init_token1 *)
          amount0_out = zero_amount;
          amount1_out = amount_out;
          msg_to_token0 = {_tag: "TransferFrom"; _recipient: init_token0; _amount: zero_amount;
                          from: _sender; to: pool_path; amount: amount_in};
          msg_to_pool = {_tag: "Swap"; _recipient: pool_path; _amount: zero_amount;
                        amount0_out: amount0_out; amount1_out: amount1_out; to: pool_path};
          msgs = two_msgs msg_to_token0 msg_to_pool;
          send msgs
        | False =>
        (* Swap exact amt of init_token1 for init_token0 *)
          amount0_out = amount_out;
          amount1_out = zero_amount;
          msg_to_token0 = {_tag: "TransferFrom"; _recipient: init_token1; _amount: zero_amount;
                          from: _sender; to: pool_path; amount: amount_in};
          msg_to_pool = {_tag: "Swap"; _recipient: pool_path; _amount: zero_amount;
                        amount0_out: amount0_out; amount1_out: amount1_out; to: pool_path};
          msgs = two_msgs msg_to_token0 msg_to_pool;
          send msgs
        end
      end
    end
  end
end

transition SwapExactZILForTokens()
  (* TODO *)
end

transition SwapTokensForExactZIL()
  (* TODO *)
end

transition SwapExactTokensForZIL()
  (* TODO *)
end

transition SwapZILForExactTokens()
  (* TODO *)
end


(*************************************)
(*             Callbacks             *)
(*************************************)

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using TransferFrom transition *)
transition TransferFromSuccessCallBack (initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using Transfer transition *)
transition RecipientAcceptTransfer (sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end
