scilla_version 0

import ListUtils
library ZilSwapRouter

let zero_address = 0x0000000000000000000000000000000000000000
let zero_amount = Uint128 0
let minimum_liquidity = Uint128 1000
let bps = Uint128 10000
let none = None {ByStr20}

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let list_exists_bystr20 = @list_exists ByStr20

let list_or_empty =
  fun (maybe_list : Option (List ByStr20)) =>
  match maybe_list with
  | Some list => list
  | None => Nil {ByStr20}
  end

let add_once =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => list
    | False => Cons {ByStr20} item list
    end

let pool_exists =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => True
    | False => False
    end

(* Error events *)
type Error =
| CodeNotSelf
| CodeNotGovernor
| CodeNotPendingGovernor
| CodeDuplicateUnamplifiedPool
| CodeInvalidPool

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotSelf                   => Int32 -1
      | CodeNotGovernor               => Int32 -2
      | CodeNotPendingGovernor        => Int32 -3
      | CodeDuplicateUnamplifiedPool  => Int32 -4
      | CodeInvalidPool               => Int32 -5

      end
    in
    { _exception : "Error"; code : result_code }

contract ZilSwapRouter
(
  init_governor : ByStr20
)

field governor : ByStr20 = init_governor
field pending_governor : Option ByStr20 = none
field fee_configuration : Pair ByStr20 Uint128 = Pair {ByStr20 Uint128} zero_address zero_amount

field all_pools : List ByStr20 = Nil {ByStr20}
field pools : Map ByStr20 (Map ByStr20 (List ByStr20)) = Emp ByStr20 (Map ByStr20 (List ByStr20))
field unamplified_pools : Map ByStr20 (Map ByStr20 ByStr20) = Emp ByStr20 (Map ByStr20 ByStr20)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(*** Factory ***)

procedure IsSelf(address : ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

procedure AddOnceToPools(tokenA : ByStr20, tokenB : ByStr20, pool : ByStr20)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  p_new = add_once list pool;
  pools[tokenA][tokenB] := p_new
end


procedure VerifyPoolAddress( 
  tokenA : ByStr20, 
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end
  end
)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  e = pool_exists list pool;
  match e with 
  | True =>
  | False =>
    err = CodeInvalidPool;
    ThrowError err
  end
end

(*** Governance ***)

procedure IsGovernor(address: ByStr20)
  g <- governor;
  is_owner = builtin eq g address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotGovernor;
    ThrowError err
  end
end

procedure IsPendingGovernor(address: ByStr20)
  maybe_pending_governor <- pending_governor;
  match maybe_pending_governor with
  | Some new_govenor =>
    is_pending_governor = builtin eq new_govenor address;
    match is_pending_governor with
    | True =>
    | False =>
      err = CodeNotPendingGovernor;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingGovernor;
    ThrowError err
  end
end

(***************************************)
(*         Factory Transitions         *)
(***************************************)

transition AddPool(
  pool : ByStr20 with contract
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field factory : ByStr20 with contract
      field fee_configuration : Pair ByStr20 Uint128
    end,
    field amp_bps : Uint128
  end
)
  (* validate factory *)
  f <- & pool.factory;
  IsSelf f;

  (* TODO: not possible now as init var cannot be fetched *)
  (* validate name and symbol *)
  (* t0 <- & pool.token0;
  symbol <- & t0 as ByStr20 with contract field symbol : String end;
  match symbol with
  | Some _ =>
  | None =>
    err = CodeNotSelf;
    ThrowError err
  end *)

  (* populate pool mapping for both directions *)
  token0 <- & pool.token0;
  token1 <- & pool.token1;
  AddOnceToPools token0 token1 pool;
  AddOnceToPools token1 token0 pool;

  amp_bps <- & pool.amp_bps;
  is_unamplified = builtin eq bps amp_bps;
  match is_unamplified with
  | False =>
  | True =>
    (* only allow one umaplified pool *)
    is_exists <- exists unamplified_pools[token0][token1];
    match is_exists with
    | False =>
    | True =>
      err = CodeDuplicateUnamplifiedPool;
      ThrowError err
    end;
    unamplified_pools[token0][token1] := pool;
    unamplified_pools[token1][token0] := pool
  end;

  ap <- all_pools;
  new_ap = add_once ap pool;
  all_pools := new_ap;

  e = {_eventname: "PoolCreated"; token0: token0; token1: token1; amp_bps: amp_bps};
  event e
end

(*** Governance ***)

transition SetFeeConfiguration(config: Pair ByStr20 Uint128)
    fee_configuration := config;
    e = {_eventname: "FeeConfigurationSet"; fee_configuration: config};
    event e
end

(* @dev: Transfers contract governorship to a new address. The new address must call the AcceptGovernorship transition to finalize the transfer. *)
(* @param new_governor: Address of the new governor.                                                                                    *)
transition SetGovernor(new_governor: ByStr20)
  IsGovernor _sender;
  g = Some {ByStr20} new_governor;
  pending_governor := g;
  e = {_eventname : "GovernanceTransferInitiated"; governor : _sender; pending_governor : new_governor};
  event e
end

(* @dev: Finalizes transfer of contract governance. Must be called by the pending governor. *)
transition AcceptGovernance()
  IsPendingGovernor _sender;
  previous_governor <- governor;
  governor := _sender;
  pending_governor := none;
  e = {_eventname : "GovernanceTransferAccepted"; previous_governor : previous_governor; governor : _sender};
  event e
end

(***************************************)
(*          Router Transitions         *)
(***************************************)

(*** LIQUIDITY ***)


(* function addLiquidity(
  IERC20 tokenA,
  IERC20 tokenB,
  address pool,
  uint256 amountADesired,
  uint256 amountBDesired,
  uint256 amountAMin,
  uint256 amountBMin,
  uint256[2] memory vReserveRatioBounds,
  address to,
  uint256 deadline
)
  public
  virtual
  override
  ensure(deadline)
  returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
  )
{
  verifyPoolAddress(tokenA, tokenB, pool);
  (amountA, amountB) = _addLiquidity(
      tokenA,
      tokenB,
      pool,
      amountADesired,
      amountBDesired,
      amountAMin,
      amountBMin,
      vReserveRatioBounds
  );
  // using tokenA.safeTransferFrom will get "Stack too deep"
  SafeERC20.safeTransferFrom(tokenA, msg.sender, pool, amountA);
  SafeERC20.safeTransferFrom(tokenB, msg.sender, pool, amountB);
  liquidity = IDMMPool(pool).mint(to);
} *)
transition AddLiquidity(
  tokenA: ByStr20,
  tokenB: ByStr20,
  pool: ByStr20 with contract 
    field token0 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end,
    field token1 : ByStr20 with contract
      field total_supply : Uint128,
      field balances: Map ByStr20 Uint128,
      field allowances: Map ByStr20 (Map ByStr20 Uint128)
    end
  end,
  amountA_Desired: Uint256,
  amountB_Desired: Uint256,
  amountA_Min: Uint256,
  amountB_Min: Uint256,
  vReserve_Ratio_Bounds: Uint256,
  to: ByStr20,
  deadline: Uint256
)
  VerifyPoolAddress tokenA tokenB pool
end

transition AddLiquidityZIL()
  (* TODO *)
end

transition RemoveLiquidity()
  (* TODO *)
end

transition RemoveLiquidityZIL()
  (* TODO *)
end

(*** SWAP ***)

transition SwapExactTokensForTokens()
  (* TODO *)
end

transition SwapTokensForExactTokens()
  (* TODO *)
end

transition SwapExactZILForTokens()
  (* TODO *)
end

transition SwapTokensForExactZIL()
  (* TODO *)
end

transition SwapExactTokensForZIL()
  (* TODO *)
end

transition SwapZILForExactTokens()
  (* TODO *)
end
